/**
 * @file		thing.metadata.generated.ts
 * @company		 RHEA System S.A.
 * @copyright	Copyright (c) 2020  RHEA System S.A.
 * @summary		This is an auto-generated class. Any manual changes on this file will be overwritten!
 */
import { Utils } from "../../../utils/utils";
import { Cdp4Type } from "../../../types/ordered-item";
import { Dto } from "../dto.generated";

export module Metadata {
  /**
   * An Enumeration type to specify the kind of aggregation of a Property.
   */
  export enum AggregationKind {

    /**
     * Indicates that the Property has no aggregation.
     */
    None,

    /**
     * Indicates that the Property has shared aggregation.
     */
    Shared,

    /**
     * Indicates that the Property is aggregated compositely, i.e., the composite object has responsibility for the existence and storage of the composed objects (parts).
     */
    Composite
  }

  /**
   * A type that provides metadata information on the container of a Thing
   */
  export class ContainerMetadata {

    constructor(className: string,
                propertyName: string) {
      this.classKind = className;
      this.propertyName = propertyName;
    }

    /**
     * Gets or sets the name of container classKind
     */
    public classKind: string;

    /**
     * Gets or sets the type name of the container property
     */
    public propertyName: string;
  }

  /**
   * A type that provides metadata information on the property of a Thing
   */
  export class PropertyMetadata {

    constructor(name: string,
                typename: string,
                lowerCardinality: number,
                upperCardinality: string,
                aggregationKind: AggregationKind,
                isReadOnly: boolean,
                isOrdered: boolean,
                isValueArray: boolean,
                isDerived: boolean,
                isNullable: boolean,
                isPersisted: boolean,
                version: string) {
      this.name = name;
      this.typeName = typename;
      this.lowerCardinality = lowerCardinality;
      this.upperCardinality = upperCardinality;
      this.aggregationKind = aggregationKind;
      this.isReadOnly = isReadOnly;
      this.isOrdered = isOrdered;
      this.isValueArray = isValueArray;
      this.isDerived = isDerived;
      this.isNullable = isNullable;
      this.isPersisted = isPersisted;
      this.version = version;
    }

    /**
     * Gets or sets the name of the property
     */
    public name: string;

    /**
     * Gets or sets the type name of the property
     */
    public typeName: string;

    /**
     * Gets or sets the lower cardinality of the property
     */
    public lowerCardinality: number;

    /**
     * Gets or sets the upper cardinality of the property
     */
    public upperCardinality: string;

    /**
     * Gets or sets the aggregation kind of the property
     */
    public aggregationKind: AggregationKind;

    /**
     * Gets or sets a value indicating whether the property is read-only
     */
    public isReadOnly: boolean;

    /**
     * Gets or sets a value indicating whether the property is ordered
     */
    public isOrdered: boolean;

    /**
     * Gets or sets a value indicating whether the property is a value-array
     */
    public isValueArray: boolean;

    /**
     * Gets or sets a value indicating whether the property is derived
     */
    public isDerived: boolean;

    /**
     * Gets or sets a value indicating whether the property is nullable
     */
    public isNullable: boolean;

    /**
     * Gets or sets a value indicating whether the property is persisted
     */
    public isPersisted: boolean;

    /**
     * Gets or sets the version of the data-model related to this property
     */
    public version: string;
  }

  /**
   * A type that provides metadata information on a Thing
   */
  export interface IThingMetadata {

    /**
     * Gets or sets the name of the property
     */
    name: string;

    /**
     * Gets or sets the name of the base type
     */
    baseTypeName: string;

    /**
     * Gets or sets a value indicating whether the thing type is abstract
     */
    isAbstract: boolean;

    /**
     * Gets or sets the name of the container
     */
    container: ContainerMetadata;

    /**
     * Gets or sets the version of the data-model related to this property
     */
    version: string;

    /**
     * Gets or sets property metadata map
     */
    propertyMetaData: { [property: string]: PropertyMetadata };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    getContainerList(thing: Dto.Thing): { [propertyName: string]: string[] };

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    getOrderedContainerList(thing: Dto.Thing): { [propertyName: string]: Cdp4Type.OrderedItem[] };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the instance of a thing
     */
    getValue(dto: Dto.Thing, property: string): any;

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container for the created clone
     * @returns The clone of the thing
     */
    clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing;
  }

  /**
   * The metadata for ActionItem
   */
  class ActionItemMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ActionItem";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ModellingAnnotationItem";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModel", "modellingAnnotation");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "actionee": new PropertyMetadata("actionee", "Participant", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "approvedBy": new PropertyMetadata("approvedBy", "Approval", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "author": new PropertyMetadata("author", "Participant", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classification": new PropertyMetadata("classification", "AnnotationClassificationKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "closeOutDate": new PropertyMetadata("closeOutDate", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "closeOutStatement": new PropertyMetadata("closeOutStatement", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "discussion": new PropertyMetadata("discussion", "EngineeringModelDataDiscussionItem", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "dueDate": new PropertyMetadata("dueDate", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "primaryAnnotatedThing": new PropertyMetadata("primaryAnnotatedThing", "ModellingThingReference", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "relatedThing": new PropertyMetadata("relatedThing", "ModellingThingReference", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "sourceAnnotation": new PropertyMetadata("sourceAnnotation", "ModellingAnnotationItem", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "status": new PropertyMetadata("status", "AnnotationStatusKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "title": new PropertyMetadata("title", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const actionItem = <Dto.ActionItem>thing;
      return {
        "approvedBy": actionItem.approvedBy,
        "discussion": actionItem.discussion,
        "relatedThing": actionItem.relatedThing,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const actionItem = <Dto.ActionItem>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ActionItem) => any } = {
      "actionee": (dto : Dto.ActionItem) => { return dto.actionee },
      "approvedBy": (dto : Dto.ActionItem) => { return dto.approvedBy },
      "author": (dto : Dto.ActionItem) => { return dto.author },
      "category": (dto : Dto.ActionItem) => { return dto.category },
      "classification": (dto : Dto.ActionItem) => { return dto.classification },
      "classKind": (dto : Dto.ActionItem) => { return dto.classKind },
      "closeOutDate": (dto : Dto.ActionItem) => { return dto.closeOutDate },
      "closeOutStatement": (dto : Dto.ActionItem) => { return dto.closeOutStatement },
      "content": (dto : Dto.ActionItem) => { return dto.content },
      "createdOn": (dto : Dto.ActionItem) => { return dto.createdOn },
      "discussion": (dto : Dto.ActionItem) => { return dto.discussion },
      "dueDate": (dto : Dto.ActionItem) => { return dto.dueDate },
      "excludedDomain": (dto : Dto.ActionItem) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ActionItem) => { return dto.excludedPerson },
      "iid": (dto : Dto.ActionItem) => { return dto.iid },
      "languageCode": (dto : Dto.ActionItem) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.ActionItem) => { return dto.modifiedOn },
      "owner": (dto : Dto.ActionItem) => { return dto.owner },
      "primaryAnnotatedThing": (dto : Dto.ActionItem) => { return dto.primaryAnnotatedThing },
      "relatedThing": (dto : Dto.ActionItem) => { return dto.relatedThing },
      "revisionNumber": (dto : Dto.ActionItem) => { return dto.revisionNumber },
      "shortName": (dto : Dto.ActionItem) => { return dto.shortName },
      "sourceAnnotation": (dto : Dto.ActionItem) => { return dto.sourceAnnotation },
      "status": (dto : Dto.ActionItem) => { return dto.status },
      "title": (dto : Dto.ActionItem) => { return dto.title },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ActionItem>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ActionItem>dtoThing;
      const clone = new Dto.ActionItem(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.actionee = dto.actionee;
      clone.approvedBy = (dto.approvedBy !== undefined && dto.approvedBy !== null) ? dto.approvedBy.slice(0) : dto.approvedBy;
      clone.author = dto.author;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classification = dto.classification;
      clone.classKind = dto.classKind;
      clone.closeOutDate = dto.closeOutDate;
      clone.closeOutStatement = dto.closeOutStatement;
      clone.content = dto.content;
      clone.createdOn = dto.createdOn;
      clone.discussion = (dto.discussion !== undefined && dto.discussion !== null) ? dto.discussion.slice(0) : dto.discussion;
      clone.dueDate = dto.dueDate;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;
      clone.primaryAnnotatedThing = dto.primaryAnnotatedThing;
      clone.relatedThing = (dto.relatedThing !== undefined && dto.relatedThing !== null) ? dto.relatedThing.slice(0) : dto.relatedThing;
      clone.shortName = dto.shortName;
      clone.sourceAnnotation = (dto.sourceAnnotation !== undefined && dto.sourceAnnotation !== null) ? dto.sourceAnnotation.slice(0) : dto.sourceAnnotation;
      clone.status = dto.status;
      clone.title = dto.title;

      return clone;
    }
  }

  /**
   * The metadata for ActualFiniteState
   */
  class ActualFiniteStateMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ActualFiniteState";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ActualFiniteStateList", "actualState");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "kind": new PropertyMetadata("kind", "ActualFiniteStateKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "possibleState": new PropertyMetadata("possibleState", "PossibleFiniteState", 1, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const actualFiniteState = <Dto.ActualFiniteState>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const actualFiniteState = <Dto.ActualFiniteState>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ActualFiniteState) => any } = {
      "classKind": (dto : Dto.ActualFiniteState) => { return dto.classKind },
      "excludedDomain": (dto : Dto.ActualFiniteState) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ActualFiniteState) => { return dto.excludedPerson },
      "iid": (dto : Dto.ActualFiniteState) => { return dto.iid },
      "kind": (dto : Dto.ActualFiniteState) => { return dto.kind },
      "modifiedOn": (dto : Dto.ActualFiniteState) => { return dto.modifiedOn },
      "name": (dto : Dto.ActualFiniteState) => { return dto.name },
      "owner": (dto : Dto.ActualFiniteState) => { return dto.owner },
      "possibleState": (dto : Dto.ActualFiniteState) => { return dto.possibleState },
      "revisionNumber": (dto : Dto.ActualFiniteState) => { return dto.revisionNumber },
      "shortName": (dto : Dto.ActualFiniteState) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ActualFiniteState>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ActualFiniteState>dtoThing;
      const clone = new Dto.ActualFiniteState(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.kind = dto.kind;
      clone.modifiedOn = dto.modifiedOn;
      clone.possibleState = (dto.possibleState !== undefined && dto.possibleState !== null) ? dto.possibleState.slice(0) : dto.possibleState;

      return clone;
    }
  }

  /**
   * The metadata for ActualFiniteStateList
   */
  class ActualFiniteStateListMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ActualFiniteStateList";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "actualFiniteStateList");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "actualState": new PropertyMetadata("actualState", "ActualFiniteState", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludeOption": new PropertyMetadata("excludeOption", "Option", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "possibleFiniteStateList": new PropertyMetadata("possibleFiniteStateList", "PossibleFiniteStateList", 1, "*", AggregationKind.None, false, true, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const actualFiniteStateList = <Dto.ActualFiniteStateList>thing;
      return {
        "actualState": actualFiniteStateList.actualState,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const actualFiniteStateList = <Dto.ActualFiniteStateList>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ActualFiniteStateList) => any } = {
      "actualState": (dto : Dto.ActualFiniteStateList) => { return dto.actualState },
      "classKind": (dto : Dto.ActualFiniteStateList) => { return dto.classKind },
      "excludedDomain": (dto : Dto.ActualFiniteStateList) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ActualFiniteStateList) => { return dto.excludedPerson },
      "excludeOption": (dto : Dto.ActualFiniteStateList) => { return dto.excludeOption },
      "iid": (dto : Dto.ActualFiniteStateList) => { return dto.iid },
      "modifiedOn": (dto : Dto.ActualFiniteStateList) => { return dto.modifiedOn },
      "name": (dto : Dto.ActualFiniteStateList) => { return dto.name },
      "owner": (dto : Dto.ActualFiniteStateList) => { return dto.owner },
      "possibleFiniteStateList": (dto : Dto.ActualFiniteStateList) => { return dto.possibleFiniteStateList },
      "revisionNumber": (dto : Dto.ActualFiniteStateList) => { return dto.revisionNumber },
      "shortName": (dto : Dto.ActualFiniteStateList) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ActualFiniteStateList>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ActualFiniteStateList>dtoThing;
      const clone = new Dto.ActualFiniteStateList(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.actualState = (dto.actualState !== undefined && dto.actualState !== null) ? dto.actualState.slice(0) : dto.actualState;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.excludeOption = (dto.excludeOption !== undefined && dto.excludeOption !== null) ? dto.excludeOption.slice(0) : dto.excludeOption;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;
      clone.possibleFiniteStateList = (dto.possibleFiniteStateList !== undefined && dto.possibleFiniteStateList !== null) ? dto.possibleFiniteStateList.slice(0) : dto.possibleFiniteStateList;

      return clone;
    }
  }

  /**
   * The metadata for Alias
   */
  class AliasMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Alias";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("DefinedThing", "alias");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isSynonym": new PropertyMetadata("isSynonym", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const alias = <Dto.Alias>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const alias = <Dto.Alias>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Alias) => any } = {
      "classKind": (dto : Dto.Alias) => { return dto.classKind },
      "content": (dto : Dto.Alias) => { return dto.content },
      "excludedDomain": (dto : Dto.Alias) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Alias) => { return dto.excludedPerson },
      "iid": (dto : Dto.Alias) => { return dto.iid },
      "isSynonym": (dto : Dto.Alias) => { return dto.isSynonym },
      "languageCode": (dto : Dto.Alias) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.Alias) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.Alias) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Alias>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Alias>dtoThing;
      const clone = new Dto.Alias(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.isSynonym = dto.isSynonym;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;

      return clone;
    }
  }

  /**
   * The metadata for AndExpression
   */
  class AndExpressionMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "AndExpression";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "BooleanExpression";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ParametricConstraint", "expression");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "term": new PropertyMetadata("term", "BooleanExpression", 2, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const andExpression = <Dto.AndExpression>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const andExpression = <Dto.AndExpression>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.AndExpression) => any } = {
      "classKind": (dto : Dto.AndExpression) => { return dto.classKind },
      "excludedDomain": (dto : Dto.AndExpression) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.AndExpression) => { return dto.excludedPerson },
      "iid": (dto : Dto.AndExpression) => { return dto.iid },
      "modifiedOn": (dto : Dto.AndExpression) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.AndExpression) => { return dto.revisionNumber },
      "term": (dto : Dto.AndExpression) => { return dto.term },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.AndExpression>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.AndExpression>dtoThing;
      const clone = new Dto.AndExpression(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.term = (dto.term !== undefined && dto.term !== null) ? dto.term.slice(0) : dto.term;

      return clone;
    }
  }

  /**
   * The metadata for Approval
   */
  class ApprovalMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Approval";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "GenericAnnotation";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ModellingAnnotationItem", "approvedBy");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "author": new PropertyMetadata("author", "Participant", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classification": new PropertyMetadata("classification", "AnnotationApprovalKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const approval = <Dto.Approval>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const approval = <Dto.Approval>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Approval) => any } = {
      "author": (dto : Dto.Approval) => { return dto.author },
      "classification": (dto : Dto.Approval) => { return dto.classification },
      "classKind": (dto : Dto.Approval) => { return dto.classKind },
      "content": (dto : Dto.Approval) => { return dto.content },
      "createdOn": (dto : Dto.Approval) => { return dto.createdOn },
      "excludedDomain": (dto : Dto.Approval) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Approval) => { return dto.excludedPerson },
      "iid": (dto : Dto.Approval) => { return dto.iid },
      "languageCode": (dto : Dto.Approval) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.Approval) => { return dto.modifiedOn },
      "owner": (dto : Dto.Approval) => { return dto.owner },
      "revisionNumber": (dto : Dto.Approval) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Approval>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Approval>dtoThing;
      const clone = new Dto.Approval(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.author = dto.author;
      clone.classification = dto.classification;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.createdOn = dto.createdOn;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;

      return clone;
    }
  }

  /**
   * The metadata for ArrayParameterType
   */
  class ArrayParameterTypeMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ArrayParameterType";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "CompoundParameterType";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "parameterType");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "component": new PropertyMetadata("component", "ParameterTypeComponent", 1, "*", AggregationKind.Composite, false, true, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "dimension": new PropertyMetadata("dimension", "number", 1, "*", AggregationKind.None, false, true, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hasSingleComponentType": new PropertyMetadata("hasSingleComponentType", "boolean", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isFinalized": new PropertyMetadata("isFinalized", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isTensor": new PropertyMetadata("isTensor", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "numberOfValues": new PropertyMetadata("numberOfValues", "number", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "rank": new PropertyMetadata("rank", "number", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "symbol": new PropertyMetadata("symbol", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const arrayParameterType = <Dto.ArrayParameterType>thing;
      return {
        "alias": arrayParameterType.alias,
        "definition": arrayParameterType.definition,
        "hyperLink": arrayParameterType.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const arrayParameterType = <Dto.ArrayParameterType>thing;
      return {
        "component": arrayParameterType.component,
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ArrayParameterType) => any } = {
      "alias": (dto : Dto.ArrayParameterType) => { return dto.alias },
      "category": (dto : Dto.ArrayParameterType) => { return dto.category },
      "classKind": (dto : Dto.ArrayParameterType) => { return dto.classKind },
      "component": (dto : Dto.ArrayParameterType) => { return dto.component },
      "definition": (dto : Dto.ArrayParameterType) => { return dto.definition },
      "dimension": (dto : Dto.ArrayParameterType) => { return dto.dimension },
      "excludedDomain": (dto : Dto.ArrayParameterType) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ArrayParameterType) => { return dto.excludedPerson },
      "hasSingleComponentType": (dto : Dto.ArrayParameterType) => { return dto.hasSingleComponentType },
      "hyperLink": (dto : Dto.ArrayParameterType) => { return dto.hyperLink },
      "iid": (dto : Dto.ArrayParameterType) => { return dto.iid },
      "isDeprecated": (dto : Dto.ArrayParameterType) => { return dto.isDeprecated },
      "isFinalized": (dto : Dto.ArrayParameterType) => { return dto.isFinalized },
      "isTensor": (dto : Dto.ArrayParameterType) => { return dto.isTensor },
      "modifiedOn": (dto : Dto.ArrayParameterType) => { return dto.modifiedOn },
      "name": (dto : Dto.ArrayParameterType) => { return dto.name },
      "numberOfValues": (dto : Dto.ArrayParameterType) => { return dto.numberOfValues },
      "rank": (dto : Dto.ArrayParameterType) => { return dto.rank },
      "revisionNumber": (dto : Dto.ArrayParameterType) => { return dto.revisionNumber },
      "shortName": (dto : Dto.ArrayParameterType) => { return dto.shortName },
      "symbol": (dto : Dto.ArrayParameterType) => { return dto.symbol },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ArrayParameterType>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ArrayParameterType>dtoThing;
      const clone = new Dto.ArrayParameterType(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.component = (dto.component !== undefined && dto.component !== null) ? dto.component.slice(0) : dto.component;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.dimension = (dto.dimension !== undefined && dto.dimension !== null) ? dto.dimension.slice(0) : dto.dimension;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.isFinalized = dto.isFinalized;
      clone.isTensor = dto.isTensor;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;
      clone.symbol = dto.symbol;

      return clone;
    }
  }

  /**
   * The metadata for BinaryNote
   */
  class BinaryNoteMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "BinaryNote";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Note";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Page", "note");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "caption": new PropertyMetadata("caption", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "fileType": new PropertyMetadata("fileType", "FileType", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const binaryNote = <Dto.BinaryNote>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const binaryNote = <Dto.BinaryNote>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.BinaryNote) => any } = {
      "caption": (dto : Dto.BinaryNote) => { return dto.caption },
      "category": (dto : Dto.BinaryNote) => { return dto.category },
      "classKind": (dto : Dto.BinaryNote) => { return dto.classKind },
      "createdOn": (dto : Dto.BinaryNote) => { return dto.createdOn },
      "excludedDomain": (dto : Dto.BinaryNote) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.BinaryNote) => { return dto.excludedPerson },
      "fileType": (dto : Dto.BinaryNote) => { return dto.fileType },
      "iid": (dto : Dto.BinaryNote) => { return dto.iid },
      "modifiedOn": (dto : Dto.BinaryNote) => { return dto.modifiedOn },
      "name": (dto : Dto.BinaryNote) => { return dto.name },
      "owner": (dto : Dto.BinaryNote) => { return dto.owner },
      "revisionNumber": (dto : Dto.BinaryNote) => { return dto.revisionNumber },
      "shortName": (dto : Dto.BinaryNote) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.BinaryNote>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.BinaryNote>dtoThing;
      const clone = new Dto.BinaryNote(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.caption = dto.caption;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.createdOn = dto.createdOn;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.fileType = dto.fileType;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.owner = dto.owner;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for BinaryRelationship
   */
  class BinaryRelationshipMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "BinaryRelationship";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Relationship";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "relationship");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "parameterValue": new PropertyMetadata("parameterValue", "RelationshipParameterValue", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "source": new PropertyMetadata("source", "Thing", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "target": new PropertyMetadata("target", "Thing", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const binaryRelationship = <Dto.BinaryRelationship>thing;
      return {
        "parameterValue": binaryRelationship.parameterValue,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const binaryRelationship = <Dto.BinaryRelationship>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.BinaryRelationship) => any } = {
      "category": (dto : Dto.BinaryRelationship) => { return dto.category },
      "classKind": (dto : Dto.BinaryRelationship) => { return dto.classKind },
      "excludedDomain": (dto : Dto.BinaryRelationship) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.BinaryRelationship) => { return dto.excludedPerson },
      "iid": (dto : Dto.BinaryRelationship) => { return dto.iid },
      "modifiedOn": (dto : Dto.BinaryRelationship) => { return dto.modifiedOn },
      "owner": (dto : Dto.BinaryRelationship) => { return dto.owner },
      "parameterValue": (dto : Dto.BinaryRelationship) => { return dto.parameterValue },
      "revisionNumber": (dto : Dto.BinaryRelationship) => { return dto.revisionNumber },
      "source": (dto : Dto.BinaryRelationship) => { return dto.source },
      "target": (dto : Dto.BinaryRelationship) => { return dto.target },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.BinaryRelationship>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.BinaryRelationship>dtoThing;
      const clone = new Dto.BinaryRelationship(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;
      clone.parameterValue = (dto.parameterValue !== undefined && dto.parameterValue !== null) ? dto.parameterValue.slice(0) : dto.parameterValue;
      clone.source = dto.source;
      clone.target = dto.target;

      return clone;
    }
  }

  /**
   * The metadata for BinaryRelationshipRule
   */
  class BinaryRelationshipRuleMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "BinaryRelationshipRule";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Rule";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "rule");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "forwardRelationshipName": new PropertyMetadata("forwardRelationshipName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "inverseRelationshipName": new PropertyMetadata("inverseRelationshipName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "relationshipCategory": new PropertyMetadata("relationshipCategory", "Category", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "sourceCategory": new PropertyMetadata("sourceCategory", "Category", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "targetCategory": new PropertyMetadata("targetCategory", "Category", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const binaryRelationshipRule = <Dto.BinaryRelationshipRule>thing;
      return {
        "alias": binaryRelationshipRule.alias,
        "definition": binaryRelationshipRule.definition,
        "hyperLink": binaryRelationshipRule.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const binaryRelationshipRule = <Dto.BinaryRelationshipRule>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.BinaryRelationshipRule) => any } = {
      "alias": (dto : Dto.BinaryRelationshipRule) => { return dto.alias },
      "classKind": (dto : Dto.BinaryRelationshipRule) => { return dto.classKind },
      "definition": (dto : Dto.BinaryRelationshipRule) => { return dto.definition },
      "excludedDomain": (dto : Dto.BinaryRelationshipRule) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.BinaryRelationshipRule) => { return dto.excludedPerson },
      "forwardRelationshipName": (dto : Dto.BinaryRelationshipRule) => { return dto.forwardRelationshipName },
      "hyperLink": (dto : Dto.BinaryRelationshipRule) => { return dto.hyperLink },
      "iid": (dto : Dto.BinaryRelationshipRule) => { return dto.iid },
      "inverseRelationshipName": (dto : Dto.BinaryRelationshipRule) => { return dto.inverseRelationshipName },
      "isDeprecated": (dto : Dto.BinaryRelationshipRule) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.BinaryRelationshipRule) => { return dto.modifiedOn },
      "name": (dto : Dto.BinaryRelationshipRule) => { return dto.name },
      "relationshipCategory": (dto : Dto.BinaryRelationshipRule) => { return dto.relationshipCategory },
      "revisionNumber": (dto : Dto.BinaryRelationshipRule) => { return dto.revisionNumber },
      "shortName": (dto : Dto.BinaryRelationshipRule) => { return dto.shortName },
      "sourceCategory": (dto : Dto.BinaryRelationshipRule) => { return dto.sourceCategory },
      "targetCategory": (dto : Dto.BinaryRelationshipRule) => { return dto.targetCategory },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.BinaryRelationshipRule>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.BinaryRelationshipRule>dtoThing;
      const clone = new Dto.BinaryRelationshipRule(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.forwardRelationshipName = dto.forwardRelationshipName;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.inverseRelationshipName = dto.inverseRelationshipName;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.relationshipCategory = dto.relationshipCategory;
      clone.shortName = dto.shortName;
      clone.sourceCategory = dto.sourceCategory;
      clone.targetCategory = dto.targetCategory;

      return clone;
    }
  }

  /**
   * The metadata for Book
   */
  class BookMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Book";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModel", "book");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "section": new PropertyMetadata("section", "Section", 0, "*", AggregationKind.Composite, false, true, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const book = <Dto.Book>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const book = <Dto.Book>thing;
      return {
        "section": book.section,
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Book) => any } = {
      "category": (dto : Dto.Book) => { return dto.category },
      "classKind": (dto : Dto.Book) => { return dto.classKind },
      "createdOn": (dto : Dto.Book) => { return dto.createdOn },
      "excludedDomain": (dto : Dto.Book) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Book) => { return dto.excludedPerson },
      "iid": (dto : Dto.Book) => { return dto.iid },
      "modifiedOn": (dto : Dto.Book) => { return dto.modifiedOn },
      "name": (dto : Dto.Book) => { return dto.name },
      "owner": (dto : Dto.Book) => { return dto.owner },
      "revisionNumber": (dto : Dto.Book) => { return dto.revisionNumber },
      "section": (dto : Dto.Book) => { return dto.section },
      "shortName": (dto : Dto.Book) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Book>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Book>dtoThing;
      const clone = new Dto.Book(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.createdOn = dto.createdOn;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.owner = dto.owner;
      clone.section = (dto.section !== undefined && dto.section !== null) ? dto.section.slice(0) : dto.section;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for BooleanParameterType
   */
  class BooleanParameterTypeMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "BooleanParameterType";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ScalarParameterType";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "parameterType");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "numberOfValues": new PropertyMetadata("numberOfValues", "number", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "symbol": new PropertyMetadata("symbol", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const booleanParameterType = <Dto.BooleanParameterType>thing;
      return {
        "alias": booleanParameterType.alias,
        "definition": booleanParameterType.definition,
        "hyperLink": booleanParameterType.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const booleanParameterType = <Dto.BooleanParameterType>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.BooleanParameterType) => any } = {
      "alias": (dto : Dto.BooleanParameterType) => { return dto.alias },
      "category": (dto : Dto.BooleanParameterType) => { return dto.category },
      "classKind": (dto : Dto.BooleanParameterType) => { return dto.classKind },
      "definition": (dto : Dto.BooleanParameterType) => { return dto.definition },
      "excludedDomain": (dto : Dto.BooleanParameterType) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.BooleanParameterType) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.BooleanParameterType) => { return dto.hyperLink },
      "iid": (dto : Dto.BooleanParameterType) => { return dto.iid },
      "isDeprecated": (dto : Dto.BooleanParameterType) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.BooleanParameterType) => { return dto.modifiedOn },
      "name": (dto : Dto.BooleanParameterType) => { return dto.name },
      "numberOfValues": (dto : Dto.BooleanParameterType) => { return dto.numberOfValues },
      "revisionNumber": (dto : Dto.BooleanParameterType) => { return dto.revisionNumber },
      "shortName": (dto : Dto.BooleanParameterType) => { return dto.shortName },
      "symbol": (dto : Dto.BooleanParameterType) => { return dto.symbol },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.BooleanParameterType>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.BooleanParameterType>dtoThing;
      const clone = new Dto.BooleanParameterType(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;
      clone.symbol = dto.symbol;

      return clone;
    }
  }

  /**
   * The metadata for Bounds
   */
  class BoundsMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Bounds";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DiagramThingBase";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("DiagramElementContainer", "bounds");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "height": new PropertyMetadata("height", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "width": new PropertyMetadata("width", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "x": new PropertyMetadata("x", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "y": new PropertyMetadata("y", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const bounds = <Dto.Bounds>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const bounds = <Dto.Bounds>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Bounds) => any } = {
      "classKind": (dto : Dto.Bounds) => { return dto.classKind },
      "excludedDomain": (dto : Dto.Bounds) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Bounds) => { return dto.excludedPerson },
      "height": (dto : Dto.Bounds) => { return dto.height },
      "iid": (dto : Dto.Bounds) => { return dto.iid },
      "modifiedOn": (dto : Dto.Bounds) => { return dto.modifiedOn },
      "name": (dto : Dto.Bounds) => { return dto.name },
      "revisionNumber": (dto : Dto.Bounds) => { return dto.revisionNumber },
      "width": (dto : Dto.Bounds) => { return dto.width },
      "x": (dto : Dto.Bounds) => { return dto.x },
      "y": (dto : Dto.Bounds) => { return dto.y },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Bounds>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Bounds>dtoThing;
      const clone = new Dto.Bounds(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.height = dto.height;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.width = dto.width;
      clone.x = dto.x;
      clone.y = dto.y;

      return clone;
    }
  }

  /**
   * The metadata for BuiltInRuleVerification
   */
  class BuiltInRuleVerificationMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "BuiltInRuleVerification";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "RuleVerification";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("RuleVerificationList", "ruleVerification");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "executedOn": new PropertyMetadata("executedOn", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isActive": new PropertyMetadata("isActive", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "status": new PropertyMetadata("status", "RuleVerificationStatusKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "violation": new PropertyMetadata("violation", "RuleViolation", 0, "*", AggregationKind.Composite, false, false, false, false, false, false, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const builtInRuleVerification = <Dto.BuiltInRuleVerification>thing;
      return {
        "violation": builtInRuleVerification.violation,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const builtInRuleVerification = <Dto.BuiltInRuleVerification>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.BuiltInRuleVerification) => any } = {
      "classKind": (dto : Dto.BuiltInRuleVerification) => { return dto.classKind },
      "excludedDomain": (dto : Dto.BuiltInRuleVerification) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.BuiltInRuleVerification) => { return dto.excludedPerson },
      "executedOn": (dto : Dto.BuiltInRuleVerification) => { return dto.executedOn },
      "iid": (dto : Dto.BuiltInRuleVerification) => { return dto.iid },
      "isActive": (dto : Dto.BuiltInRuleVerification) => { return dto.isActive },
      "modifiedOn": (dto : Dto.BuiltInRuleVerification) => { return dto.modifiedOn },
      "name": (dto : Dto.BuiltInRuleVerification) => { return dto.name },
      "owner": (dto : Dto.BuiltInRuleVerification) => { return dto.owner },
      "revisionNumber": (dto : Dto.BuiltInRuleVerification) => { return dto.revisionNumber },
      "status": (dto : Dto.BuiltInRuleVerification) => { return dto.status },
      "violation": (dto : Dto.BuiltInRuleVerification) => { return dto.violation },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.BuiltInRuleVerification>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.BuiltInRuleVerification>dtoThing;
      const clone = new Dto.BuiltInRuleVerification(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.executedOn = dto.executedOn;
      clone.isActive = dto.isActive;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.status = dto.status;
      clone.violation = (dto.violation !== undefined && dto.violation !== null) ? dto.violation.slice(0) : dto.violation;

      return clone;
    }
  }

  /**
   * The metadata for Category
   */
  class CategoryMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Category";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "definedCategory");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isAbstract": new PropertyMetadata("isAbstract", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "permissibleClass": new PropertyMetadata("permissibleClass", "ClassKind", 1, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "superCategory": new PropertyMetadata("superCategory", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const category = <Dto.Category>thing;
      return {
        "alias": category.alias,
        "definition": category.definition,
        "hyperLink": category.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const category = <Dto.Category>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Category) => any } = {
      "alias": (dto : Dto.Category) => { return dto.alias },
      "classKind": (dto : Dto.Category) => { return dto.classKind },
      "definition": (dto : Dto.Category) => { return dto.definition },
      "excludedDomain": (dto : Dto.Category) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Category) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.Category) => { return dto.hyperLink },
      "iid": (dto : Dto.Category) => { return dto.iid },
      "isAbstract": (dto : Dto.Category) => { return dto.isAbstract },
      "isDeprecated": (dto : Dto.Category) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.Category) => { return dto.modifiedOn },
      "name": (dto : Dto.Category) => { return dto.name },
      "permissibleClass": (dto : Dto.Category) => { return dto.permissibleClass },
      "revisionNumber": (dto : Dto.Category) => { return dto.revisionNumber },
      "shortName": (dto : Dto.Category) => { return dto.shortName },
      "superCategory": (dto : Dto.Category) => { return dto.superCategory },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Category>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Category>dtoThing;
      const clone = new Dto.Category(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isAbstract = dto.isAbstract;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.permissibleClass = (dto.permissibleClass !== undefined && dto.permissibleClass !== null) ? dto.permissibleClass.slice(0) : dto.permissibleClass;
      clone.shortName = dto.shortName;
      clone.superCategory = (dto.superCategory !== undefined && dto.superCategory !== null) ? dto.superCategory.slice(0) : dto.superCategory;

      return clone;
    }
  }

  /**
   * The metadata for ChangeProposal
   */
  class ChangeProposalMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ChangeProposal";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ModellingAnnotationItem";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModel", "modellingAnnotation");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "approvedBy": new PropertyMetadata("approvedBy", "Approval", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "author": new PropertyMetadata("author", "Participant", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "changeRequest": new PropertyMetadata("changeRequest", "ChangeRequest", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classification": new PropertyMetadata("classification", "AnnotationClassificationKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "discussion": new PropertyMetadata("discussion", "EngineeringModelDataDiscussionItem", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "primaryAnnotatedThing": new PropertyMetadata("primaryAnnotatedThing", "ModellingThingReference", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "relatedThing": new PropertyMetadata("relatedThing", "ModellingThingReference", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "sourceAnnotation": new PropertyMetadata("sourceAnnotation", "ModellingAnnotationItem", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "status": new PropertyMetadata("status", "AnnotationStatusKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "title": new PropertyMetadata("title", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const changeProposal = <Dto.ChangeProposal>thing;
      return {
        "approvedBy": changeProposal.approvedBy,
        "discussion": changeProposal.discussion,
        "relatedThing": changeProposal.relatedThing,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const changeProposal = <Dto.ChangeProposal>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ChangeProposal) => any } = {
      "approvedBy": (dto : Dto.ChangeProposal) => { return dto.approvedBy },
      "author": (dto : Dto.ChangeProposal) => { return dto.author },
      "category": (dto : Dto.ChangeProposal) => { return dto.category },
      "changeRequest": (dto : Dto.ChangeProposal) => { return dto.changeRequest },
      "classification": (dto : Dto.ChangeProposal) => { return dto.classification },
      "classKind": (dto : Dto.ChangeProposal) => { return dto.classKind },
      "content": (dto : Dto.ChangeProposal) => { return dto.content },
      "createdOn": (dto : Dto.ChangeProposal) => { return dto.createdOn },
      "discussion": (dto : Dto.ChangeProposal) => { return dto.discussion },
      "excludedDomain": (dto : Dto.ChangeProposal) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ChangeProposal) => { return dto.excludedPerson },
      "iid": (dto : Dto.ChangeProposal) => { return dto.iid },
      "languageCode": (dto : Dto.ChangeProposal) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.ChangeProposal) => { return dto.modifiedOn },
      "owner": (dto : Dto.ChangeProposal) => { return dto.owner },
      "primaryAnnotatedThing": (dto : Dto.ChangeProposal) => { return dto.primaryAnnotatedThing },
      "relatedThing": (dto : Dto.ChangeProposal) => { return dto.relatedThing },
      "revisionNumber": (dto : Dto.ChangeProposal) => { return dto.revisionNumber },
      "shortName": (dto : Dto.ChangeProposal) => { return dto.shortName },
      "sourceAnnotation": (dto : Dto.ChangeProposal) => { return dto.sourceAnnotation },
      "status": (dto : Dto.ChangeProposal) => { return dto.status },
      "title": (dto : Dto.ChangeProposal) => { return dto.title },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ChangeProposal>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ChangeProposal>dtoThing;
      const clone = new Dto.ChangeProposal(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.approvedBy = (dto.approvedBy !== undefined && dto.approvedBy !== null) ? dto.approvedBy.slice(0) : dto.approvedBy;
      clone.author = dto.author;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.changeRequest = dto.changeRequest;
      clone.classification = dto.classification;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.createdOn = dto.createdOn;
      clone.discussion = (dto.discussion !== undefined && dto.discussion !== null) ? dto.discussion.slice(0) : dto.discussion;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;
      clone.primaryAnnotatedThing = dto.primaryAnnotatedThing;
      clone.relatedThing = (dto.relatedThing !== undefined && dto.relatedThing !== null) ? dto.relatedThing.slice(0) : dto.relatedThing;
      clone.shortName = dto.shortName;
      clone.sourceAnnotation = (dto.sourceAnnotation !== undefined && dto.sourceAnnotation !== null) ? dto.sourceAnnotation.slice(0) : dto.sourceAnnotation;
      clone.status = dto.status;
      clone.title = dto.title;

      return clone;
    }
  }

  /**
   * The metadata for ChangeRequest
   */
  class ChangeRequestMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ChangeRequest";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ContractDeviation";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModel", "modellingAnnotation");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "approvedBy": new PropertyMetadata("approvedBy", "Approval", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "author": new PropertyMetadata("author", "Participant", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classification": new PropertyMetadata("classification", "AnnotationClassificationKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "discussion": new PropertyMetadata("discussion", "EngineeringModelDataDiscussionItem", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "primaryAnnotatedThing": new PropertyMetadata("primaryAnnotatedThing", "ModellingThingReference", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "relatedThing": new PropertyMetadata("relatedThing", "ModellingThingReference", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "sourceAnnotation": new PropertyMetadata("sourceAnnotation", "ModellingAnnotationItem", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "status": new PropertyMetadata("status", "AnnotationStatusKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "title": new PropertyMetadata("title", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const changeRequest = <Dto.ChangeRequest>thing;
      return {
        "approvedBy": changeRequest.approvedBy,
        "discussion": changeRequest.discussion,
        "relatedThing": changeRequest.relatedThing,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const changeRequest = <Dto.ChangeRequest>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ChangeRequest) => any } = {
      "approvedBy": (dto : Dto.ChangeRequest) => { return dto.approvedBy },
      "author": (dto : Dto.ChangeRequest) => { return dto.author },
      "category": (dto : Dto.ChangeRequest) => { return dto.category },
      "classification": (dto : Dto.ChangeRequest) => { return dto.classification },
      "classKind": (dto : Dto.ChangeRequest) => { return dto.classKind },
      "content": (dto : Dto.ChangeRequest) => { return dto.content },
      "createdOn": (dto : Dto.ChangeRequest) => { return dto.createdOn },
      "discussion": (dto : Dto.ChangeRequest) => { return dto.discussion },
      "excludedDomain": (dto : Dto.ChangeRequest) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ChangeRequest) => { return dto.excludedPerson },
      "iid": (dto : Dto.ChangeRequest) => { return dto.iid },
      "languageCode": (dto : Dto.ChangeRequest) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.ChangeRequest) => { return dto.modifiedOn },
      "owner": (dto : Dto.ChangeRequest) => { return dto.owner },
      "primaryAnnotatedThing": (dto : Dto.ChangeRequest) => { return dto.primaryAnnotatedThing },
      "relatedThing": (dto : Dto.ChangeRequest) => { return dto.relatedThing },
      "revisionNumber": (dto : Dto.ChangeRequest) => { return dto.revisionNumber },
      "shortName": (dto : Dto.ChangeRequest) => { return dto.shortName },
      "sourceAnnotation": (dto : Dto.ChangeRequest) => { return dto.sourceAnnotation },
      "status": (dto : Dto.ChangeRequest) => { return dto.status },
      "title": (dto : Dto.ChangeRequest) => { return dto.title },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ChangeRequest>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ChangeRequest>dtoThing;
      const clone = new Dto.ChangeRequest(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.approvedBy = (dto.approvedBy !== undefined && dto.approvedBy !== null) ? dto.approvedBy.slice(0) : dto.approvedBy;
      clone.author = dto.author;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classification = dto.classification;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.createdOn = dto.createdOn;
      clone.discussion = (dto.discussion !== undefined && dto.discussion !== null) ? dto.discussion.slice(0) : dto.discussion;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;
      clone.primaryAnnotatedThing = dto.primaryAnnotatedThing;
      clone.relatedThing = (dto.relatedThing !== undefined && dto.relatedThing !== null) ? dto.relatedThing.slice(0) : dto.relatedThing;
      clone.shortName = dto.shortName;
      clone.sourceAnnotation = (dto.sourceAnnotation !== undefined && dto.sourceAnnotation !== null) ? dto.sourceAnnotation.slice(0) : dto.sourceAnnotation;
      clone.status = dto.status;
      clone.title = dto.title;

      return clone;
    }
  }

  /**
   * The metadata for Citation
   */
  class CitationMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Citation";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Definition", "citation");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isAdaptation": new PropertyMetadata("isAdaptation", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "location": new PropertyMetadata("location", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "remark": new PropertyMetadata("remark", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "source": new PropertyMetadata("source", "ReferenceSource", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const citation = <Dto.Citation>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const citation = <Dto.Citation>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Citation) => any } = {
      "classKind": (dto : Dto.Citation) => { return dto.classKind },
      "excludedDomain": (dto : Dto.Citation) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Citation) => { return dto.excludedPerson },
      "iid": (dto : Dto.Citation) => { return dto.iid },
      "isAdaptation": (dto : Dto.Citation) => { return dto.isAdaptation },
      "location": (dto : Dto.Citation) => { return dto.location },
      "modifiedOn": (dto : Dto.Citation) => { return dto.modifiedOn },
      "remark": (dto : Dto.Citation) => { return dto.remark },
      "revisionNumber": (dto : Dto.Citation) => { return dto.revisionNumber },
      "shortName": (dto : Dto.Citation) => { return dto.shortName },
      "source": (dto : Dto.Citation) => { return dto.source },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Citation>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Citation>dtoThing;
      const clone = new Dto.Citation(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.isAdaptation = dto.isAdaptation;
      clone.location = dto.location;
      clone.modifiedOn = dto.modifiedOn;
      clone.remark = dto.remark;
      clone.shortName = dto.shortName;
      clone.source = dto.source;

      return clone;
    }
  }

  /**
   * The metadata for Color
   */
  class ColorMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Color";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DiagramThingBase";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("DiagrammingStyle", "usedColor");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "blue": new PropertyMetadata("blue", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "green": new PropertyMetadata("green", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "red": new PropertyMetadata("red", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const color = <Dto.Color>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const color = <Dto.Color>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Color) => any } = {
      "blue": (dto : Dto.Color) => { return dto.blue },
      "classKind": (dto : Dto.Color) => { return dto.classKind },
      "excludedDomain": (dto : Dto.Color) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Color) => { return dto.excludedPerson },
      "green": (dto : Dto.Color) => { return dto.green },
      "iid": (dto : Dto.Color) => { return dto.iid },
      "modifiedOn": (dto : Dto.Color) => { return dto.modifiedOn },
      "name": (dto : Dto.Color) => { return dto.name },
      "red": (dto : Dto.Color) => { return dto.red },
      "revisionNumber": (dto : Dto.Color) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Color>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Color>dtoThing;
      const clone = new Dto.Color(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.blue = dto.blue;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.green = dto.green;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.red = dto.red;

      return clone;
    }
  }

  /**
   * The metadata for CommonFileStore
   */
  class CommonFileStoreMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "CommonFileStore";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "FileStore";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModel", "commonFileStore");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "file": new PropertyMetadata("file", "File", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "folder": new PropertyMetadata("folder", "Folder", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const commonFileStore = <Dto.CommonFileStore>thing;
      return {
        "file": commonFileStore.file,
        "folder": commonFileStore.folder,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const commonFileStore = <Dto.CommonFileStore>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.CommonFileStore) => any } = {
      "classKind": (dto : Dto.CommonFileStore) => { return dto.classKind },
      "createdOn": (dto : Dto.CommonFileStore) => { return dto.createdOn },
      "excludedDomain": (dto : Dto.CommonFileStore) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.CommonFileStore) => { return dto.excludedPerson },
      "file": (dto : Dto.CommonFileStore) => { return dto.file },
      "folder": (dto : Dto.CommonFileStore) => { return dto.folder },
      "iid": (dto : Dto.CommonFileStore) => { return dto.iid },
      "modifiedOn": (dto : Dto.CommonFileStore) => { return dto.modifiedOn },
      "name": (dto : Dto.CommonFileStore) => { return dto.name },
      "owner": (dto : Dto.CommonFileStore) => { return dto.owner },
      "revisionNumber": (dto : Dto.CommonFileStore) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.CommonFileStore>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.CommonFileStore>dtoThing;
      const clone = new Dto.CommonFileStore(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.createdOn = dto.createdOn;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.file = (dto.file !== undefined && dto.file !== null) ? dto.file.slice(0) : dto.file;
      clone.folder = (dto.folder !== undefined && dto.folder !== null) ? dto.folder.slice(0) : dto.folder;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.owner = dto.owner;

      return clone;
    }
  }

  /**
   * The metadata for CompoundParameterType
   */
  class CompoundParameterTypeMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "CompoundParameterType";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ParameterType";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "parameterType");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "component": new PropertyMetadata("component", "ParameterTypeComponent", 1, "*", AggregationKind.Composite, false, true, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isFinalized": new PropertyMetadata("isFinalized", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "numberOfValues": new PropertyMetadata("numberOfValues", "number", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "symbol": new PropertyMetadata("symbol", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const compoundParameterType = <Dto.CompoundParameterType>thing;
      return {
        "alias": compoundParameterType.alias,
        "definition": compoundParameterType.definition,
        "hyperLink": compoundParameterType.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const compoundParameterType = <Dto.CompoundParameterType>thing;
      return {
        "component": compoundParameterType.component,
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.CompoundParameterType) => any } = {
      "alias": (dto : Dto.CompoundParameterType) => { return dto.alias },
      "category": (dto : Dto.CompoundParameterType) => { return dto.category },
      "classKind": (dto : Dto.CompoundParameterType) => { return dto.classKind },
      "component": (dto : Dto.CompoundParameterType) => { return dto.component },
      "definition": (dto : Dto.CompoundParameterType) => { return dto.definition },
      "excludedDomain": (dto : Dto.CompoundParameterType) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.CompoundParameterType) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.CompoundParameterType) => { return dto.hyperLink },
      "iid": (dto : Dto.CompoundParameterType) => { return dto.iid },
      "isDeprecated": (dto : Dto.CompoundParameterType) => { return dto.isDeprecated },
      "isFinalized": (dto : Dto.CompoundParameterType) => { return dto.isFinalized },
      "modifiedOn": (dto : Dto.CompoundParameterType) => { return dto.modifiedOn },
      "name": (dto : Dto.CompoundParameterType) => { return dto.name },
      "numberOfValues": (dto : Dto.CompoundParameterType) => { return dto.numberOfValues },
      "revisionNumber": (dto : Dto.CompoundParameterType) => { return dto.revisionNumber },
      "shortName": (dto : Dto.CompoundParameterType) => { return dto.shortName },
      "symbol": (dto : Dto.CompoundParameterType) => { return dto.symbol },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.CompoundParameterType>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.CompoundParameterType>dtoThing;
      const clone = new Dto.CompoundParameterType(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.component = (dto.component !== undefined && dto.component !== null) ? dto.component.slice(0) : dto.component;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.isFinalized = dto.isFinalized;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;
      clone.symbol = dto.symbol;

      return clone;
    }
  }

  /**
   * The metadata for Constant
   */
  class ConstantMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Constant";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "constant");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "parameterType": new PropertyMetadata("parameterType", "ParameterType", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "scale": new PropertyMetadata("scale", "MeasurementScale", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "value": new PropertyMetadata("value", "string", 1, "*", AggregationKind.None, false, true, true, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const constant = <Dto.Constant>thing;
      return {
        "alias": constant.alias,
        "definition": constant.definition,
        "hyperLink": constant.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const constant = <Dto.Constant>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Constant) => any } = {
      "alias": (dto : Dto.Constant) => { return dto.alias },
      "category": (dto : Dto.Constant) => { return dto.category },
      "classKind": (dto : Dto.Constant) => { return dto.classKind },
      "definition": (dto : Dto.Constant) => { return dto.definition },
      "excludedDomain": (dto : Dto.Constant) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Constant) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.Constant) => { return dto.hyperLink },
      "iid": (dto : Dto.Constant) => { return dto.iid },
      "isDeprecated": (dto : Dto.Constant) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.Constant) => { return dto.modifiedOn },
      "name": (dto : Dto.Constant) => { return dto.name },
      "parameterType": (dto : Dto.Constant) => { return dto.parameterType },
      "revisionNumber": (dto : Dto.Constant) => { return dto.revisionNumber },
      "scale": (dto : Dto.Constant) => { return dto.scale },
      "shortName": (dto : Dto.Constant) => { return dto.shortName },
      "value": (dto : Dto.Constant) => { return dto.value },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Constant>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Constant>dtoThing;
      const clone = new Dto.Constant(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.parameterType = dto.parameterType;
      clone.scale = dto.scale;
      clone.shortName = dto.shortName;
      clone.value = (dto.value !== undefined && dto.value !== null) ? dto.value.slice(0) : dto.value;

      return clone;
    }
  }

  /**
   * The metadata for ContractChangeNotice
   */
  class ContractChangeNoticeMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ContractChangeNotice";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ModellingAnnotationItem";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModel", "modellingAnnotation");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "approvedBy": new PropertyMetadata("approvedBy", "Approval", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "author": new PropertyMetadata("author", "Participant", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "changeProposal": new PropertyMetadata("changeProposal", "ChangeProposal", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classification": new PropertyMetadata("classification", "AnnotationClassificationKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "discussion": new PropertyMetadata("discussion", "EngineeringModelDataDiscussionItem", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "primaryAnnotatedThing": new PropertyMetadata("primaryAnnotatedThing", "ModellingThingReference", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "relatedThing": new PropertyMetadata("relatedThing", "ModellingThingReference", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "sourceAnnotation": new PropertyMetadata("sourceAnnotation", "ModellingAnnotationItem", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "status": new PropertyMetadata("status", "AnnotationStatusKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "title": new PropertyMetadata("title", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const contractChangeNotice = <Dto.ContractChangeNotice>thing;
      return {
        "approvedBy": contractChangeNotice.approvedBy,
        "discussion": contractChangeNotice.discussion,
        "relatedThing": contractChangeNotice.relatedThing,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const contractChangeNotice = <Dto.ContractChangeNotice>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ContractChangeNotice) => any } = {
      "approvedBy": (dto : Dto.ContractChangeNotice) => { return dto.approvedBy },
      "author": (dto : Dto.ContractChangeNotice) => { return dto.author },
      "category": (dto : Dto.ContractChangeNotice) => { return dto.category },
      "changeProposal": (dto : Dto.ContractChangeNotice) => { return dto.changeProposal },
      "classification": (dto : Dto.ContractChangeNotice) => { return dto.classification },
      "classKind": (dto : Dto.ContractChangeNotice) => { return dto.classKind },
      "content": (dto : Dto.ContractChangeNotice) => { return dto.content },
      "createdOn": (dto : Dto.ContractChangeNotice) => { return dto.createdOn },
      "discussion": (dto : Dto.ContractChangeNotice) => { return dto.discussion },
      "excludedDomain": (dto : Dto.ContractChangeNotice) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ContractChangeNotice) => { return dto.excludedPerson },
      "iid": (dto : Dto.ContractChangeNotice) => { return dto.iid },
      "languageCode": (dto : Dto.ContractChangeNotice) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.ContractChangeNotice) => { return dto.modifiedOn },
      "owner": (dto : Dto.ContractChangeNotice) => { return dto.owner },
      "primaryAnnotatedThing": (dto : Dto.ContractChangeNotice) => { return dto.primaryAnnotatedThing },
      "relatedThing": (dto : Dto.ContractChangeNotice) => { return dto.relatedThing },
      "revisionNumber": (dto : Dto.ContractChangeNotice) => { return dto.revisionNumber },
      "shortName": (dto : Dto.ContractChangeNotice) => { return dto.shortName },
      "sourceAnnotation": (dto : Dto.ContractChangeNotice) => { return dto.sourceAnnotation },
      "status": (dto : Dto.ContractChangeNotice) => { return dto.status },
      "title": (dto : Dto.ContractChangeNotice) => { return dto.title },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ContractChangeNotice>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ContractChangeNotice>dtoThing;
      const clone = new Dto.ContractChangeNotice(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.approvedBy = (dto.approvedBy !== undefined && dto.approvedBy !== null) ? dto.approvedBy.slice(0) : dto.approvedBy;
      clone.author = dto.author;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.changeProposal = dto.changeProposal;
      clone.classification = dto.classification;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.createdOn = dto.createdOn;
      clone.discussion = (dto.discussion !== undefined && dto.discussion !== null) ? dto.discussion.slice(0) : dto.discussion;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;
      clone.primaryAnnotatedThing = dto.primaryAnnotatedThing;
      clone.relatedThing = (dto.relatedThing !== undefined && dto.relatedThing !== null) ? dto.relatedThing.slice(0) : dto.relatedThing;
      clone.shortName = dto.shortName;
      clone.sourceAnnotation = (dto.sourceAnnotation !== undefined && dto.sourceAnnotation !== null) ? dto.sourceAnnotation.slice(0) : dto.sourceAnnotation;
      clone.status = dto.status;
      clone.title = dto.title;

      return clone;
    }
  }

  /**
   * The metadata for CyclicRatioScale
   */
  class CyclicRatioScaleMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "CyclicRatioScale";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "RatioScale";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "scale");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isMaximumInclusive": new PropertyMetadata("isMaximumInclusive", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isMinimumInclusive": new PropertyMetadata("isMinimumInclusive", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "mappingToReferenceScale": new PropertyMetadata("mappingToReferenceScale", "MappingToReferenceScale", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "maximumPermissibleValue": new PropertyMetadata("maximumPermissibleValue", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "minimumPermissibleValue": new PropertyMetadata("minimumPermissibleValue", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "modulus": new PropertyMetadata("modulus", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "negativeValueConnotation": new PropertyMetadata("negativeValueConnotation", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "numberSet": new PropertyMetadata("numberSet", "NumberSetKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "positiveValueConnotation": new PropertyMetadata("positiveValueConnotation", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "unit": new PropertyMetadata("unit", "MeasurementUnit", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "valueDefinition": new PropertyMetadata("valueDefinition", "ScaleValueDefinition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const cyclicRatioScale = <Dto.CyclicRatioScale>thing;
      return {
        "alias": cyclicRatioScale.alias,
        "definition": cyclicRatioScale.definition,
        "hyperLink": cyclicRatioScale.hyperLink,
        "mappingToReferenceScale": cyclicRatioScale.mappingToReferenceScale,
        "valueDefinition": cyclicRatioScale.valueDefinition,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const cyclicRatioScale = <Dto.CyclicRatioScale>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.CyclicRatioScale) => any } = {
      "alias": (dto : Dto.CyclicRatioScale) => { return dto.alias },
      "classKind": (dto : Dto.CyclicRatioScale) => { return dto.classKind },
      "definition": (dto : Dto.CyclicRatioScale) => { return dto.definition },
      "excludedDomain": (dto : Dto.CyclicRatioScale) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.CyclicRatioScale) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.CyclicRatioScale) => { return dto.hyperLink },
      "iid": (dto : Dto.CyclicRatioScale) => { return dto.iid },
      "isDeprecated": (dto : Dto.CyclicRatioScale) => { return dto.isDeprecated },
      "isMaximumInclusive": (dto : Dto.CyclicRatioScale) => { return dto.isMaximumInclusive },
      "isMinimumInclusive": (dto : Dto.CyclicRatioScale) => { return dto.isMinimumInclusive },
      "mappingToReferenceScale": (dto : Dto.CyclicRatioScale) => { return dto.mappingToReferenceScale },
      "maximumPermissibleValue": (dto : Dto.CyclicRatioScale) => { return dto.maximumPermissibleValue },
      "minimumPermissibleValue": (dto : Dto.CyclicRatioScale) => { return dto.minimumPermissibleValue },
      "modifiedOn": (dto : Dto.CyclicRatioScale) => { return dto.modifiedOn },
      "modulus": (dto : Dto.CyclicRatioScale) => { return dto.modulus },
      "name": (dto : Dto.CyclicRatioScale) => { return dto.name },
      "negativeValueConnotation": (dto : Dto.CyclicRatioScale) => { return dto.negativeValueConnotation },
      "numberSet": (dto : Dto.CyclicRatioScale) => { return dto.numberSet },
      "positiveValueConnotation": (dto : Dto.CyclicRatioScale) => { return dto.positiveValueConnotation },
      "revisionNumber": (dto : Dto.CyclicRatioScale) => { return dto.revisionNumber },
      "shortName": (dto : Dto.CyclicRatioScale) => { return dto.shortName },
      "unit": (dto : Dto.CyclicRatioScale) => { return dto.unit },
      "valueDefinition": (dto : Dto.CyclicRatioScale) => { return dto.valueDefinition },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.CyclicRatioScale>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.CyclicRatioScale>dtoThing;
      const clone = new Dto.CyclicRatioScale(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.isMaximumInclusive = dto.isMaximumInclusive;
      clone.isMinimumInclusive = dto.isMinimumInclusive;
      clone.mappingToReferenceScale = (dto.mappingToReferenceScale !== undefined && dto.mappingToReferenceScale !== null) ? dto.mappingToReferenceScale.slice(0) : dto.mappingToReferenceScale;
      clone.maximumPermissibleValue = dto.maximumPermissibleValue;
      clone.minimumPermissibleValue = dto.minimumPermissibleValue;
      clone.modifiedOn = dto.modifiedOn;
      clone.modulus = dto.modulus;
      clone.name = dto.name;
      clone.negativeValueConnotation = dto.negativeValueConnotation;
      clone.numberSet = dto.numberSet;
      clone.positiveValueConnotation = dto.positiveValueConnotation;
      clone.shortName = dto.shortName;
      clone.unit = dto.unit;
      clone.valueDefinition = (dto.valueDefinition !== undefined && dto.valueDefinition !== null) ? dto.valueDefinition.slice(0) : dto.valueDefinition;

      return clone;
    }
  }

  /**
   * The metadata for DateParameterType
   */
  class DateParameterTypeMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "DateParameterType";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ScalarParameterType";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "parameterType");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "numberOfValues": new PropertyMetadata("numberOfValues", "number", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "symbol": new PropertyMetadata("symbol", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const dateParameterType = <Dto.DateParameterType>thing;
      return {
        "alias": dateParameterType.alias,
        "definition": dateParameterType.definition,
        "hyperLink": dateParameterType.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const dateParameterType = <Dto.DateParameterType>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.DateParameterType) => any } = {
      "alias": (dto : Dto.DateParameterType) => { return dto.alias },
      "category": (dto : Dto.DateParameterType) => { return dto.category },
      "classKind": (dto : Dto.DateParameterType) => { return dto.classKind },
      "definition": (dto : Dto.DateParameterType) => { return dto.definition },
      "excludedDomain": (dto : Dto.DateParameterType) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.DateParameterType) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.DateParameterType) => { return dto.hyperLink },
      "iid": (dto : Dto.DateParameterType) => { return dto.iid },
      "isDeprecated": (dto : Dto.DateParameterType) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.DateParameterType) => { return dto.modifiedOn },
      "name": (dto : Dto.DateParameterType) => { return dto.name },
      "numberOfValues": (dto : Dto.DateParameterType) => { return dto.numberOfValues },
      "revisionNumber": (dto : Dto.DateParameterType) => { return dto.revisionNumber },
      "shortName": (dto : Dto.DateParameterType) => { return dto.shortName },
      "symbol": (dto : Dto.DateParameterType) => { return dto.symbol },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.DateParameterType>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.DateParameterType>dtoThing;
      const clone = new Dto.DateParameterType(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;
      clone.symbol = dto.symbol;

      return clone;
    }
  }

  /**
   * The metadata for DateTimeParameterType
   */
  class DateTimeParameterTypeMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "DateTimeParameterType";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ScalarParameterType";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "parameterType");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "numberOfValues": new PropertyMetadata("numberOfValues", "number", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "symbol": new PropertyMetadata("symbol", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const dateTimeParameterType = <Dto.DateTimeParameterType>thing;
      return {
        "alias": dateTimeParameterType.alias,
        "definition": dateTimeParameterType.definition,
        "hyperLink": dateTimeParameterType.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const dateTimeParameterType = <Dto.DateTimeParameterType>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.DateTimeParameterType) => any } = {
      "alias": (dto : Dto.DateTimeParameterType) => { return dto.alias },
      "category": (dto : Dto.DateTimeParameterType) => { return dto.category },
      "classKind": (dto : Dto.DateTimeParameterType) => { return dto.classKind },
      "definition": (dto : Dto.DateTimeParameterType) => { return dto.definition },
      "excludedDomain": (dto : Dto.DateTimeParameterType) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.DateTimeParameterType) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.DateTimeParameterType) => { return dto.hyperLink },
      "iid": (dto : Dto.DateTimeParameterType) => { return dto.iid },
      "isDeprecated": (dto : Dto.DateTimeParameterType) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.DateTimeParameterType) => { return dto.modifiedOn },
      "name": (dto : Dto.DateTimeParameterType) => { return dto.name },
      "numberOfValues": (dto : Dto.DateTimeParameterType) => { return dto.numberOfValues },
      "revisionNumber": (dto : Dto.DateTimeParameterType) => { return dto.revisionNumber },
      "shortName": (dto : Dto.DateTimeParameterType) => { return dto.shortName },
      "symbol": (dto : Dto.DateTimeParameterType) => { return dto.symbol },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.DateTimeParameterType>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.DateTimeParameterType>dtoThing;
      const clone = new Dto.DateTimeParameterType(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;
      clone.symbol = dto.symbol;

      return clone;
    }
  }

  /**
   * The metadata for DecompositionRule
   */
  class DecompositionRuleMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "DecompositionRule";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Rule";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "rule");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "containedCategory": new PropertyMetadata("containedCategory", "Category", 1, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "containingCategory": new PropertyMetadata("containingCategory", "Category", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "maxContained": new PropertyMetadata("maxContained", "number", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "minContained": new PropertyMetadata("minContained", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const decompositionRule = <Dto.DecompositionRule>thing;
      return {
        "alias": decompositionRule.alias,
        "definition": decompositionRule.definition,
        "hyperLink": decompositionRule.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const decompositionRule = <Dto.DecompositionRule>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.DecompositionRule) => any } = {
      "alias": (dto : Dto.DecompositionRule) => { return dto.alias },
      "classKind": (dto : Dto.DecompositionRule) => { return dto.classKind },
      "containedCategory": (dto : Dto.DecompositionRule) => { return dto.containedCategory },
      "containingCategory": (dto : Dto.DecompositionRule) => { return dto.containingCategory },
      "definition": (dto : Dto.DecompositionRule) => { return dto.definition },
      "excludedDomain": (dto : Dto.DecompositionRule) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.DecompositionRule) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.DecompositionRule) => { return dto.hyperLink },
      "iid": (dto : Dto.DecompositionRule) => { return dto.iid },
      "isDeprecated": (dto : Dto.DecompositionRule) => { return dto.isDeprecated },
      "maxContained": (dto : Dto.DecompositionRule) => { return dto.maxContained },
      "minContained": (dto : Dto.DecompositionRule) => { return dto.minContained },
      "modifiedOn": (dto : Dto.DecompositionRule) => { return dto.modifiedOn },
      "name": (dto : Dto.DecompositionRule) => { return dto.name },
      "revisionNumber": (dto : Dto.DecompositionRule) => { return dto.revisionNumber },
      "shortName": (dto : Dto.DecompositionRule) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.DecompositionRule>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.DecompositionRule>dtoThing;
      const clone = new Dto.DecompositionRule(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.containedCategory = (dto.containedCategory !== undefined && dto.containedCategory !== null) ? dto.containedCategory.slice(0) : dto.containedCategory;
      clone.containingCategory = dto.containingCategory;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.maxContained = dto.maxContained;
      clone.minContained = dto.minContained;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for Definition
   */
  class DefinitionMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Definition";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("DefinedThing", "definition");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "citation": new PropertyMetadata("citation", "Citation", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "example": new PropertyMetadata("example", "string", 0, "*", AggregationKind.None, false, true, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "note": new PropertyMetadata("note", "string", 0, "*", AggregationKind.None, false, true, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const definition = <Dto.Definition>thing;
      return {
        "citation": definition.citation,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const definition = <Dto.Definition>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Definition) => any } = {
      "citation": (dto : Dto.Definition) => { return dto.citation },
      "classKind": (dto : Dto.Definition) => { return dto.classKind },
      "content": (dto : Dto.Definition) => { return dto.content },
      "example": (dto : Dto.Definition) => { return dto.example },
      "excludedDomain": (dto : Dto.Definition) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Definition) => { return dto.excludedPerson },
      "iid": (dto : Dto.Definition) => { return dto.iid },
      "languageCode": (dto : Dto.Definition) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.Definition) => { return dto.modifiedOn },
      "note": (dto : Dto.Definition) => { return dto.note },
      "revisionNumber": (dto : Dto.Definition) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Definition>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Definition>dtoThing;
      const clone = new Dto.Definition(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.citation = (dto.citation !== undefined && dto.citation !== null) ? dto.citation.slice(0) : dto.citation;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.example = (dto.example !== undefined && dto.example !== null) ? dto.example.slice(0) : dto.example;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.note = (dto.note !== undefined && dto.note !== null) ? dto.note.slice(0) : dto.note;

      return clone;
    }
  }

  /**
   * The metadata for DerivedQuantityKind
   */
  class DerivedQuantityKindMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "DerivedQuantityKind";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "QuantityKind";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "parameterType");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "allPossibleScale": new PropertyMetadata("allPossibleScale", "MeasurementScale", 0, "*", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "defaultScale": new PropertyMetadata("defaultScale", "MeasurementScale", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "numberOfValues": new PropertyMetadata("numberOfValues", "number", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "possibleScale": new PropertyMetadata("possibleScale", "MeasurementScale", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "quantityDimensionExponent": new PropertyMetadata("quantityDimensionExponent", "string", 0, "*", AggregationKind.None, false, true, false, true, false, false, "1.0.0"),
      "quantityDimensionExpression": new PropertyMetadata("quantityDimensionExpression", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "quantityDimensionSymbol": new PropertyMetadata("quantityDimensionSymbol", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "quantityKindFactor": new PropertyMetadata("quantityKindFactor", "QuantityKindFactor", 1, "*", AggregationKind.Composite, false, true, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "symbol": new PropertyMetadata("symbol", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const derivedQuantityKind = <Dto.DerivedQuantityKind>thing;
      return {
        "alias": derivedQuantityKind.alias,
        "definition": derivedQuantityKind.definition,
        "hyperLink": derivedQuantityKind.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const derivedQuantityKind = <Dto.DerivedQuantityKind>thing;
      return {
        "quantityKindFactor": derivedQuantityKind.quantityKindFactor,
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.DerivedQuantityKind) => any } = {
      "alias": (dto : Dto.DerivedQuantityKind) => { return dto.alias },
      "allPossibleScale": (dto : Dto.DerivedQuantityKind) => { return dto.allPossibleScale },
      "category": (dto : Dto.DerivedQuantityKind) => { return dto.category },
      "classKind": (dto : Dto.DerivedQuantityKind) => { return dto.classKind },
      "defaultScale": (dto : Dto.DerivedQuantityKind) => { return dto.defaultScale },
      "definition": (dto : Dto.DerivedQuantityKind) => { return dto.definition },
      "excludedDomain": (dto : Dto.DerivedQuantityKind) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.DerivedQuantityKind) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.DerivedQuantityKind) => { return dto.hyperLink },
      "iid": (dto : Dto.DerivedQuantityKind) => { return dto.iid },
      "isDeprecated": (dto : Dto.DerivedQuantityKind) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.DerivedQuantityKind) => { return dto.modifiedOn },
      "name": (dto : Dto.DerivedQuantityKind) => { return dto.name },
      "numberOfValues": (dto : Dto.DerivedQuantityKind) => { return dto.numberOfValues },
      "possibleScale": (dto : Dto.DerivedQuantityKind) => { return dto.possibleScale },
      "quantityDimensionExponent": (dto : Dto.DerivedQuantityKind) => { return dto.quantityDimensionExponent },
      "quantityDimensionExpression": (dto : Dto.DerivedQuantityKind) => { return dto.quantityDimensionExpression },
      "quantityDimensionSymbol": (dto : Dto.DerivedQuantityKind) => { return dto.quantityDimensionSymbol },
      "quantityKindFactor": (dto : Dto.DerivedQuantityKind) => { return dto.quantityKindFactor },
      "revisionNumber": (dto : Dto.DerivedQuantityKind) => { return dto.revisionNumber },
      "shortName": (dto : Dto.DerivedQuantityKind) => { return dto.shortName },
      "symbol": (dto : Dto.DerivedQuantityKind) => { return dto.symbol },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.DerivedQuantityKind>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.DerivedQuantityKind>dtoThing;
      const clone = new Dto.DerivedQuantityKind(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.defaultScale = dto.defaultScale;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.possibleScale = (dto.possibleScale !== undefined && dto.possibleScale !== null) ? dto.possibleScale.slice(0) : dto.possibleScale;
      clone.quantityDimensionSymbol = dto.quantityDimensionSymbol;
      clone.quantityKindFactor = (dto.quantityKindFactor !== undefined && dto.quantityKindFactor !== null) ? dto.quantityKindFactor.slice(0) : dto.quantityKindFactor;
      clone.shortName = dto.shortName;
      clone.symbol = dto.symbol;

      return clone;
    }
  }

  /**
   * The metadata for DerivedUnit
   */
  class DerivedUnitMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "DerivedUnit";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "MeasurementUnit";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "unit");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "unitFactor": new PropertyMetadata("unitFactor", "UnitFactor", 1, "*", AggregationKind.Composite, false, true, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const derivedUnit = <Dto.DerivedUnit>thing;
      return {
        "alias": derivedUnit.alias,
        "definition": derivedUnit.definition,
        "hyperLink": derivedUnit.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const derivedUnit = <Dto.DerivedUnit>thing;
      return {
        "unitFactor": derivedUnit.unitFactor,
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.DerivedUnit) => any } = {
      "alias": (dto : Dto.DerivedUnit) => { return dto.alias },
      "classKind": (dto : Dto.DerivedUnit) => { return dto.classKind },
      "definition": (dto : Dto.DerivedUnit) => { return dto.definition },
      "excludedDomain": (dto : Dto.DerivedUnit) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.DerivedUnit) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.DerivedUnit) => { return dto.hyperLink },
      "iid": (dto : Dto.DerivedUnit) => { return dto.iid },
      "isDeprecated": (dto : Dto.DerivedUnit) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.DerivedUnit) => { return dto.modifiedOn },
      "name": (dto : Dto.DerivedUnit) => { return dto.name },
      "revisionNumber": (dto : Dto.DerivedUnit) => { return dto.revisionNumber },
      "shortName": (dto : Dto.DerivedUnit) => { return dto.shortName },
      "unitFactor": (dto : Dto.DerivedUnit) => { return dto.unitFactor },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.DerivedUnit>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.DerivedUnit>dtoThing;
      const clone = new Dto.DerivedUnit(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;
      clone.unitFactor = (dto.unitFactor !== undefined && dto.unitFactor !== null) ? dto.unitFactor.slice(0) : dto.unitFactor;

      return clone;
    }
  }

  /**
   * The metadata for DiagramCanvas
   */
  class DiagramCanvasMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "DiagramCanvas";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DiagramElementContainer";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "diagramCanvas");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "bounds": new PropertyMetadata("bounds", "Bounds", 0, "1", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "diagramElement": new PropertyMetadata("diagramElement", "DiagramElementThing", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const diagramCanvas = <Dto.DiagramCanvas>thing;
      return {
        "bounds": diagramCanvas.bounds,
        "diagramElement": diagramCanvas.diagramElement,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const diagramCanvas = <Dto.DiagramCanvas>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.DiagramCanvas) => any } = {
      "bounds": (dto : Dto.DiagramCanvas) => { return dto.bounds },
      "classKind": (dto : Dto.DiagramCanvas) => { return dto.classKind },
      "createdOn": (dto : Dto.DiagramCanvas) => { return dto.createdOn },
      "diagramElement": (dto : Dto.DiagramCanvas) => { return dto.diagramElement },
      "excludedDomain": (dto : Dto.DiagramCanvas) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.DiagramCanvas) => { return dto.excludedPerson },
      "iid": (dto : Dto.DiagramCanvas) => { return dto.iid },
      "modifiedOn": (dto : Dto.DiagramCanvas) => { return dto.modifiedOn },
      "name": (dto : Dto.DiagramCanvas) => { return dto.name },
      "revisionNumber": (dto : Dto.DiagramCanvas) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.DiagramCanvas>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.DiagramCanvas>dtoThing;
      const clone = new Dto.DiagramCanvas(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.bounds = dto.bounds;
      clone.classKind = dto.classKind;
      clone.createdOn = dto.createdOn;
      clone.diagramElement = (dto.diagramElement !== undefined && dto.diagramElement !== null) ? dto.diagramElement.slice(0) : dto.diagramElement;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;

      return clone;
    }
  }

  /**
   * The metadata for DiagramEdge
   */
  class DiagramEdgeMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "DiagramEdge";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DiagramElementThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("DiagramElementContainer", "diagramElement");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "bounds": new PropertyMetadata("bounds", "Bounds", 0, "1", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "depictedThing": new PropertyMetadata("depictedThing", "Thing", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "diagramElement": new PropertyMetadata("diagramElement", "DiagramElementThing", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "localStyle": new PropertyMetadata("localStyle", "OwnedStyle", 0, "1", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "point": new PropertyMetadata("point", "Point", 0, "*", AggregationKind.Composite, false, true, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "sharedStyle": new PropertyMetadata("sharedStyle", "SharedStyle", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "source": new PropertyMetadata("source", "DiagramElementThing", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "target": new PropertyMetadata("target", "DiagramElementThing", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const diagramEdge = <Dto.DiagramEdge>thing;
      return {
        "bounds": diagramEdge.bounds,
        "diagramElement": diagramEdge.diagramElement,
        "localStyle": diagramEdge.localStyle,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const diagramEdge = <Dto.DiagramEdge>thing;
      return {
        "point": diagramEdge.point,
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.DiagramEdge) => any } = {
      "bounds": (dto : Dto.DiagramEdge) => { return dto.bounds },
      "classKind": (dto : Dto.DiagramEdge) => { return dto.classKind },
      "depictedThing": (dto : Dto.DiagramEdge) => { return dto.depictedThing },
      "diagramElement": (dto : Dto.DiagramEdge) => { return dto.diagramElement },
      "excludedDomain": (dto : Dto.DiagramEdge) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.DiagramEdge) => { return dto.excludedPerson },
      "iid": (dto : Dto.DiagramEdge) => { return dto.iid },
      "localStyle": (dto : Dto.DiagramEdge) => { return dto.localStyle },
      "modifiedOn": (dto : Dto.DiagramEdge) => { return dto.modifiedOn },
      "name": (dto : Dto.DiagramEdge) => { return dto.name },
      "point": (dto : Dto.DiagramEdge) => { return dto.point },
      "revisionNumber": (dto : Dto.DiagramEdge) => { return dto.revisionNumber },
      "sharedStyle": (dto : Dto.DiagramEdge) => { return dto.sharedStyle },
      "source": (dto : Dto.DiagramEdge) => { return dto.source },
      "target": (dto : Dto.DiagramEdge) => { return dto.target },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.DiagramEdge>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.DiagramEdge>dtoThing;
      const clone = new Dto.DiagramEdge(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.bounds = dto.bounds;
      clone.classKind = dto.classKind;
      clone.depictedThing = dto.depictedThing;
      clone.diagramElement = (dto.diagramElement !== undefined && dto.diagramElement !== null) ? dto.diagramElement.slice(0) : dto.diagramElement;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.localStyle = dto.localStyle;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.point = (dto.point !== undefined && dto.point !== null) ? dto.point.slice(0) : dto.point;
      clone.sharedStyle = dto.sharedStyle;
      clone.source = dto.source;
      clone.target = dto.target;

      return clone;
    }
  }

  /**
   * The metadata for DiagramObject
   */
  class DiagramObjectMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "DiagramObject";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DiagramShape";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("DiagramElementContainer", "diagramElement");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "bounds": new PropertyMetadata("bounds", "Bounds", 0, "1", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "depictedThing": new PropertyMetadata("depictedThing", "Thing", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "diagramElement": new PropertyMetadata("diagramElement", "DiagramElementThing", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "documentation": new PropertyMetadata("documentation", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "localStyle": new PropertyMetadata("localStyle", "OwnedStyle", 0, "1", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "resolution": new PropertyMetadata("resolution", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "sharedStyle": new PropertyMetadata("sharedStyle", "SharedStyle", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const diagramObject = <Dto.DiagramObject>thing;
      return {
        "bounds": diagramObject.bounds,
        "diagramElement": diagramObject.diagramElement,
        "localStyle": diagramObject.localStyle,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const diagramObject = <Dto.DiagramObject>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.DiagramObject) => any } = {
      "bounds": (dto : Dto.DiagramObject) => { return dto.bounds },
      "classKind": (dto : Dto.DiagramObject) => { return dto.classKind },
      "depictedThing": (dto : Dto.DiagramObject) => { return dto.depictedThing },
      "diagramElement": (dto : Dto.DiagramObject) => { return dto.diagramElement },
      "documentation": (dto : Dto.DiagramObject) => { return dto.documentation },
      "excludedDomain": (dto : Dto.DiagramObject) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.DiagramObject) => { return dto.excludedPerson },
      "iid": (dto : Dto.DiagramObject) => { return dto.iid },
      "localStyle": (dto : Dto.DiagramObject) => { return dto.localStyle },
      "modifiedOn": (dto : Dto.DiagramObject) => { return dto.modifiedOn },
      "name": (dto : Dto.DiagramObject) => { return dto.name },
      "resolution": (dto : Dto.DiagramObject) => { return dto.resolution },
      "revisionNumber": (dto : Dto.DiagramObject) => { return dto.revisionNumber },
      "sharedStyle": (dto : Dto.DiagramObject) => { return dto.sharedStyle },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.DiagramObject>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.DiagramObject>dtoThing;
      const clone = new Dto.DiagramObject(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.bounds = dto.bounds;
      clone.classKind = dto.classKind;
      clone.depictedThing = dto.depictedThing;
      clone.diagramElement = (dto.diagramElement !== undefined && dto.diagramElement !== null) ? dto.diagramElement.slice(0) : dto.diagramElement;
      clone.documentation = dto.documentation;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.localStyle = dto.localStyle;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.resolution = dto.resolution;
      clone.sharedStyle = dto.sharedStyle;

      return clone;
    }
  }

  /**
   * The metadata for DomainFileStore
   */
  class DomainFileStoreMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "DomainFileStore";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "FileStore";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "domainFileStore");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "file": new PropertyMetadata("file", "File", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "folder": new PropertyMetadata("folder", "Folder", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isHidden": new PropertyMetadata("isHidden", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const domainFileStore = <Dto.DomainFileStore>thing;
      return {
        "file": domainFileStore.file,
        "folder": domainFileStore.folder,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const domainFileStore = <Dto.DomainFileStore>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.DomainFileStore) => any } = {
      "classKind": (dto : Dto.DomainFileStore) => { return dto.classKind },
      "createdOn": (dto : Dto.DomainFileStore) => { return dto.createdOn },
      "excludedDomain": (dto : Dto.DomainFileStore) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.DomainFileStore) => { return dto.excludedPerson },
      "file": (dto : Dto.DomainFileStore) => { return dto.file },
      "folder": (dto : Dto.DomainFileStore) => { return dto.folder },
      "iid": (dto : Dto.DomainFileStore) => { return dto.iid },
      "isHidden": (dto : Dto.DomainFileStore) => { return dto.isHidden },
      "modifiedOn": (dto : Dto.DomainFileStore) => { return dto.modifiedOn },
      "name": (dto : Dto.DomainFileStore) => { return dto.name },
      "owner": (dto : Dto.DomainFileStore) => { return dto.owner },
      "revisionNumber": (dto : Dto.DomainFileStore) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.DomainFileStore>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.DomainFileStore>dtoThing;
      const clone = new Dto.DomainFileStore(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.createdOn = dto.createdOn;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.file = (dto.file !== undefined && dto.file !== null) ? dto.file.slice(0) : dto.file;
      clone.folder = (dto.folder !== undefined && dto.folder !== null) ? dto.folder.slice(0) : dto.folder;
      clone.isHidden = dto.isHidden;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.owner = dto.owner;

      return clone;
    }
  }

  /**
   * The metadata for DomainOfExpertise
   */
  class DomainOfExpertiseMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "DomainOfExpertise";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("SiteDirectory", "domain");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const domainOfExpertise = <Dto.DomainOfExpertise>thing;
      return {
        "alias": domainOfExpertise.alias,
        "definition": domainOfExpertise.definition,
        "hyperLink": domainOfExpertise.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const domainOfExpertise = <Dto.DomainOfExpertise>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.DomainOfExpertise) => any } = {
      "alias": (dto : Dto.DomainOfExpertise) => { return dto.alias },
      "category": (dto : Dto.DomainOfExpertise) => { return dto.category },
      "classKind": (dto : Dto.DomainOfExpertise) => { return dto.classKind },
      "definition": (dto : Dto.DomainOfExpertise) => { return dto.definition },
      "excludedDomain": (dto : Dto.DomainOfExpertise) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.DomainOfExpertise) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.DomainOfExpertise) => { return dto.hyperLink },
      "iid": (dto : Dto.DomainOfExpertise) => { return dto.iid },
      "isDeprecated": (dto : Dto.DomainOfExpertise) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.DomainOfExpertise) => { return dto.modifiedOn },
      "name": (dto : Dto.DomainOfExpertise) => { return dto.name },
      "revisionNumber": (dto : Dto.DomainOfExpertise) => { return dto.revisionNumber },
      "shortName": (dto : Dto.DomainOfExpertise) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.DomainOfExpertise>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.DomainOfExpertise>dtoThing;
      const clone = new Dto.DomainOfExpertise(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for DomainOfExpertiseGroup
   */
  class DomainOfExpertiseGroupMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "DomainOfExpertiseGroup";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("SiteDirectory", "domainGroup");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "domain": new PropertyMetadata("domain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const domainOfExpertiseGroup = <Dto.DomainOfExpertiseGroup>thing;
      return {
        "alias": domainOfExpertiseGroup.alias,
        "definition": domainOfExpertiseGroup.definition,
        "hyperLink": domainOfExpertiseGroup.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const domainOfExpertiseGroup = <Dto.DomainOfExpertiseGroup>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.DomainOfExpertiseGroup) => any } = {
      "alias": (dto : Dto.DomainOfExpertiseGroup) => { return dto.alias },
      "classKind": (dto : Dto.DomainOfExpertiseGroup) => { return dto.classKind },
      "definition": (dto : Dto.DomainOfExpertiseGroup) => { return dto.definition },
      "domain": (dto : Dto.DomainOfExpertiseGroup) => { return dto.domain },
      "excludedDomain": (dto : Dto.DomainOfExpertiseGroup) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.DomainOfExpertiseGroup) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.DomainOfExpertiseGroup) => { return dto.hyperLink },
      "iid": (dto : Dto.DomainOfExpertiseGroup) => { return dto.iid },
      "isDeprecated": (dto : Dto.DomainOfExpertiseGroup) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.DomainOfExpertiseGroup) => { return dto.modifiedOn },
      "name": (dto : Dto.DomainOfExpertiseGroup) => { return dto.name },
      "revisionNumber": (dto : Dto.DomainOfExpertiseGroup) => { return dto.revisionNumber },
      "shortName": (dto : Dto.DomainOfExpertiseGroup) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.DomainOfExpertiseGroup>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.DomainOfExpertiseGroup>dtoThing;
      const clone = new Dto.DomainOfExpertiseGroup(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.domain = (dto.domain !== undefined && dto.domain !== null) ? dto.domain.slice(0) : dto.domain;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for ElementDefinition
   */
  class ElementDefinitionMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ElementDefinition";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ElementBase";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "element");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "containedElement": new PropertyMetadata("containedElement", "ElementUsage", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "parameter": new PropertyMetadata("parameter", "Parameter", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "parameterGroup": new PropertyMetadata("parameterGroup", "ParameterGroup", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "referencedElement": new PropertyMetadata("referencedElement", "NestedElement", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const elementDefinition = <Dto.ElementDefinition>thing;
      return {
        "alias": elementDefinition.alias,
        "containedElement": elementDefinition.containedElement,
        "definition": elementDefinition.definition,
        "hyperLink": elementDefinition.hyperLink,
        "parameter": elementDefinition.parameter,
        "parameterGroup": elementDefinition.parameterGroup,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const elementDefinition = <Dto.ElementDefinition>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ElementDefinition) => any } = {
      "alias": (dto : Dto.ElementDefinition) => { return dto.alias },
      "category": (dto : Dto.ElementDefinition) => { return dto.category },
      "classKind": (dto : Dto.ElementDefinition) => { return dto.classKind },
      "containedElement": (dto : Dto.ElementDefinition) => { return dto.containedElement },
      "definition": (dto : Dto.ElementDefinition) => { return dto.definition },
      "excludedDomain": (dto : Dto.ElementDefinition) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ElementDefinition) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.ElementDefinition) => { return dto.hyperLink },
      "iid": (dto : Dto.ElementDefinition) => { return dto.iid },
      "modifiedOn": (dto : Dto.ElementDefinition) => { return dto.modifiedOn },
      "name": (dto : Dto.ElementDefinition) => { return dto.name },
      "owner": (dto : Dto.ElementDefinition) => { return dto.owner },
      "parameter": (dto : Dto.ElementDefinition) => { return dto.parameter },
      "parameterGroup": (dto : Dto.ElementDefinition) => { return dto.parameterGroup },
      "referencedElement": (dto : Dto.ElementDefinition) => { return dto.referencedElement },
      "revisionNumber": (dto : Dto.ElementDefinition) => { return dto.revisionNumber },
      "shortName": (dto : Dto.ElementDefinition) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ElementDefinition>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ElementDefinition>dtoThing;
      const clone = new Dto.ElementDefinition(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.containedElement = (dto.containedElement !== undefined && dto.containedElement !== null) ? dto.containedElement.slice(0) : dto.containedElement;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.owner = dto.owner;
      clone.parameter = (dto.parameter !== undefined && dto.parameter !== null) ? dto.parameter.slice(0) : dto.parameter;
      clone.parameterGroup = (dto.parameterGroup !== undefined && dto.parameterGroup !== null) ? dto.parameterGroup.slice(0) : dto.parameterGroup;
      clone.referencedElement = (dto.referencedElement !== undefined && dto.referencedElement !== null) ? dto.referencedElement.slice(0) : dto.referencedElement;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for ElementUsage
   */
  class ElementUsageMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ElementUsage";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ElementBase";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ElementDefinition", "containedElement");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "elementDefinition": new PropertyMetadata("elementDefinition", "ElementDefinition", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludeOption": new PropertyMetadata("excludeOption", "Option", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "interfaceEnd": new PropertyMetadata("interfaceEnd", "InterfaceEndKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "parameterOverride": new PropertyMetadata("parameterOverride", "ParameterOverride", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const elementUsage = <Dto.ElementUsage>thing;
      return {
        "alias": elementUsage.alias,
        "definition": elementUsage.definition,
        "hyperLink": elementUsage.hyperLink,
        "parameterOverride": elementUsage.parameterOverride,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const elementUsage = <Dto.ElementUsage>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ElementUsage) => any } = {
      "alias": (dto : Dto.ElementUsage) => { return dto.alias },
      "category": (dto : Dto.ElementUsage) => { return dto.category },
      "classKind": (dto : Dto.ElementUsage) => { return dto.classKind },
      "definition": (dto : Dto.ElementUsage) => { return dto.definition },
      "elementDefinition": (dto : Dto.ElementUsage) => { return dto.elementDefinition },
      "excludedDomain": (dto : Dto.ElementUsage) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ElementUsage) => { return dto.excludedPerson },
      "excludeOption": (dto : Dto.ElementUsage) => { return dto.excludeOption },
      "hyperLink": (dto : Dto.ElementUsage) => { return dto.hyperLink },
      "iid": (dto : Dto.ElementUsage) => { return dto.iid },
      "interfaceEnd": (dto : Dto.ElementUsage) => { return dto.interfaceEnd },
      "modifiedOn": (dto : Dto.ElementUsage) => { return dto.modifiedOn },
      "name": (dto : Dto.ElementUsage) => { return dto.name },
      "owner": (dto : Dto.ElementUsage) => { return dto.owner },
      "parameterOverride": (dto : Dto.ElementUsage) => { return dto.parameterOverride },
      "revisionNumber": (dto : Dto.ElementUsage) => { return dto.revisionNumber },
      "shortName": (dto : Dto.ElementUsage) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ElementUsage>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ElementUsage>dtoThing;
      const clone = new Dto.ElementUsage(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.elementDefinition = dto.elementDefinition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.excludeOption = (dto.excludeOption !== undefined && dto.excludeOption !== null) ? dto.excludeOption.slice(0) : dto.excludeOption;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.interfaceEnd = dto.interfaceEnd;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.owner = dto.owner;
      clone.parameterOverride = (dto.parameterOverride !== undefined && dto.parameterOverride !== null) ? dto.parameterOverride.slice(0) : dto.parameterOverride;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for EmailAddress
   */
  class EmailAddressMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "EmailAddress";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Person", "emailAddress");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "value": new PropertyMetadata("value", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "vcardType": new PropertyMetadata("vcardType", "VcardEmailAddressKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const emailAddress = <Dto.EmailAddress>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const emailAddress = <Dto.EmailAddress>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.EmailAddress) => any } = {
      "classKind": (dto : Dto.EmailAddress) => { return dto.classKind },
      "excludedDomain": (dto : Dto.EmailAddress) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.EmailAddress) => { return dto.excludedPerson },
      "iid": (dto : Dto.EmailAddress) => { return dto.iid },
      "modifiedOn": (dto : Dto.EmailAddress) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.EmailAddress) => { return dto.revisionNumber },
      "value": (dto : Dto.EmailAddress) => { return dto.value },
      "vcardType": (dto : Dto.EmailAddress) => { return dto.vcardType },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.EmailAddress>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.EmailAddress>dtoThing;
      const clone = new Dto.EmailAddress(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.value = dto.value;
      clone.vcardType = dto.vcardType;

      return clone;
    }
  }

  /**
   * The metadata for EngineeringModel
   */
  class EngineeringModelMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "EngineeringModel";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "TopContainer";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("", "");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "book": new PropertyMetadata("book", "Book", 0, "*", AggregationKind.Composite, false, true, false, false, false, true, "1.1.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "commonFileStore": new PropertyMetadata("commonFileStore", "CommonFileStore", 0, "1", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "engineeringModelSetup": new PropertyMetadata("engineeringModelSetup", "EngineeringModelSetup", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "genericNote": new PropertyMetadata("genericNote", "EngineeringModelDataNote", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iteration": new PropertyMetadata("iteration", "Iteration", 1, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "lastModifiedOn": new PropertyMetadata("lastModifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "logEntry": new PropertyMetadata("logEntry", "ModelLogEntry", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "modellingAnnotation": new PropertyMetadata("modellingAnnotation", "ModellingAnnotationItem", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.1.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const engineeringModel = <Dto.EngineeringModel>thing;
      return {
        "commonFileStore": engineeringModel.commonFileStore,
        "genericNote": engineeringModel.genericNote,
        "iteration": engineeringModel.iteration,
        "logEntry": engineeringModel.logEntry,
        "modellingAnnotation": engineeringModel.modellingAnnotation,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const engineeringModel = <Dto.EngineeringModel>thing;
      return {
        "book": engineeringModel.book,
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.EngineeringModel) => any } = {
      "book": (dto : Dto.EngineeringModel) => { return dto.book },
      "classKind": (dto : Dto.EngineeringModel) => { return dto.classKind },
      "commonFileStore": (dto : Dto.EngineeringModel) => { return dto.commonFileStore },
      "engineeringModelSetup": (dto : Dto.EngineeringModel) => { return dto.engineeringModelSetup },
      "excludedDomain": (dto : Dto.EngineeringModel) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.EngineeringModel) => { return dto.excludedPerson },
      "genericNote": (dto : Dto.EngineeringModel) => { return dto.genericNote },
      "iid": (dto : Dto.EngineeringModel) => { return dto.iid },
      "iteration": (dto : Dto.EngineeringModel) => { return dto.iteration },
      "lastModifiedOn": (dto : Dto.EngineeringModel) => { return dto.lastModifiedOn },
      "logEntry": (dto : Dto.EngineeringModel) => { return dto.logEntry },
      "modellingAnnotation": (dto : Dto.EngineeringModel) => { return dto.modellingAnnotation },
      "modifiedOn": (dto : Dto.EngineeringModel) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.EngineeringModel) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.EngineeringModel>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.EngineeringModel>dtoThing;
      const clone = new Dto.EngineeringModel(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.book = (dto.book !== undefined && dto.book !== null) ? dto.book.slice(0) : dto.book;
      clone.classKind = dto.classKind;
      clone.commonFileStore = dto.commonFileStore;
      clone.engineeringModelSetup = dto.engineeringModelSetup;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.genericNote = (dto.genericNote !== undefined && dto.genericNote !== null) ? dto.genericNote.slice(0) : dto.genericNote;
      clone.iteration = (dto.iteration !== undefined && dto.iteration !== null) ? dto.iteration.slice(0) : dto.iteration;
      clone.lastModifiedOn = dto.lastModifiedOn;
      clone.logEntry = (dto.logEntry !== undefined && dto.logEntry !== null) ? dto.logEntry.slice(0) : dto.logEntry;
      clone.modellingAnnotation = (dto.modellingAnnotation !== undefined && dto.modellingAnnotation !== null) ? dto.modellingAnnotation.slice(0) : dto.modellingAnnotation;
      clone.modifiedOn = dto.modifiedOn;

      return clone;
    }
  }

  /**
   * The metadata for EngineeringModelDataDiscussionItem
   */
  class EngineeringModelDataDiscussionItemMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "EngineeringModelDataDiscussionItem";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DiscussionItem";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModelDataAnnotation", "discussion");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "author": new PropertyMetadata("author", "Participant", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "replyTo": new PropertyMetadata("replyTo", "DiscussionItem", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const engineeringModelDataDiscussionItem = <Dto.EngineeringModelDataDiscussionItem>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const engineeringModelDataDiscussionItem = <Dto.EngineeringModelDataDiscussionItem>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.EngineeringModelDataDiscussionItem) => any } = {
      "author": (dto : Dto.EngineeringModelDataDiscussionItem) => { return dto.author },
      "classKind": (dto : Dto.EngineeringModelDataDiscussionItem) => { return dto.classKind },
      "content": (dto : Dto.EngineeringModelDataDiscussionItem) => { return dto.content },
      "createdOn": (dto : Dto.EngineeringModelDataDiscussionItem) => { return dto.createdOn },
      "excludedDomain": (dto : Dto.EngineeringModelDataDiscussionItem) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.EngineeringModelDataDiscussionItem) => { return dto.excludedPerson },
      "iid": (dto : Dto.EngineeringModelDataDiscussionItem) => { return dto.iid },
      "languageCode": (dto : Dto.EngineeringModelDataDiscussionItem) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.EngineeringModelDataDiscussionItem) => { return dto.modifiedOn },
      "replyTo": (dto : Dto.EngineeringModelDataDiscussionItem) => { return dto.replyTo },
      "revisionNumber": (dto : Dto.EngineeringModelDataDiscussionItem) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.EngineeringModelDataDiscussionItem>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.EngineeringModelDataDiscussionItem>dtoThing;
      const clone = new Dto.EngineeringModelDataDiscussionItem(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.author = dto.author;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.createdOn = dto.createdOn;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.replyTo = dto.replyTo;

      return clone;
    }
  }

  /**
   * The metadata for EngineeringModelDataNote
   */
  class EngineeringModelDataNoteMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "EngineeringModelDataNote";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "EngineeringModelDataAnnotation";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModel", "genericNote");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "author": new PropertyMetadata("author", "Participant", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "discussion": new PropertyMetadata("discussion", "EngineeringModelDataDiscussionItem", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "primaryAnnotatedThing": new PropertyMetadata("primaryAnnotatedThing", "ModellingThingReference", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "relatedThing": new PropertyMetadata("relatedThing", "ModellingThingReference", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const engineeringModelDataNote = <Dto.EngineeringModelDataNote>thing;
      return {
        "discussion": engineeringModelDataNote.discussion,
        "relatedThing": engineeringModelDataNote.relatedThing,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const engineeringModelDataNote = <Dto.EngineeringModelDataNote>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.EngineeringModelDataNote) => any } = {
      "author": (dto : Dto.EngineeringModelDataNote) => { return dto.author },
      "classKind": (dto : Dto.EngineeringModelDataNote) => { return dto.classKind },
      "content": (dto : Dto.EngineeringModelDataNote) => { return dto.content },
      "createdOn": (dto : Dto.EngineeringModelDataNote) => { return dto.createdOn },
      "discussion": (dto : Dto.EngineeringModelDataNote) => { return dto.discussion },
      "excludedDomain": (dto : Dto.EngineeringModelDataNote) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.EngineeringModelDataNote) => { return dto.excludedPerson },
      "iid": (dto : Dto.EngineeringModelDataNote) => { return dto.iid },
      "languageCode": (dto : Dto.EngineeringModelDataNote) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.EngineeringModelDataNote) => { return dto.modifiedOn },
      "primaryAnnotatedThing": (dto : Dto.EngineeringModelDataNote) => { return dto.primaryAnnotatedThing },
      "relatedThing": (dto : Dto.EngineeringModelDataNote) => { return dto.relatedThing },
      "revisionNumber": (dto : Dto.EngineeringModelDataNote) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.EngineeringModelDataNote>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.EngineeringModelDataNote>dtoThing;
      const clone = new Dto.EngineeringModelDataNote(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.author = dto.author;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.createdOn = dto.createdOn;
      clone.discussion = (dto.discussion !== undefined && dto.discussion !== null) ? dto.discussion.slice(0) : dto.discussion;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.primaryAnnotatedThing = dto.primaryAnnotatedThing;
      clone.relatedThing = (dto.relatedThing !== undefined && dto.relatedThing !== null) ? dto.relatedThing.slice(0) : dto.relatedThing;

      return clone;
    }
  }

  /**
   * The metadata for EngineeringModelSetup
   */
  class EngineeringModelSetupMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "EngineeringModelSetup";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("SiteDirectory", "model");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "activeDomain": new PropertyMetadata("activeDomain", "DomainOfExpertise", 1, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "engineeringModelIid": new PropertyMetadata("engineeringModelIid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iterationSetup": new PropertyMetadata("iterationSetup", "IterationSetup", 1, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "kind": new PropertyMetadata("kind", "EngineeringModelKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "participant": new PropertyMetadata("participant", "Participant", 1, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "requiredRdl": new PropertyMetadata("requiredRdl", "ModelReferenceDataLibrary", 1, "1", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "sourceEngineeringModelSetupIid": new PropertyMetadata("sourceEngineeringModelSetupIid", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "studyPhase": new PropertyMetadata("studyPhase", "StudyPhaseKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const engineeringModelSetup = <Dto.EngineeringModelSetup>thing;
      return {
        "alias": engineeringModelSetup.alias,
        "definition": engineeringModelSetup.definition,
        "hyperLink": engineeringModelSetup.hyperLink,
        "iterationSetup": engineeringModelSetup.iterationSetup,
        "participant": engineeringModelSetup.participant,
        "requiredRdl": engineeringModelSetup.requiredRdl,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const engineeringModelSetup = <Dto.EngineeringModelSetup>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.EngineeringModelSetup) => any } = {
      "activeDomain": (dto : Dto.EngineeringModelSetup) => { return dto.activeDomain },
      "alias": (dto : Dto.EngineeringModelSetup) => { return dto.alias },
      "classKind": (dto : Dto.EngineeringModelSetup) => { return dto.classKind },
      "definition": (dto : Dto.EngineeringModelSetup) => { return dto.definition },
      "engineeringModelIid": (dto : Dto.EngineeringModelSetup) => { return dto.engineeringModelIid },
      "excludedDomain": (dto : Dto.EngineeringModelSetup) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.EngineeringModelSetup) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.EngineeringModelSetup) => { return dto.hyperLink },
      "iid": (dto : Dto.EngineeringModelSetup) => { return dto.iid },
      "iterationSetup": (dto : Dto.EngineeringModelSetup) => { return dto.iterationSetup },
      "kind": (dto : Dto.EngineeringModelSetup) => { return dto.kind },
      "modifiedOn": (dto : Dto.EngineeringModelSetup) => { return dto.modifiedOn },
      "name": (dto : Dto.EngineeringModelSetup) => { return dto.name },
      "participant": (dto : Dto.EngineeringModelSetup) => { return dto.participant },
      "requiredRdl": (dto : Dto.EngineeringModelSetup) => { return dto.requiredRdl },
      "revisionNumber": (dto : Dto.EngineeringModelSetup) => { return dto.revisionNumber },
      "shortName": (dto : Dto.EngineeringModelSetup) => { return dto.shortName },
      "sourceEngineeringModelSetupIid": (dto : Dto.EngineeringModelSetup) => { return dto.sourceEngineeringModelSetupIid },
      "studyPhase": (dto : Dto.EngineeringModelSetup) => { return dto.studyPhase },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.EngineeringModelSetup>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.EngineeringModelSetup>dtoThing;
      const clone = new Dto.EngineeringModelSetup(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.activeDomain = (dto.activeDomain !== undefined && dto.activeDomain !== null) ? dto.activeDomain.slice(0) : dto.activeDomain;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.engineeringModelIid = dto.engineeringModelIid;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.iterationSetup = (dto.iterationSetup !== undefined && dto.iterationSetup !== null) ? dto.iterationSetup.slice(0) : dto.iterationSetup;
      clone.kind = dto.kind;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.participant = (dto.participant !== undefined && dto.participant !== null) ? dto.participant.slice(0) : dto.participant;
      clone.requiredRdl = dto.requiredRdl;
      clone.shortName = dto.shortName;
      clone.sourceEngineeringModelSetupIid = dto.sourceEngineeringModelSetupIid;
      clone.studyPhase = dto.studyPhase;

      return clone;
    }
  }

  /**
   * The metadata for EnumerationParameterType
   */
  class EnumerationParameterTypeMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "EnumerationParameterType";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ScalarParameterType";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "parameterType");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "allowMultiSelect": new PropertyMetadata("allowMultiSelect", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "numberOfValues": new PropertyMetadata("numberOfValues", "number", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "symbol": new PropertyMetadata("symbol", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "valueDefinition": new PropertyMetadata("valueDefinition", "EnumerationValueDefinition", 1, "*", AggregationKind.Composite, false, true, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const enumerationParameterType = <Dto.EnumerationParameterType>thing;
      return {
        "alias": enumerationParameterType.alias,
        "definition": enumerationParameterType.definition,
        "hyperLink": enumerationParameterType.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const enumerationParameterType = <Dto.EnumerationParameterType>thing;
      return {
        "valueDefinition": enumerationParameterType.valueDefinition,
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.EnumerationParameterType) => any } = {
      "alias": (dto : Dto.EnumerationParameterType) => { return dto.alias },
      "allowMultiSelect": (dto : Dto.EnumerationParameterType) => { return dto.allowMultiSelect },
      "category": (dto : Dto.EnumerationParameterType) => { return dto.category },
      "classKind": (dto : Dto.EnumerationParameterType) => { return dto.classKind },
      "definition": (dto : Dto.EnumerationParameterType) => { return dto.definition },
      "excludedDomain": (dto : Dto.EnumerationParameterType) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.EnumerationParameterType) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.EnumerationParameterType) => { return dto.hyperLink },
      "iid": (dto : Dto.EnumerationParameterType) => { return dto.iid },
      "isDeprecated": (dto : Dto.EnumerationParameterType) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.EnumerationParameterType) => { return dto.modifiedOn },
      "name": (dto : Dto.EnumerationParameterType) => { return dto.name },
      "numberOfValues": (dto : Dto.EnumerationParameterType) => { return dto.numberOfValues },
      "revisionNumber": (dto : Dto.EnumerationParameterType) => { return dto.revisionNumber },
      "shortName": (dto : Dto.EnumerationParameterType) => { return dto.shortName },
      "symbol": (dto : Dto.EnumerationParameterType) => { return dto.symbol },
      "valueDefinition": (dto : Dto.EnumerationParameterType) => { return dto.valueDefinition },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.EnumerationParameterType>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.EnumerationParameterType>dtoThing;
      const clone = new Dto.EnumerationParameterType(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.allowMultiSelect = dto.allowMultiSelect;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;
      clone.symbol = dto.symbol;
      clone.valueDefinition = (dto.valueDefinition !== undefined && dto.valueDefinition !== null) ? dto.valueDefinition.slice(0) : dto.valueDefinition;

      return clone;
    }
  }

  /**
   * The metadata for EnumerationValueDefinition
   */
  class EnumerationValueDefinitionMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "EnumerationValueDefinition";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EnumerationParameterType", "valueDefinition");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const enumerationValueDefinition = <Dto.EnumerationValueDefinition>thing;
      return {
        "alias": enumerationValueDefinition.alias,
        "definition": enumerationValueDefinition.definition,
        "hyperLink": enumerationValueDefinition.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const enumerationValueDefinition = <Dto.EnumerationValueDefinition>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.EnumerationValueDefinition) => any } = {
      "alias": (dto : Dto.EnumerationValueDefinition) => { return dto.alias },
      "classKind": (dto : Dto.EnumerationValueDefinition) => { return dto.classKind },
      "definition": (dto : Dto.EnumerationValueDefinition) => { return dto.definition },
      "excludedDomain": (dto : Dto.EnumerationValueDefinition) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.EnumerationValueDefinition) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.EnumerationValueDefinition) => { return dto.hyperLink },
      "iid": (dto : Dto.EnumerationValueDefinition) => { return dto.iid },
      "modifiedOn": (dto : Dto.EnumerationValueDefinition) => { return dto.modifiedOn },
      "name": (dto : Dto.EnumerationValueDefinition) => { return dto.name },
      "revisionNumber": (dto : Dto.EnumerationValueDefinition) => { return dto.revisionNumber },
      "shortName": (dto : Dto.EnumerationValueDefinition) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.EnumerationValueDefinition>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.EnumerationValueDefinition>dtoThing;
      const clone = new Dto.EnumerationValueDefinition(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for ExclusiveOrExpression
   */
  class ExclusiveOrExpressionMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ExclusiveOrExpression";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "BooleanExpression";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ParametricConstraint", "expression");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "term": new PropertyMetadata("term", "BooleanExpression", 2, "2", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const exclusiveOrExpression = <Dto.ExclusiveOrExpression>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const exclusiveOrExpression = <Dto.ExclusiveOrExpression>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ExclusiveOrExpression) => any } = {
      "classKind": (dto : Dto.ExclusiveOrExpression) => { return dto.classKind },
      "excludedDomain": (dto : Dto.ExclusiveOrExpression) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ExclusiveOrExpression) => { return dto.excludedPerson },
      "iid": (dto : Dto.ExclusiveOrExpression) => { return dto.iid },
      "modifiedOn": (dto : Dto.ExclusiveOrExpression) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.ExclusiveOrExpression) => { return dto.revisionNumber },
      "term": (dto : Dto.ExclusiveOrExpression) => { return dto.term },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ExclusiveOrExpression>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ExclusiveOrExpression>dtoThing;
      const clone = new Dto.ExclusiveOrExpression(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.term = (dto.term !== undefined && dto.term !== null) ? dto.term.slice(0) : dto.term;

      return clone;
    }
  }

  /**
   * The metadata for ExternalIdentifierMap
   */
  class ExternalIdentifierMapMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ExternalIdentifierMap";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "externalIdentifierMap");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "correspondence": new PropertyMetadata("correspondence", "IdCorrespondence", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "externalFormat": new PropertyMetadata("externalFormat", "ReferenceSource", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "externalModelName": new PropertyMetadata("externalModelName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "externalToolName": new PropertyMetadata("externalToolName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "externalToolVersion": new PropertyMetadata("externalToolVersion", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const externalIdentifierMap = <Dto.ExternalIdentifierMap>thing;
      return {
        "correspondence": externalIdentifierMap.correspondence,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const externalIdentifierMap = <Dto.ExternalIdentifierMap>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ExternalIdentifierMap) => any } = {
      "classKind": (dto : Dto.ExternalIdentifierMap) => { return dto.classKind },
      "correspondence": (dto : Dto.ExternalIdentifierMap) => { return dto.correspondence },
      "excludedDomain": (dto : Dto.ExternalIdentifierMap) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ExternalIdentifierMap) => { return dto.excludedPerson },
      "externalFormat": (dto : Dto.ExternalIdentifierMap) => { return dto.externalFormat },
      "externalModelName": (dto : Dto.ExternalIdentifierMap) => { return dto.externalModelName },
      "externalToolName": (dto : Dto.ExternalIdentifierMap) => { return dto.externalToolName },
      "externalToolVersion": (dto : Dto.ExternalIdentifierMap) => { return dto.externalToolVersion },
      "iid": (dto : Dto.ExternalIdentifierMap) => { return dto.iid },
      "modifiedOn": (dto : Dto.ExternalIdentifierMap) => { return dto.modifiedOn },
      "name": (dto : Dto.ExternalIdentifierMap) => { return dto.name },
      "owner": (dto : Dto.ExternalIdentifierMap) => { return dto.owner },
      "revisionNumber": (dto : Dto.ExternalIdentifierMap) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ExternalIdentifierMap>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ExternalIdentifierMap>dtoThing;
      const clone = new Dto.ExternalIdentifierMap(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.correspondence = (dto.correspondence !== undefined && dto.correspondence !== null) ? dto.correspondence.slice(0) : dto.correspondence;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.externalFormat = dto.externalFormat;
      clone.externalModelName = dto.externalModelName;
      clone.externalToolName = dto.externalToolName;
      clone.externalToolVersion = dto.externalToolVersion;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.owner = dto.owner;

      return clone;
    }
  }

  /**
   * The metadata for File
   */
  class FileMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "File";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("FileStore", "file");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "fileRevision": new PropertyMetadata("fileRevision", "FileRevision", 1, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "lockedBy": new PropertyMetadata("lockedBy", "Person", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const file = <Dto.File>thing;
      return {
        "fileRevision": file.fileRevision,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const file = <Dto.File>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.File) => any } = {
      "category": (dto : Dto.File) => { return dto.category },
      "classKind": (dto : Dto.File) => { return dto.classKind },
      "excludedDomain": (dto : Dto.File) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.File) => { return dto.excludedPerson },
      "fileRevision": (dto : Dto.File) => { return dto.fileRevision },
      "iid": (dto : Dto.File) => { return dto.iid },
      "lockedBy": (dto : Dto.File) => { return dto.lockedBy },
      "modifiedOn": (dto : Dto.File) => { return dto.modifiedOn },
      "owner": (dto : Dto.File) => { return dto.owner },
      "revisionNumber": (dto : Dto.File) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.File>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.File>dtoThing;
      const clone = new Dto.File(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.fileRevision = (dto.fileRevision !== undefined && dto.fileRevision !== null) ? dto.fileRevision.slice(0) : dto.fileRevision;
      clone.lockedBy = dto.lockedBy;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;

      return clone;
    }
  }

  /**
   * The metadata for FileRevision
   */
  class FileRevisionMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "FileRevision";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("File", "fileRevision");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "containingFolder": new PropertyMetadata("containingFolder", "Folder", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "contentHash": new PropertyMetadata("contentHash", "string", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "creator": new PropertyMetadata("creator", "Participant", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "fileType": new PropertyMetadata("fileType", "FileType", 1, "*", AggregationKind.None, false, true, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "path": new PropertyMetadata("path", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const fileRevision = <Dto.FileRevision>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const fileRevision = <Dto.FileRevision>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.FileRevision) => any } = {
      "classKind": (dto : Dto.FileRevision) => { return dto.classKind },
      "containingFolder": (dto : Dto.FileRevision) => { return dto.containingFolder },
      "contentHash": (dto : Dto.FileRevision) => { return dto.contentHash },
      "createdOn": (dto : Dto.FileRevision) => { return dto.createdOn },
      "creator": (dto : Dto.FileRevision) => { return dto.creator },
      "excludedDomain": (dto : Dto.FileRevision) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.FileRevision) => { return dto.excludedPerson },
      "fileType": (dto : Dto.FileRevision) => { return dto.fileType },
      "iid": (dto : Dto.FileRevision) => { return dto.iid },
      "modifiedOn": (dto : Dto.FileRevision) => { return dto.modifiedOn },
      "name": (dto : Dto.FileRevision) => { return dto.name },
      "path": (dto : Dto.FileRevision) => { return dto.path },
      "revisionNumber": (dto : Dto.FileRevision) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.FileRevision>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.FileRevision>dtoThing;
      const clone = new Dto.FileRevision(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.containingFolder = dto.containingFolder;
      clone.contentHash = dto.contentHash;
      clone.createdOn = dto.createdOn;
      clone.creator = dto.creator;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.fileType = (dto.fileType !== undefined && dto.fileType !== null) ? dto.fileType.slice(0) : dto.fileType;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;

      return clone;
    }
  }

  /**
   * The metadata for FileType
   */
  class FileTypeMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "FileType";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "fileType");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "extension": new PropertyMetadata("extension", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const fileType = <Dto.FileType>thing;
      return {
        "alias": fileType.alias,
        "definition": fileType.definition,
        "hyperLink": fileType.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const fileType = <Dto.FileType>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.FileType) => any } = {
      "alias": (dto : Dto.FileType) => { return dto.alias },
      "category": (dto : Dto.FileType) => { return dto.category },
      "classKind": (dto : Dto.FileType) => { return dto.classKind },
      "definition": (dto : Dto.FileType) => { return dto.definition },
      "excludedDomain": (dto : Dto.FileType) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.FileType) => { return dto.excludedPerson },
      "extension": (dto : Dto.FileType) => { return dto.extension },
      "hyperLink": (dto : Dto.FileType) => { return dto.hyperLink },
      "iid": (dto : Dto.FileType) => { return dto.iid },
      "isDeprecated": (dto : Dto.FileType) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.FileType) => { return dto.modifiedOn },
      "name": (dto : Dto.FileType) => { return dto.name },
      "revisionNumber": (dto : Dto.FileType) => { return dto.revisionNumber },
      "shortName": (dto : Dto.FileType) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.FileType>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.FileType>dtoThing;
      const clone = new Dto.FileType(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.extension = dto.extension;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for Folder
   */
  class FolderMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Folder";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("FileStore", "folder");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "containingFolder": new PropertyMetadata("containingFolder", "Folder", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "creator": new PropertyMetadata("creator", "Participant", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "path": new PropertyMetadata("path", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const folder = <Dto.Folder>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const folder = <Dto.Folder>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Folder) => any } = {
      "classKind": (dto : Dto.Folder) => { return dto.classKind },
      "containingFolder": (dto : Dto.Folder) => { return dto.containingFolder },
      "createdOn": (dto : Dto.Folder) => { return dto.createdOn },
      "creator": (dto : Dto.Folder) => { return dto.creator },
      "excludedDomain": (dto : Dto.Folder) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Folder) => { return dto.excludedPerson },
      "iid": (dto : Dto.Folder) => { return dto.iid },
      "modifiedOn": (dto : Dto.Folder) => { return dto.modifiedOn },
      "name": (dto : Dto.Folder) => { return dto.name },
      "owner": (dto : Dto.Folder) => { return dto.owner },
      "path": (dto : Dto.Folder) => { return dto.path },
      "revisionNumber": (dto : Dto.Folder) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Folder>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Folder>dtoThing;
      const clone = new Dto.Folder(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.containingFolder = dto.containingFolder;
      clone.createdOn = dto.createdOn;
      clone.creator = dto.creator;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.owner = dto.owner;

      return clone;
    }
  }

  /**
   * The metadata for Glossary
   */
  class GlossaryMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Glossary";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "glossary");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "term": new PropertyMetadata("term", "Term", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const glossary = <Dto.Glossary>thing;
      return {
        "alias": glossary.alias,
        "definition": glossary.definition,
        "hyperLink": glossary.hyperLink,
        "term": glossary.term,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const glossary = <Dto.Glossary>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Glossary) => any } = {
      "alias": (dto : Dto.Glossary) => { return dto.alias },
      "category": (dto : Dto.Glossary) => { return dto.category },
      "classKind": (dto : Dto.Glossary) => { return dto.classKind },
      "definition": (dto : Dto.Glossary) => { return dto.definition },
      "excludedDomain": (dto : Dto.Glossary) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Glossary) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.Glossary) => { return dto.hyperLink },
      "iid": (dto : Dto.Glossary) => { return dto.iid },
      "isDeprecated": (dto : Dto.Glossary) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.Glossary) => { return dto.modifiedOn },
      "name": (dto : Dto.Glossary) => { return dto.name },
      "revisionNumber": (dto : Dto.Glossary) => { return dto.revisionNumber },
      "shortName": (dto : Dto.Glossary) => { return dto.shortName },
      "term": (dto : Dto.Glossary) => { return dto.term },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Glossary>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Glossary>dtoThing;
      const clone = new Dto.Glossary(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;
      clone.term = (dto.term !== undefined && dto.term !== null) ? dto.term.slice(0) : dto.term;

      return clone;
    }
  }

  /**
   * The metadata for Goal
   */
  class GoalMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Goal";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "goal");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const goal = <Dto.Goal>thing;
      return {
        "alias": goal.alias,
        "definition": goal.definition,
        "hyperLink": goal.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const goal = <Dto.Goal>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Goal) => any } = {
      "alias": (dto : Dto.Goal) => { return dto.alias },
      "category": (dto : Dto.Goal) => { return dto.category },
      "classKind": (dto : Dto.Goal) => { return dto.classKind },
      "definition": (dto : Dto.Goal) => { return dto.definition },
      "excludedDomain": (dto : Dto.Goal) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Goal) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.Goal) => { return dto.hyperLink },
      "iid": (dto : Dto.Goal) => { return dto.iid },
      "modifiedOn": (dto : Dto.Goal) => { return dto.modifiedOn },
      "name": (dto : Dto.Goal) => { return dto.name },
      "revisionNumber": (dto : Dto.Goal) => { return dto.revisionNumber },
      "shortName": (dto : Dto.Goal) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Goal>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Goal>dtoThing;
      const clone = new Dto.Goal(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for HyperLink
   */
  class HyperLinkMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "HyperLink";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("DefinedThing", "hyperLink");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "uri": new PropertyMetadata("uri", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const hyperLink = <Dto.HyperLink>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const hyperLink = <Dto.HyperLink>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.HyperLink) => any } = {
      "classKind": (dto : Dto.HyperLink) => { return dto.classKind },
      "content": (dto : Dto.HyperLink) => { return dto.content },
      "excludedDomain": (dto : Dto.HyperLink) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.HyperLink) => { return dto.excludedPerson },
      "iid": (dto : Dto.HyperLink) => { return dto.iid },
      "languageCode": (dto : Dto.HyperLink) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.HyperLink) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.HyperLink) => { return dto.revisionNumber },
      "uri": (dto : Dto.HyperLink) => { return dto.uri },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.HyperLink>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.HyperLink>dtoThing;
      const clone = new Dto.HyperLink(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.uri = dto.uri;

      return clone;
    }
  }

  /**
   * The metadata for IdCorrespondence
   */
  class IdCorrespondenceMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "IdCorrespondence";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ExternalIdentifierMap", "correspondence");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "externalId": new PropertyMetadata("externalId", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "internalThing": new PropertyMetadata("internalThing", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const idCorrespondence = <Dto.IdCorrespondence>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const idCorrespondence = <Dto.IdCorrespondence>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.IdCorrespondence) => any } = {
      "classKind": (dto : Dto.IdCorrespondence) => { return dto.classKind },
      "excludedDomain": (dto : Dto.IdCorrespondence) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.IdCorrespondence) => { return dto.excludedPerson },
      "externalId": (dto : Dto.IdCorrespondence) => { return dto.externalId },
      "iid": (dto : Dto.IdCorrespondence) => { return dto.iid },
      "internalThing": (dto : Dto.IdCorrespondence) => { return dto.internalThing },
      "modifiedOn": (dto : Dto.IdCorrespondence) => { return dto.modifiedOn },
      "owner": (dto : Dto.IdCorrespondence) => { return dto.owner },
      "revisionNumber": (dto : Dto.IdCorrespondence) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.IdCorrespondence>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.IdCorrespondence>dtoThing;
      const clone = new Dto.IdCorrespondence(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.externalId = dto.externalId;
      clone.internalThing = dto.internalThing;
      clone.modifiedOn = dto.modifiedOn;

      return clone;
    }
  }

  /**
   * The metadata for IntervalScale
   */
  class IntervalScaleMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "IntervalScale";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "MeasurementScale";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "scale");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isMaximumInclusive": new PropertyMetadata("isMaximumInclusive", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isMinimumInclusive": new PropertyMetadata("isMinimumInclusive", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "mappingToReferenceScale": new PropertyMetadata("mappingToReferenceScale", "MappingToReferenceScale", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "maximumPermissibleValue": new PropertyMetadata("maximumPermissibleValue", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "minimumPermissibleValue": new PropertyMetadata("minimumPermissibleValue", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "negativeValueConnotation": new PropertyMetadata("negativeValueConnotation", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "numberSet": new PropertyMetadata("numberSet", "NumberSetKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "positiveValueConnotation": new PropertyMetadata("positiveValueConnotation", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "unit": new PropertyMetadata("unit", "MeasurementUnit", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "valueDefinition": new PropertyMetadata("valueDefinition", "ScaleValueDefinition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const intervalScale = <Dto.IntervalScale>thing;
      return {
        "alias": intervalScale.alias,
        "definition": intervalScale.definition,
        "hyperLink": intervalScale.hyperLink,
        "mappingToReferenceScale": intervalScale.mappingToReferenceScale,
        "valueDefinition": intervalScale.valueDefinition,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const intervalScale = <Dto.IntervalScale>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.IntervalScale) => any } = {
      "alias": (dto : Dto.IntervalScale) => { return dto.alias },
      "classKind": (dto : Dto.IntervalScale) => { return dto.classKind },
      "definition": (dto : Dto.IntervalScale) => { return dto.definition },
      "excludedDomain": (dto : Dto.IntervalScale) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.IntervalScale) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.IntervalScale) => { return dto.hyperLink },
      "iid": (dto : Dto.IntervalScale) => { return dto.iid },
      "isDeprecated": (dto : Dto.IntervalScale) => { return dto.isDeprecated },
      "isMaximumInclusive": (dto : Dto.IntervalScale) => { return dto.isMaximumInclusive },
      "isMinimumInclusive": (dto : Dto.IntervalScale) => { return dto.isMinimumInclusive },
      "mappingToReferenceScale": (dto : Dto.IntervalScale) => { return dto.mappingToReferenceScale },
      "maximumPermissibleValue": (dto : Dto.IntervalScale) => { return dto.maximumPermissibleValue },
      "minimumPermissibleValue": (dto : Dto.IntervalScale) => { return dto.minimumPermissibleValue },
      "modifiedOn": (dto : Dto.IntervalScale) => { return dto.modifiedOn },
      "name": (dto : Dto.IntervalScale) => { return dto.name },
      "negativeValueConnotation": (dto : Dto.IntervalScale) => { return dto.negativeValueConnotation },
      "numberSet": (dto : Dto.IntervalScale) => { return dto.numberSet },
      "positiveValueConnotation": (dto : Dto.IntervalScale) => { return dto.positiveValueConnotation },
      "revisionNumber": (dto : Dto.IntervalScale) => { return dto.revisionNumber },
      "shortName": (dto : Dto.IntervalScale) => { return dto.shortName },
      "unit": (dto : Dto.IntervalScale) => { return dto.unit },
      "valueDefinition": (dto : Dto.IntervalScale) => { return dto.valueDefinition },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.IntervalScale>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.IntervalScale>dtoThing;
      const clone = new Dto.IntervalScale(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.isMaximumInclusive = dto.isMaximumInclusive;
      clone.isMinimumInclusive = dto.isMinimumInclusive;
      clone.mappingToReferenceScale = (dto.mappingToReferenceScale !== undefined && dto.mappingToReferenceScale !== null) ? dto.mappingToReferenceScale.slice(0) : dto.mappingToReferenceScale;
      clone.maximumPermissibleValue = dto.maximumPermissibleValue;
      clone.minimumPermissibleValue = dto.minimumPermissibleValue;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.negativeValueConnotation = dto.negativeValueConnotation;
      clone.numberSet = dto.numberSet;
      clone.positiveValueConnotation = dto.positiveValueConnotation;
      clone.shortName = dto.shortName;
      clone.unit = dto.unit;
      clone.valueDefinition = (dto.valueDefinition !== undefined && dto.valueDefinition !== null) ? dto.valueDefinition.slice(0) : dto.valueDefinition;

      return clone;
    }
  }

  /**
   * The metadata for Iteration
   */
  class IterationMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Iteration";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModel", "iteration");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "actualFiniteStateList": new PropertyMetadata("actualFiniteStateList", "ActualFiniteStateList", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "defaultOption": new PropertyMetadata("defaultOption", "Option", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "diagramCanvas": new PropertyMetadata("diagramCanvas", "DiagramCanvas", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.1.0"),
      "domainFileStore": new PropertyMetadata("domainFileStore", "DomainFileStore", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "element": new PropertyMetadata("element", "ElementDefinition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "externalIdentifierMap": new PropertyMetadata("externalIdentifierMap", "ExternalIdentifierMap", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "goal": new PropertyMetadata("goal", "Goal", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iterationSetup": new PropertyMetadata("iterationSetup", "IterationSetup", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "option": new PropertyMetadata("option", "Option", 1, "*", AggregationKind.Composite, false, true, false, false, false, true, "1.0.0"),
      "possibleFiniteStateList": new PropertyMetadata("possibleFiniteStateList", "PossibleFiniteStateList", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "publication": new PropertyMetadata("publication", "Publication", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "relationship": new PropertyMetadata("relationship", "Relationship", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "requirementsSpecification": new PropertyMetadata("requirementsSpecification", "RequirementsSpecification", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "ruleVerificationList": new PropertyMetadata("ruleVerificationList", "RuleVerificationList", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "sharedDiagramStyle": new PropertyMetadata("sharedDiagramStyle", "SharedStyle", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.1.0"),
      "sourceIterationIid": new PropertyMetadata("sourceIterationIid", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "stakeholder": new PropertyMetadata("stakeholder", "Stakeholder", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.1.0"),
      "stakeholderValue": new PropertyMetadata("stakeholderValue", "StakeholderValue", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.1.0"),
      "stakeholderValueMap": new PropertyMetadata("stakeholderValueMap", "StakeHolderValueMap", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.1.0"),
      "topElement": new PropertyMetadata("topElement", "ElementDefinition", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "valueGroup": new PropertyMetadata("valueGroup", "ValueGroup", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.1.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const iteration = <Dto.Iteration>thing;
      return {
        "actualFiniteStateList": iteration.actualFiniteStateList,
        "diagramCanvas": iteration.diagramCanvas,
        "domainFileStore": iteration.domainFileStore,
        "element": iteration.element,
        "externalIdentifierMap": iteration.externalIdentifierMap,
        "goal": iteration.goal,
        "possibleFiniteStateList": iteration.possibleFiniteStateList,
        "publication": iteration.publication,
        "relationship": iteration.relationship,
        "requirementsSpecification": iteration.requirementsSpecification,
        "ruleVerificationList": iteration.ruleVerificationList,
        "sharedDiagramStyle": iteration.sharedDiagramStyle,
        "stakeholder": iteration.stakeholder,
        "stakeholderValue": iteration.stakeholderValue,
        "stakeholderValueMap": iteration.stakeholderValueMap,
        "valueGroup": iteration.valueGroup,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const iteration = <Dto.Iteration>thing;
      return {
        "option": iteration.option,
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Iteration) => any } = {
      "actualFiniteStateList": (dto : Dto.Iteration) => { return dto.actualFiniteStateList },
      "classKind": (dto : Dto.Iteration) => { return dto.classKind },
      "defaultOption": (dto : Dto.Iteration) => { return dto.defaultOption },
      "diagramCanvas": (dto : Dto.Iteration) => { return dto.diagramCanvas },
      "domainFileStore": (dto : Dto.Iteration) => { return dto.domainFileStore },
      "element": (dto : Dto.Iteration) => { return dto.element },
      "excludedDomain": (dto : Dto.Iteration) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Iteration) => { return dto.excludedPerson },
      "externalIdentifierMap": (dto : Dto.Iteration) => { return dto.externalIdentifierMap },
      "goal": (dto : Dto.Iteration) => { return dto.goal },
      "iid": (dto : Dto.Iteration) => { return dto.iid },
      "iterationSetup": (dto : Dto.Iteration) => { return dto.iterationSetup },
      "modifiedOn": (dto : Dto.Iteration) => { return dto.modifiedOn },
      "option": (dto : Dto.Iteration) => { return dto.option },
      "possibleFiniteStateList": (dto : Dto.Iteration) => { return dto.possibleFiniteStateList },
      "publication": (dto : Dto.Iteration) => { return dto.publication },
      "relationship": (dto : Dto.Iteration) => { return dto.relationship },
      "requirementsSpecification": (dto : Dto.Iteration) => { return dto.requirementsSpecification },
      "revisionNumber": (dto : Dto.Iteration) => { return dto.revisionNumber },
      "ruleVerificationList": (dto : Dto.Iteration) => { return dto.ruleVerificationList },
      "sharedDiagramStyle": (dto : Dto.Iteration) => { return dto.sharedDiagramStyle },
      "sourceIterationIid": (dto : Dto.Iteration) => { return dto.sourceIterationIid },
      "stakeholder": (dto : Dto.Iteration) => { return dto.stakeholder },
      "stakeholderValue": (dto : Dto.Iteration) => { return dto.stakeholderValue },
      "stakeholderValueMap": (dto : Dto.Iteration) => { return dto.stakeholderValueMap },
      "topElement": (dto : Dto.Iteration) => { return dto.topElement },
      "valueGroup": (dto : Dto.Iteration) => { return dto.valueGroup },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Iteration>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Iteration>dtoThing;
      const clone = new Dto.Iteration(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.actualFiniteStateList = (dto.actualFiniteStateList !== undefined && dto.actualFiniteStateList !== null) ? dto.actualFiniteStateList.slice(0) : dto.actualFiniteStateList;
      clone.classKind = dto.classKind;
      clone.defaultOption = dto.defaultOption;
      clone.diagramCanvas = (dto.diagramCanvas !== undefined && dto.diagramCanvas !== null) ? dto.diagramCanvas.slice(0) : dto.diagramCanvas;
      clone.domainFileStore = (dto.domainFileStore !== undefined && dto.domainFileStore !== null) ? dto.domainFileStore.slice(0) : dto.domainFileStore;
      clone.element = (dto.element !== undefined && dto.element !== null) ? dto.element.slice(0) : dto.element;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.externalIdentifierMap = (dto.externalIdentifierMap !== undefined && dto.externalIdentifierMap !== null) ? dto.externalIdentifierMap.slice(0) : dto.externalIdentifierMap;
      clone.goal = (dto.goal !== undefined && dto.goal !== null) ? dto.goal.slice(0) : dto.goal;
      clone.iterationSetup = dto.iterationSetup;
      clone.modifiedOn = dto.modifiedOn;
      clone.option = (dto.option !== undefined && dto.option !== null) ? dto.option.slice(0) : dto.option;
      clone.possibleFiniteStateList = (dto.possibleFiniteStateList !== undefined && dto.possibleFiniteStateList !== null) ? dto.possibleFiniteStateList.slice(0) : dto.possibleFiniteStateList;
      clone.publication = (dto.publication !== undefined && dto.publication !== null) ? dto.publication.slice(0) : dto.publication;
      clone.relationship = (dto.relationship !== undefined && dto.relationship !== null) ? dto.relationship.slice(0) : dto.relationship;
      clone.requirementsSpecification = (dto.requirementsSpecification !== undefined && dto.requirementsSpecification !== null) ? dto.requirementsSpecification.slice(0) : dto.requirementsSpecification;
      clone.ruleVerificationList = (dto.ruleVerificationList !== undefined && dto.ruleVerificationList !== null) ? dto.ruleVerificationList.slice(0) : dto.ruleVerificationList;
      clone.sharedDiagramStyle = (dto.sharedDiagramStyle !== undefined && dto.sharedDiagramStyle !== null) ? dto.sharedDiagramStyle.slice(0) : dto.sharedDiagramStyle;
      clone.sourceIterationIid = dto.sourceIterationIid;
      clone.stakeholder = (dto.stakeholder !== undefined && dto.stakeholder !== null) ? dto.stakeholder.slice(0) : dto.stakeholder;
      clone.stakeholderValue = (dto.stakeholderValue !== undefined && dto.stakeholderValue !== null) ? dto.stakeholderValue.slice(0) : dto.stakeholderValue;
      clone.stakeholderValueMap = (dto.stakeholderValueMap !== undefined && dto.stakeholderValueMap !== null) ? dto.stakeholderValueMap.slice(0) : dto.stakeholderValueMap;
      clone.topElement = dto.topElement;
      clone.valueGroup = (dto.valueGroup !== undefined && dto.valueGroup !== null) ? dto.valueGroup.slice(0) : dto.valueGroup;

      return clone;
    }
  }

  /**
   * The metadata for IterationSetup
   */
  class IterationSetupMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "IterationSetup";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModelSetup", "iterationSetup");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "description": new PropertyMetadata("description", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "frozenOn": new PropertyMetadata("frozenOn", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeleted": new PropertyMetadata("isDeleted", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iterationIid": new PropertyMetadata("iterationIid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iterationNumber": new PropertyMetadata("iterationNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "sourceIterationSetup": new PropertyMetadata("sourceIterationSetup", "IterationSetup", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const iterationSetup = <Dto.IterationSetup>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const iterationSetup = <Dto.IterationSetup>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.IterationSetup) => any } = {
      "classKind": (dto : Dto.IterationSetup) => { return dto.classKind },
      "createdOn": (dto : Dto.IterationSetup) => { return dto.createdOn },
      "description": (dto : Dto.IterationSetup) => { return dto.description },
      "excludedDomain": (dto : Dto.IterationSetup) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.IterationSetup) => { return dto.excludedPerson },
      "frozenOn": (dto : Dto.IterationSetup) => { return dto.frozenOn },
      "iid": (dto : Dto.IterationSetup) => { return dto.iid },
      "isDeleted": (dto : Dto.IterationSetup) => { return dto.isDeleted },
      "iterationIid": (dto : Dto.IterationSetup) => { return dto.iterationIid },
      "iterationNumber": (dto : Dto.IterationSetup) => { return dto.iterationNumber },
      "modifiedOn": (dto : Dto.IterationSetup) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.IterationSetup) => { return dto.revisionNumber },
      "sourceIterationSetup": (dto : Dto.IterationSetup) => { return dto.sourceIterationSetup },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.IterationSetup>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.IterationSetup>dtoThing;
      const clone = new Dto.IterationSetup(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.createdOn = dto.createdOn;
      clone.description = dto.description;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.frozenOn = dto.frozenOn;
      clone.isDeleted = dto.isDeleted;
      clone.iterationIid = dto.iterationIid;
      clone.iterationNumber = dto.iterationNumber;
      clone.modifiedOn = dto.modifiedOn;
      clone.sourceIterationSetup = dto.sourceIterationSetup;

      return clone;
    }
  }

  /**
   * The metadata for LinearConversionUnit
   */
  class LinearConversionUnitMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "LinearConversionUnit";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ConversionBasedUnit";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "unit");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "conversionFactor": new PropertyMetadata("conversionFactor", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "referenceUnit": new PropertyMetadata("referenceUnit", "MeasurementUnit", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const linearConversionUnit = <Dto.LinearConversionUnit>thing;
      return {
        "alias": linearConversionUnit.alias,
        "definition": linearConversionUnit.definition,
        "hyperLink": linearConversionUnit.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const linearConversionUnit = <Dto.LinearConversionUnit>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.LinearConversionUnit) => any } = {
      "alias": (dto : Dto.LinearConversionUnit) => { return dto.alias },
      "classKind": (dto : Dto.LinearConversionUnit) => { return dto.classKind },
      "conversionFactor": (dto : Dto.LinearConversionUnit) => { return dto.conversionFactor },
      "definition": (dto : Dto.LinearConversionUnit) => { return dto.definition },
      "excludedDomain": (dto : Dto.LinearConversionUnit) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.LinearConversionUnit) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.LinearConversionUnit) => { return dto.hyperLink },
      "iid": (dto : Dto.LinearConversionUnit) => { return dto.iid },
      "isDeprecated": (dto : Dto.LinearConversionUnit) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.LinearConversionUnit) => { return dto.modifiedOn },
      "name": (dto : Dto.LinearConversionUnit) => { return dto.name },
      "referenceUnit": (dto : Dto.LinearConversionUnit) => { return dto.referenceUnit },
      "revisionNumber": (dto : Dto.LinearConversionUnit) => { return dto.revisionNumber },
      "shortName": (dto : Dto.LinearConversionUnit) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.LinearConversionUnit>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.LinearConversionUnit>dtoThing;
      const clone = new Dto.LinearConversionUnit(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.conversionFactor = dto.conversionFactor;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.referenceUnit = dto.referenceUnit;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for LogarithmicScale
   */
  class LogarithmicScaleMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "LogarithmicScale";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "MeasurementScale";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "scale");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "exponent": new PropertyMetadata("exponent", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "factor": new PropertyMetadata("factor", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isMaximumInclusive": new PropertyMetadata("isMaximumInclusive", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isMinimumInclusive": new PropertyMetadata("isMinimumInclusive", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "logarithmBase": new PropertyMetadata("logarithmBase", "LogarithmBaseKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "mappingToReferenceScale": new PropertyMetadata("mappingToReferenceScale", "MappingToReferenceScale", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "maximumPermissibleValue": new PropertyMetadata("maximumPermissibleValue", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "minimumPermissibleValue": new PropertyMetadata("minimumPermissibleValue", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "negativeValueConnotation": new PropertyMetadata("negativeValueConnotation", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "numberSet": new PropertyMetadata("numberSet", "NumberSetKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "positiveValueConnotation": new PropertyMetadata("positiveValueConnotation", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "referenceQuantityKind": new PropertyMetadata("referenceQuantityKind", "QuantityKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "referenceQuantityValue": new PropertyMetadata("referenceQuantityValue", "ScaleReferenceQuantityValue", 0, "1", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "unit": new PropertyMetadata("unit", "MeasurementUnit", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "valueDefinition": new PropertyMetadata("valueDefinition", "ScaleValueDefinition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const logarithmicScale = <Dto.LogarithmicScale>thing;
      return {
        "alias": logarithmicScale.alias,
        "definition": logarithmicScale.definition,
        "hyperLink": logarithmicScale.hyperLink,
        "mappingToReferenceScale": logarithmicScale.mappingToReferenceScale,
        "referenceQuantityValue": logarithmicScale.referenceQuantityValue,
        "valueDefinition": logarithmicScale.valueDefinition,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const logarithmicScale = <Dto.LogarithmicScale>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.LogarithmicScale) => any } = {
      "alias": (dto : Dto.LogarithmicScale) => { return dto.alias },
      "classKind": (dto : Dto.LogarithmicScale) => { return dto.classKind },
      "definition": (dto : Dto.LogarithmicScale) => { return dto.definition },
      "excludedDomain": (dto : Dto.LogarithmicScale) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.LogarithmicScale) => { return dto.excludedPerson },
      "exponent": (dto : Dto.LogarithmicScale) => { return dto.exponent },
      "factor": (dto : Dto.LogarithmicScale) => { return dto.factor },
      "hyperLink": (dto : Dto.LogarithmicScale) => { return dto.hyperLink },
      "iid": (dto : Dto.LogarithmicScale) => { return dto.iid },
      "isDeprecated": (dto : Dto.LogarithmicScale) => { return dto.isDeprecated },
      "isMaximumInclusive": (dto : Dto.LogarithmicScale) => { return dto.isMaximumInclusive },
      "isMinimumInclusive": (dto : Dto.LogarithmicScale) => { return dto.isMinimumInclusive },
      "logarithmBase": (dto : Dto.LogarithmicScale) => { return dto.logarithmBase },
      "mappingToReferenceScale": (dto : Dto.LogarithmicScale) => { return dto.mappingToReferenceScale },
      "maximumPermissibleValue": (dto : Dto.LogarithmicScale) => { return dto.maximumPermissibleValue },
      "minimumPermissibleValue": (dto : Dto.LogarithmicScale) => { return dto.minimumPermissibleValue },
      "modifiedOn": (dto : Dto.LogarithmicScale) => { return dto.modifiedOn },
      "name": (dto : Dto.LogarithmicScale) => { return dto.name },
      "negativeValueConnotation": (dto : Dto.LogarithmicScale) => { return dto.negativeValueConnotation },
      "numberSet": (dto : Dto.LogarithmicScale) => { return dto.numberSet },
      "positiveValueConnotation": (dto : Dto.LogarithmicScale) => { return dto.positiveValueConnotation },
      "referenceQuantityKind": (dto : Dto.LogarithmicScale) => { return dto.referenceQuantityKind },
      "referenceQuantityValue": (dto : Dto.LogarithmicScale) => { return dto.referenceQuantityValue },
      "revisionNumber": (dto : Dto.LogarithmicScale) => { return dto.revisionNumber },
      "shortName": (dto : Dto.LogarithmicScale) => { return dto.shortName },
      "unit": (dto : Dto.LogarithmicScale) => { return dto.unit },
      "valueDefinition": (dto : Dto.LogarithmicScale) => { return dto.valueDefinition },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.LogarithmicScale>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.LogarithmicScale>dtoThing;
      const clone = new Dto.LogarithmicScale(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.exponent = dto.exponent;
      clone.factor = dto.factor;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.isMaximumInclusive = dto.isMaximumInclusive;
      clone.isMinimumInclusive = dto.isMinimumInclusive;
      clone.logarithmBase = dto.logarithmBase;
      clone.mappingToReferenceScale = (dto.mappingToReferenceScale !== undefined && dto.mappingToReferenceScale !== null) ? dto.mappingToReferenceScale.slice(0) : dto.mappingToReferenceScale;
      clone.maximumPermissibleValue = dto.maximumPermissibleValue;
      clone.minimumPermissibleValue = dto.minimumPermissibleValue;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.negativeValueConnotation = dto.negativeValueConnotation;
      clone.numberSet = dto.numberSet;
      clone.positiveValueConnotation = dto.positiveValueConnotation;
      clone.referenceQuantityKind = dto.referenceQuantityKind;
      clone.referenceQuantityValue = dto.referenceQuantityValue;
      clone.shortName = dto.shortName;
      clone.unit = dto.unit;
      clone.valueDefinition = (dto.valueDefinition !== undefined && dto.valueDefinition !== null) ? dto.valueDefinition.slice(0) : dto.valueDefinition;

      return clone;
    }
  }

  /**
   * The metadata for MappingToReferenceScale
   */
  class MappingToReferenceScaleMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "MappingToReferenceScale";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("MeasurementScale", "mappingToReferenceScale");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "dependentScaleValue": new PropertyMetadata("dependentScaleValue", "ScaleValueDefinition", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "referenceScaleValue": new PropertyMetadata("referenceScaleValue", "ScaleValueDefinition", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const mappingToReferenceScale = <Dto.MappingToReferenceScale>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const mappingToReferenceScale = <Dto.MappingToReferenceScale>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.MappingToReferenceScale) => any } = {
      "classKind": (dto : Dto.MappingToReferenceScale) => { return dto.classKind },
      "dependentScaleValue": (dto : Dto.MappingToReferenceScale) => { return dto.dependentScaleValue },
      "excludedDomain": (dto : Dto.MappingToReferenceScale) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.MappingToReferenceScale) => { return dto.excludedPerson },
      "iid": (dto : Dto.MappingToReferenceScale) => { return dto.iid },
      "modifiedOn": (dto : Dto.MappingToReferenceScale) => { return dto.modifiedOn },
      "referenceScaleValue": (dto : Dto.MappingToReferenceScale) => { return dto.referenceScaleValue },
      "revisionNumber": (dto : Dto.MappingToReferenceScale) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.MappingToReferenceScale>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.MappingToReferenceScale>dtoThing;
      const clone = new Dto.MappingToReferenceScale(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.dependentScaleValue = dto.dependentScaleValue;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.referenceScaleValue = dto.referenceScaleValue;

      return clone;
    }
  }

  /**
   * The metadata for ModellingThingReference
   */
  class ModellingThingReferenceMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ModellingThingReference";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ThingReference";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModelDataAnnotation", "relatedThing");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "referencedRevisionNumber": new PropertyMetadata("referencedRevisionNumber", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "referencedThing": new PropertyMetadata("referencedThing", "Thing", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const modellingThingReference = <Dto.ModellingThingReference>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const modellingThingReference = <Dto.ModellingThingReference>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ModellingThingReference) => any } = {
      "classKind": (dto : Dto.ModellingThingReference) => { return dto.classKind },
      "excludedDomain": (dto : Dto.ModellingThingReference) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ModellingThingReference) => { return dto.excludedPerson },
      "iid": (dto : Dto.ModellingThingReference) => { return dto.iid },
      "modifiedOn": (dto : Dto.ModellingThingReference) => { return dto.modifiedOn },
      "referencedRevisionNumber": (dto : Dto.ModellingThingReference) => { return dto.referencedRevisionNumber },
      "referencedThing": (dto : Dto.ModellingThingReference) => { return dto.referencedThing },
      "revisionNumber": (dto : Dto.ModellingThingReference) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ModellingThingReference>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ModellingThingReference>dtoThing;
      const clone = new Dto.ModellingThingReference(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.referencedRevisionNumber = dto.referencedRevisionNumber;
      clone.referencedThing = dto.referencedThing;

      return clone;
    }
  }

  /**
   * The metadata for ModelLogEntry
   */
  class ModelLogEntryMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ModelLogEntry";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModel", "logEntry");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "affectedItemIid": new PropertyMetadata("affectedItemIid", "string", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "author": new PropertyMetadata("author", "Person", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "level": new PropertyMetadata("level", "LogLevelKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const modelLogEntry = <Dto.ModelLogEntry>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const modelLogEntry = <Dto.ModelLogEntry>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ModelLogEntry) => any } = {
      "affectedItemIid": (dto : Dto.ModelLogEntry) => { return dto.affectedItemIid },
      "author": (dto : Dto.ModelLogEntry) => { return dto.author },
      "category": (dto : Dto.ModelLogEntry) => { return dto.category },
      "classKind": (dto : Dto.ModelLogEntry) => { return dto.classKind },
      "content": (dto : Dto.ModelLogEntry) => { return dto.content },
      "createdOn": (dto : Dto.ModelLogEntry) => { return dto.createdOn },
      "excludedDomain": (dto : Dto.ModelLogEntry) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ModelLogEntry) => { return dto.excludedPerson },
      "iid": (dto : Dto.ModelLogEntry) => { return dto.iid },
      "languageCode": (dto : Dto.ModelLogEntry) => { return dto.languageCode },
      "level": (dto : Dto.ModelLogEntry) => { return dto.level },
      "modifiedOn": (dto : Dto.ModelLogEntry) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.ModelLogEntry) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ModelLogEntry>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ModelLogEntry>dtoThing;
      const clone = new Dto.ModelLogEntry(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.affectedItemIid = (dto.affectedItemIid !== undefined && dto.affectedItemIid !== null) ? dto.affectedItemIid.slice(0) : dto.affectedItemIid;
      clone.author = dto.author;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.createdOn = dto.createdOn;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.level = dto.level;
      clone.modifiedOn = dto.modifiedOn;

      return clone;
    }
  }

  /**
   * The metadata for ModelReferenceDataLibrary
   */
  class ModelReferenceDataLibraryMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ModelReferenceDataLibrary";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ReferenceDataLibrary";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModelSetup", "requiredRdl");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "baseQuantityKind": new PropertyMetadata("baseQuantityKind", "QuantityKind", 0, "*", AggregationKind.None, false, true, false, false, false, true, "1.0.0"),
      "baseUnit": new PropertyMetadata("baseUnit", "MeasurementUnit", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "constant": new PropertyMetadata("constant", "Constant", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "definedCategory": new PropertyMetadata("definedCategory", "Category", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "fileType": new PropertyMetadata("fileType", "FileType", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "glossary": new PropertyMetadata("glossary", "Glossary", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "parameterType": new PropertyMetadata("parameterType", "ParameterType", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "referenceSource": new PropertyMetadata("referenceSource", "ReferenceSource", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "requiredRdl": new PropertyMetadata("requiredRdl", "SiteReferenceDataLibrary", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "rule": new PropertyMetadata("rule", "Rule", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "scale": new PropertyMetadata("scale", "MeasurementScale", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "unit": new PropertyMetadata("unit", "MeasurementUnit", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "unitPrefix": new PropertyMetadata("unitPrefix", "UnitPrefix", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const modelReferenceDataLibrary = <Dto.ModelReferenceDataLibrary>thing;
      return {
        "alias": modelReferenceDataLibrary.alias,
        "constant": modelReferenceDataLibrary.constant,
        "definedCategory": modelReferenceDataLibrary.definedCategory,
        "definition": modelReferenceDataLibrary.definition,
        "fileType": modelReferenceDataLibrary.fileType,
        "glossary": modelReferenceDataLibrary.glossary,
        "hyperLink": modelReferenceDataLibrary.hyperLink,
        "parameterType": modelReferenceDataLibrary.parameterType,
        "referenceSource": modelReferenceDataLibrary.referenceSource,
        "rule": modelReferenceDataLibrary.rule,
        "scale": modelReferenceDataLibrary.scale,
        "unit": modelReferenceDataLibrary.unit,
        "unitPrefix": modelReferenceDataLibrary.unitPrefix,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const modelReferenceDataLibrary = <Dto.ModelReferenceDataLibrary>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ModelReferenceDataLibrary) => any } = {
      "alias": (dto : Dto.ModelReferenceDataLibrary) => { return dto.alias },
      "baseQuantityKind": (dto : Dto.ModelReferenceDataLibrary) => { return dto.baseQuantityKind },
      "baseUnit": (dto : Dto.ModelReferenceDataLibrary) => { return dto.baseUnit },
      "classKind": (dto : Dto.ModelReferenceDataLibrary) => { return dto.classKind },
      "constant": (dto : Dto.ModelReferenceDataLibrary) => { return dto.constant },
      "definedCategory": (dto : Dto.ModelReferenceDataLibrary) => { return dto.definedCategory },
      "definition": (dto : Dto.ModelReferenceDataLibrary) => { return dto.definition },
      "excludedDomain": (dto : Dto.ModelReferenceDataLibrary) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ModelReferenceDataLibrary) => { return dto.excludedPerson },
      "fileType": (dto : Dto.ModelReferenceDataLibrary) => { return dto.fileType },
      "glossary": (dto : Dto.ModelReferenceDataLibrary) => { return dto.glossary },
      "hyperLink": (dto : Dto.ModelReferenceDataLibrary) => { return dto.hyperLink },
      "iid": (dto : Dto.ModelReferenceDataLibrary) => { return dto.iid },
      "modifiedOn": (dto : Dto.ModelReferenceDataLibrary) => { return dto.modifiedOn },
      "name": (dto : Dto.ModelReferenceDataLibrary) => { return dto.name },
      "parameterType": (dto : Dto.ModelReferenceDataLibrary) => { return dto.parameterType },
      "referenceSource": (dto : Dto.ModelReferenceDataLibrary) => { return dto.referenceSource },
      "requiredRdl": (dto : Dto.ModelReferenceDataLibrary) => { return dto.requiredRdl },
      "revisionNumber": (dto : Dto.ModelReferenceDataLibrary) => { return dto.revisionNumber },
      "rule": (dto : Dto.ModelReferenceDataLibrary) => { return dto.rule },
      "scale": (dto : Dto.ModelReferenceDataLibrary) => { return dto.scale },
      "shortName": (dto : Dto.ModelReferenceDataLibrary) => { return dto.shortName },
      "unit": (dto : Dto.ModelReferenceDataLibrary) => { return dto.unit },
      "unitPrefix": (dto : Dto.ModelReferenceDataLibrary) => { return dto.unitPrefix },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ModelReferenceDataLibrary>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ModelReferenceDataLibrary>dtoThing;
      const clone = new Dto.ModelReferenceDataLibrary(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.baseQuantityKind = (dto.baseQuantityKind !== undefined && dto.baseQuantityKind !== null) ? dto.baseQuantityKind.slice(0) : dto.baseQuantityKind;
      clone.baseUnit = (dto.baseUnit !== undefined && dto.baseUnit !== null) ? dto.baseUnit.slice(0) : dto.baseUnit;
      clone.classKind = dto.classKind;
      clone.constant = (dto.constant !== undefined && dto.constant !== null) ? dto.constant.slice(0) : dto.constant;
      clone.definedCategory = (dto.definedCategory !== undefined && dto.definedCategory !== null) ? dto.definedCategory.slice(0) : dto.definedCategory;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.fileType = (dto.fileType !== undefined && dto.fileType !== null) ? dto.fileType.slice(0) : dto.fileType;
      clone.glossary = (dto.glossary !== undefined && dto.glossary !== null) ? dto.glossary.slice(0) : dto.glossary;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.parameterType = (dto.parameterType !== undefined && dto.parameterType !== null) ? dto.parameterType.slice(0) : dto.parameterType;
      clone.referenceSource = (dto.referenceSource !== undefined && dto.referenceSource !== null) ? dto.referenceSource.slice(0) : dto.referenceSource;
      clone.requiredRdl = dto.requiredRdl;
      clone.rule = (dto.rule !== undefined && dto.rule !== null) ? dto.rule.slice(0) : dto.rule;
      clone.scale = (dto.scale !== undefined && dto.scale !== null) ? dto.scale.slice(0) : dto.scale;
      clone.shortName = dto.shortName;
      clone.unit = (dto.unit !== undefined && dto.unit !== null) ? dto.unit.slice(0) : dto.unit;
      clone.unitPrefix = (dto.unitPrefix !== undefined && dto.unitPrefix !== null) ? dto.unitPrefix.slice(0) : dto.unitPrefix;

      return clone;
    }
  }

  /**
   * The metadata for MultiRelationship
   */
  class MultiRelationshipMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "MultiRelationship";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Relationship";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "relationship");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "parameterValue": new PropertyMetadata("parameterValue", "RelationshipParameterValue", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.1.0"),
      "relatedThing": new PropertyMetadata("relatedThing", "Thing", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const multiRelationship = <Dto.MultiRelationship>thing;
      return {
        "parameterValue": multiRelationship.parameterValue,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const multiRelationship = <Dto.MultiRelationship>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.MultiRelationship) => any } = {
      "category": (dto : Dto.MultiRelationship) => { return dto.category },
      "classKind": (dto : Dto.MultiRelationship) => { return dto.classKind },
      "excludedDomain": (dto : Dto.MultiRelationship) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.MultiRelationship) => { return dto.excludedPerson },
      "iid": (dto : Dto.MultiRelationship) => { return dto.iid },
      "modifiedOn": (dto : Dto.MultiRelationship) => { return dto.modifiedOn },
      "owner": (dto : Dto.MultiRelationship) => { return dto.owner },
      "parameterValue": (dto : Dto.MultiRelationship) => { return dto.parameterValue },
      "relatedThing": (dto : Dto.MultiRelationship) => { return dto.relatedThing },
      "revisionNumber": (dto : Dto.MultiRelationship) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.MultiRelationship>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.MultiRelationship>dtoThing;
      const clone = new Dto.MultiRelationship(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;
      clone.parameterValue = (dto.parameterValue !== undefined && dto.parameterValue !== null) ? dto.parameterValue.slice(0) : dto.parameterValue;
      clone.relatedThing = (dto.relatedThing !== undefined && dto.relatedThing !== null) ? dto.relatedThing.slice(0) : dto.relatedThing;

      return clone;
    }
  }

  /**
   * The metadata for MultiRelationshipRule
   */
  class MultiRelationshipRuleMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "MultiRelationshipRule";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Rule";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "rule");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "maxRelated": new PropertyMetadata("maxRelated", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "minRelated": new PropertyMetadata("minRelated", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "relatedCategory": new PropertyMetadata("relatedCategory", "Category", 1, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "relationshipCategory": new PropertyMetadata("relationshipCategory", "Category", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const multiRelationshipRule = <Dto.MultiRelationshipRule>thing;
      return {
        "alias": multiRelationshipRule.alias,
        "definition": multiRelationshipRule.definition,
        "hyperLink": multiRelationshipRule.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const multiRelationshipRule = <Dto.MultiRelationshipRule>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.MultiRelationshipRule) => any } = {
      "alias": (dto : Dto.MultiRelationshipRule) => { return dto.alias },
      "classKind": (dto : Dto.MultiRelationshipRule) => { return dto.classKind },
      "definition": (dto : Dto.MultiRelationshipRule) => { return dto.definition },
      "excludedDomain": (dto : Dto.MultiRelationshipRule) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.MultiRelationshipRule) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.MultiRelationshipRule) => { return dto.hyperLink },
      "iid": (dto : Dto.MultiRelationshipRule) => { return dto.iid },
      "isDeprecated": (dto : Dto.MultiRelationshipRule) => { return dto.isDeprecated },
      "maxRelated": (dto : Dto.MultiRelationshipRule) => { return dto.maxRelated },
      "minRelated": (dto : Dto.MultiRelationshipRule) => { return dto.minRelated },
      "modifiedOn": (dto : Dto.MultiRelationshipRule) => { return dto.modifiedOn },
      "name": (dto : Dto.MultiRelationshipRule) => { return dto.name },
      "relatedCategory": (dto : Dto.MultiRelationshipRule) => { return dto.relatedCategory },
      "relationshipCategory": (dto : Dto.MultiRelationshipRule) => { return dto.relationshipCategory },
      "revisionNumber": (dto : Dto.MultiRelationshipRule) => { return dto.revisionNumber },
      "shortName": (dto : Dto.MultiRelationshipRule) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.MultiRelationshipRule>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.MultiRelationshipRule>dtoThing;
      const clone = new Dto.MultiRelationshipRule(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.maxRelated = dto.maxRelated;
      clone.minRelated = dto.minRelated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.relatedCategory = (dto.relatedCategory !== undefined && dto.relatedCategory !== null) ? dto.relatedCategory.slice(0) : dto.relatedCategory;
      clone.relationshipCategory = dto.relationshipCategory;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for NaturalLanguage
   */
  class NaturalLanguageMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "NaturalLanguage";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("SiteDirectory", "naturalLanguage");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "nativeName": new PropertyMetadata("nativeName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const naturalLanguage = <Dto.NaturalLanguage>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const naturalLanguage = <Dto.NaturalLanguage>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.NaturalLanguage) => any } = {
      "classKind": (dto : Dto.NaturalLanguage) => { return dto.classKind },
      "excludedDomain": (dto : Dto.NaturalLanguage) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.NaturalLanguage) => { return dto.excludedPerson },
      "iid": (dto : Dto.NaturalLanguage) => { return dto.iid },
      "languageCode": (dto : Dto.NaturalLanguage) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.NaturalLanguage) => { return dto.modifiedOn },
      "name": (dto : Dto.NaturalLanguage) => { return dto.name },
      "nativeName": (dto : Dto.NaturalLanguage) => { return dto.nativeName },
      "revisionNumber": (dto : Dto.NaturalLanguage) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.NaturalLanguage>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.NaturalLanguage>dtoThing;
      const clone = new Dto.NaturalLanguage(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.nativeName = dto.nativeName;

      return clone;
    }
  }

  /**
   * The metadata for NestedElement
   */
  class NestedElementMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "NestedElement";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Option", "nestedElement");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "elementUsage": new PropertyMetadata("elementUsage", "ElementUsage", 1, "*", AggregationKind.None, false, true, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isVolatile": new PropertyMetadata("isVolatile", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "nestedParameter": new PropertyMetadata("nestedParameter", "NestedParameter", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "rootElement": new PropertyMetadata("rootElement", "ElementDefinition", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const nestedElement = <Dto.NestedElement>thing;
      return {
        "nestedParameter": nestedElement.nestedParameter,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const nestedElement = <Dto.NestedElement>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.NestedElement) => any } = {
      "classKind": (dto : Dto.NestedElement) => { return dto.classKind },
      "elementUsage": (dto : Dto.NestedElement) => { return dto.elementUsage },
      "excludedDomain": (dto : Dto.NestedElement) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.NestedElement) => { return dto.excludedPerson },
      "iid": (dto : Dto.NestedElement) => { return dto.iid },
      "isVolatile": (dto : Dto.NestedElement) => { return dto.isVolatile },
      "modifiedOn": (dto : Dto.NestedElement) => { return dto.modifiedOn },
      "name": (dto : Dto.NestedElement) => { return dto.name },
      "nestedParameter": (dto : Dto.NestedElement) => { return dto.nestedParameter },
      "owner": (dto : Dto.NestedElement) => { return dto.owner },
      "revisionNumber": (dto : Dto.NestedElement) => { return dto.revisionNumber },
      "rootElement": (dto : Dto.NestedElement) => { return dto.rootElement },
      "shortName": (dto : Dto.NestedElement) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.NestedElement>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.NestedElement>dtoThing;
      const clone = new Dto.NestedElement(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.elementUsage = (dto.elementUsage !== undefined && dto.elementUsage !== null) ? dto.elementUsage.slice(0) : dto.elementUsage;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.isVolatile = dto.isVolatile;
      clone.modifiedOn = dto.modifiedOn;
      clone.nestedParameter = (dto.nestedParameter !== undefined && dto.nestedParameter !== null) ? dto.nestedParameter.slice(0) : dto.nestedParameter;
      clone.rootElement = dto.rootElement;

      return clone;
    }
  }

  /**
   * The metadata for NestedParameter
   */
  class NestedParameterMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "NestedParameter";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("NestedElement", "nestedParameter");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "actualState": new PropertyMetadata("actualState", "ActualFiniteState", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "actualValue": new PropertyMetadata("actualValue", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "associatedParameter": new PropertyMetadata("associatedParameter", "ParameterBase", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "formula": new PropertyMetadata("formula", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isVolatile": new PropertyMetadata("isVolatile", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "path": new PropertyMetadata("path", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const nestedParameter = <Dto.NestedParameter>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const nestedParameter = <Dto.NestedParameter>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.NestedParameter) => any } = {
      "actualState": (dto : Dto.NestedParameter) => { return dto.actualState },
      "actualValue": (dto : Dto.NestedParameter) => { return dto.actualValue },
      "associatedParameter": (dto : Dto.NestedParameter) => { return dto.associatedParameter },
      "classKind": (dto : Dto.NestedParameter) => { return dto.classKind },
      "excludedDomain": (dto : Dto.NestedParameter) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.NestedParameter) => { return dto.excludedPerson },
      "formula": (dto : Dto.NestedParameter) => { return dto.formula },
      "iid": (dto : Dto.NestedParameter) => { return dto.iid },
      "isVolatile": (dto : Dto.NestedParameter) => { return dto.isVolatile },
      "modifiedOn": (dto : Dto.NestedParameter) => { return dto.modifiedOn },
      "owner": (dto : Dto.NestedParameter) => { return dto.owner },
      "path": (dto : Dto.NestedParameter) => { return dto.path },
      "revisionNumber": (dto : Dto.NestedParameter) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.NestedParameter>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.NestedParameter>dtoThing;
      const clone = new Dto.NestedParameter(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.actualState = dto.actualState;
      clone.actualValue = dto.actualValue;
      clone.associatedParameter = dto.associatedParameter;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.formula = dto.formula;
      clone.isVolatile = dto.isVolatile;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;

      return clone;
    }
  }

  /**
   * The metadata for NotExpression
   */
  class NotExpressionMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "NotExpression";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "BooleanExpression";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ParametricConstraint", "expression");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "term": new PropertyMetadata("term", "BooleanExpression", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const notExpression = <Dto.NotExpression>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const notExpression = <Dto.NotExpression>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.NotExpression) => any } = {
      "classKind": (dto : Dto.NotExpression) => { return dto.classKind },
      "excludedDomain": (dto : Dto.NotExpression) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.NotExpression) => { return dto.excludedPerson },
      "iid": (dto : Dto.NotExpression) => { return dto.iid },
      "modifiedOn": (dto : Dto.NotExpression) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.NotExpression) => { return dto.revisionNumber },
      "term": (dto : Dto.NotExpression) => { return dto.term },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.NotExpression>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.NotExpression>dtoThing;
      const clone = new Dto.NotExpression(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.term = dto.term;

      return clone;
    }
  }

  /**
   * The metadata for Option
   */
  class OptionMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Option";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "option");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "nestedElement": new PropertyMetadata("nestedElement", "NestedElement", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const option = <Dto.Option>thing;
      return {
        "alias": option.alias,
        "definition": option.definition,
        "hyperLink": option.hyperLink,
        "nestedElement": option.nestedElement,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const option = <Dto.Option>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Option) => any } = {
      "alias": (dto : Dto.Option) => { return dto.alias },
      "category": (dto : Dto.Option) => { return dto.category },
      "classKind": (dto : Dto.Option) => { return dto.classKind },
      "definition": (dto : Dto.Option) => { return dto.definition },
      "excludedDomain": (dto : Dto.Option) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Option) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.Option) => { return dto.hyperLink },
      "iid": (dto : Dto.Option) => { return dto.iid },
      "modifiedOn": (dto : Dto.Option) => { return dto.modifiedOn },
      "name": (dto : Dto.Option) => { return dto.name },
      "nestedElement": (dto : Dto.Option) => { return dto.nestedElement },
      "revisionNumber": (dto : Dto.Option) => { return dto.revisionNumber },
      "shortName": (dto : Dto.Option) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Option>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Option>dtoThing;
      const clone = new Dto.Option(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.nestedElement = (dto.nestedElement !== undefined && dto.nestedElement !== null) ? dto.nestedElement.slice(0) : dto.nestedElement;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for OrdinalScale
   */
  class OrdinalScaleMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "OrdinalScale";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "MeasurementScale";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "scale");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isMaximumInclusive": new PropertyMetadata("isMaximumInclusive", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isMinimumInclusive": new PropertyMetadata("isMinimumInclusive", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "mappingToReferenceScale": new PropertyMetadata("mappingToReferenceScale", "MappingToReferenceScale", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "maximumPermissibleValue": new PropertyMetadata("maximumPermissibleValue", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "minimumPermissibleValue": new PropertyMetadata("minimumPermissibleValue", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "negativeValueConnotation": new PropertyMetadata("negativeValueConnotation", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "numberSet": new PropertyMetadata("numberSet", "NumberSetKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "positiveValueConnotation": new PropertyMetadata("positiveValueConnotation", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "unit": new PropertyMetadata("unit", "MeasurementUnit", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "useShortNameValues": new PropertyMetadata("useShortNameValues", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "valueDefinition": new PropertyMetadata("valueDefinition", "ScaleValueDefinition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const ordinalScale = <Dto.OrdinalScale>thing;
      return {
        "alias": ordinalScale.alias,
        "definition": ordinalScale.definition,
        "hyperLink": ordinalScale.hyperLink,
        "mappingToReferenceScale": ordinalScale.mappingToReferenceScale,
        "valueDefinition": ordinalScale.valueDefinition,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const ordinalScale = <Dto.OrdinalScale>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.OrdinalScale) => any } = {
      "alias": (dto : Dto.OrdinalScale) => { return dto.alias },
      "classKind": (dto : Dto.OrdinalScale) => { return dto.classKind },
      "definition": (dto : Dto.OrdinalScale) => { return dto.definition },
      "excludedDomain": (dto : Dto.OrdinalScale) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.OrdinalScale) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.OrdinalScale) => { return dto.hyperLink },
      "iid": (dto : Dto.OrdinalScale) => { return dto.iid },
      "isDeprecated": (dto : Dto.OrdinalScale) => { return dto.isDeprecated },
      "isMaximumInclusive": (dto : Dto.OrdinalScale) => { return dto.isMaximumInclusive },
      "isMinimumInclusive": (dto : Dto.OrdinalScale) => { return dto.isMinimumInclusive },
      "mappingToReferenceScale": (dto : Dto.OrdinalScale) => { return dto.mappingToReferenceScale },
      "maximumPermissibleValue": (dto : Dto.OrdinalScale) => { return dto.maximumPermissibleValue },
      "minimumPermissibleValue": (dto : Dto.OrdinalScale) => { return dto.minimumPermissibleValue },
      "modifiedOn": (dto : Dto.OrdinalScale) => { return dto.modifiedOn },
      "name": (dto : Dto.OrdinalScale) => { return dto.name },
      "negativeValueConnotation": (dto : Dto.OrdinalScale) => { return dto.negativeValueConnotation },
      "numberSet": (dto : Dto.OrdinalScale) => { return dto.numberSet },
      "positiveValueConnotation": (dto : Dto.OrdinalScale) => { return dto.positiveValueConnotation },
      "revisionNumber": (dto : Dto.OrdinalScale) => { return dto.revisionNumber },
      "shortName": (dto : Dto.OrdinalScale) => { return dto.shortName },
      "unit": (dto : Dto.OrdinalScale) => { return dto.unit },
      "useShortNameValues": (dto : Dto.OrdinalScale) => { return dto.useShortNameValues },
      "valueDefinition": (dto : Dto.OrdinalScale) => { return dto.valueDefinition },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.OrdinalScale>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.OrdinalScale>dtoThing;
      const clone = new Dto.OrdinalScale(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.isMaximumInclusive = dto.isMaximumInclusive;
      clone.isMinimumInclusive = dto.isMinimumInclusive;
      clone.mappingToReferenceScale = (dto.mappingToReferenceScale !== undefined && dto.mappingToReferenceScale !== null) ? dto.mappingToReferenceScale.slice(0) : dto.mappingToReferenceScale;
      clone.maximumPermissibleValue = dto.maximumPermissibleValue;
      clone.minimumPermissibleValue = dto.minimumPermissibleValue;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.negativeValueConnotation = dto.negativeValueConnotation;
      clone.numberSet = dto.numberSet;
      clone.positiveValueConnotation = dto.positiveValueConnotation;
      clone.shortName = dto.shortName;
      clone.unit = dto.unit;
      clone.useShortNameValues = dto.useShortNameValues;
      clone.valueDefinition = (dto.valueDefinition !== undefined && dto.valueDefinition !== null) ? dto.valueDefinition.slice(0) : dto.valueDefinition;

      return clone;
    }
  }

  /**
   * The metadata for OrExpression
   */
  class OrExpressionMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "OrExpression";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "BooleanExpression";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ParametricConstraint", "expression");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "term": new PropertyMetadata("term", "BooleanExpression", 2, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const orExpression = <Dto.OrExpression>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const orExpression = <Dto.OrExpression>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.OrExpression) => any } = {
      "classKind": (dto : Dto.OrExpression) => { return dto.classKind },
      "excludedDomain": (dto : Dto.OrExpression) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.OrExpression) => { return dto.excludedPerson },
      "iid": (dto : Dto.OrExpression) => { return dto.iid },
      "modifiedOn": (dto : Dto.OrExpression) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.OrExpression) => { return dto.revisionNumber },
      "term": (dto : Dto.OrExpression) => { return dto.term },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.OrExpression>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.OrExpression>dtoThing;
      const clone = new Dto.OrExpression(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.term = (dto.term !== undefined && dto.term !== null) ? dto.term.slice(0) : dto.term;

      return clone;
    }
  }

  /**
   * The metadata for Organization
   */
  class OrganizationMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Organization";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("SiteDirectory", "organization");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const organization = <Dto.Organization>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const organization = <Dto.Organization>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Organization) => any } = {
      "classKind": (dto : Dto.Organization) => { return dto.classKind },
      "excludedDomain": (dto : Dto.Organization) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Organization) => { return dto.excludedPerson },
      "iid": (dto : Dto.Organization) => { return dto.iid },
      "isDeprecated": (dto : Dto.Organization) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.Organization) => { return dto.modifiedOn },
      "name": (dto : Dto.Organization) => { return dto.name },
      "revisionNumber": (dto : Dto.Organization) => { return dto.revisionNumber },
      "shortName": (dto : Dto.Organization) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Organization>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Organization>dtoThing;
      const clone = new Dto.Organization(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for OwnedStyle
   */
  class OwnedStyleMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "OwnedStyle";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DiagrammingStyle";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("DiagramElementThing", "localStyle");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "fillColor": new PropertyMetadata("fillColor", "Color", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "fillOpacity": new PropertyMetadata("fillOpacity", "number", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "fontBold": new PropertyMetadata("fontBold", "boolean", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "fontColor": new PropertyMetadata("fontColor", "Color", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "fontItalic": new PropertyMetadata("fontItalic", "boolean", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "fontName": new PropertyMetadata("fontName", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "fontSize": new PropertyMetadata("fontSize", "number", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "fontStrokeThrough": new PropertyMetadata("fontStrokeThrough", "boolean", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "fontUnderline": new PropertyMetadata("fontUnderline", "boolean", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "strokeColor": new PropertyMetadata("strokeColor", "Color", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "strokeOpacity": new PropertyMetadata("strokeOpacity", "number", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "strokeWidth": new PropertyMetadata("strokeWidth", "number", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "usedColor": new PropertyMetadata("usedColor", "Color", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const ownedStyle = <Dto.OwnedStyle>thing;
      return {
        "usedColor": ownedStyle.usedColor,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const ownedStyle = <Dto.OwnedStyle>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.OwnedStyle) => any } = {
      "classKind": (dto : Dto.OwnedStyle) => { return dto.classKind },
      "excludedDomain": (dto : Dto.OwnedStyle) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.OwnedStyle) => { return dto.excludedPerson },
      "fillColor": (dto : Dto.OwnedStyle) => { return dto.fillColor },
      "fillOpacity": (dto : Dto.OwnedStyle) => { return dto.fillOpacity },
      "fontBold": (dto : Dto.OwnedStyle) => { return dto.fontBold },
      "fontColor": (dto : Dto.OwnedStyle) => { return dto.fontColor },
      "fontItalic": (dto : Dto.OwnedStyle) => { return dto.fontItalic },
      "fontName": (dto : Dto.OwnedStyle) => { return dto.fontName },
      "fontSize": (dto : Dto.OwnedStyle) => { return dto.fontSize },
      "fontStrokeThrough": (dto : Dto.OwnedStyle) => { return dto.fontStrokeThrough },
      "fontUnderline": (dto : Dto.OwnedStyle) => { return dto.fontUnderline },
      "iid": (dto : Dto.OwnedStyle) => { return dto.iid },
      "modifiedOn": (dto : Dto.OwnedStyle) => { return dto.modifiedOn },
      "name": (dto : Dto.OwnedStyle) => { return dto.name },
      "revisionNumber": (dto : Dto.OwnedStyle) => { return dto.revisionNumber },
      "strokeColor": (dto : Dto.OwnedStyle) => { return dto.strokeColor },
      "strokeOpacity": (dto : Dto.OwnedStyle) => { return dto.strokeOpacity },
      "strokeWidth": (dto : Dto.OwnedStyle) => { return dto.strokeWidth },
      "usedColor": (dto : Dto.OwnedStyle) => { return dto.usedColor },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.OwnedStyle>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.OwnedStyle>dtoThing;
      const clone = new Dto.OwnedStyle(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.fillColor = dto.fillColor;
      clone.fillOpacity = dto.fillOpacity;
      clone.fontBold = dto.fontBold;
      clone.fontColor = dto.fontColor;
      clone.fontItalic = dto.fontItalic;
      clone.fontName = dto.fontName;
      clone.fontSize = dto.fontSize;
      clone.fontStrokeThrough = dto.fontStrokeThrough;
      clone.fontUnderline = dto.fontUnderline;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.strokeColor = dto.strokeColor;
      clone.strokeOpacity = dto.strokeOpacity;
      clone.strokeWidth = dto.strokeWidth;
      clone.usedColor = (dto.usedColor !== undefined && dto.usedColor !== null) ? dto.usedColor.slice(0) : dto.usedColor;

      return clone;
    }
  }

  /**
   * The metadata for Page
   */
  class PageMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Page";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Section", "page");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "note": new PropertyMetadata("note", "Note", 0, "*", AggregationKind.Composite, false, true, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const page = <Dto.Page>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const page = <Dto.Page>thing;
      return {
        "note": page.note,
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Page) => any } = {
      "category": (dto : Dto.Page) => { return dto.category },
      "classKind": (dto : Dto.Page) => { return dto.classKind },
      "createdOn": (dto : Dto.Page) => { return dto.createdOn },
      "excludedDomain": (dto : Dto.Page) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Page) => { return dto.excludedPerson },
      "iid": (dto : Dto.Page) => { return dto.iid },
      "modifiedOn": (dto : Dto.Page) => { return dto.modifiedOn },
      "name": (dto : Dto.Page) => { return dto.name },
      "note": (dto : Dto.Page) => { return dto.note },
      "owner": (dto : Dto.Page) => { return dto.owner },
      "revisionNumber": (dto : Dto.Page) => { return dto.revisionNumber },
      "shortName": (dto : Dto.Page) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Page>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Page>dtoThing;
      const clone = new Dto.Page(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.createdOn = dto.createdOn;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.note = (dto.note !== undefined && dto.note !== null) ? dto.note.slice(0) : dto.note;
      clone.owner = dto.owner;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for Parameter
   */
  class ParameterMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Parameter";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ParameterOrOverrideBase";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ElementDefinition", "parameter");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "allowDifferentOwnerOfOverride": new PropertyMetadata("allowDifferentOwnerOfOverride", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "expectsOverride": new PropertyMetadata("expectsOverride", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "group": new PropertyMetadata("group", "ParameterGroup", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isOptionDependent": new PropertyMetadata("isOptionDependent", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "parameterSubscription": new PropertyMetadata("parameterSubscription", "ParameterSubscription", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "parameterType": new PropertyMetadata("parameterType", "ParameterType", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "requestedBy": new PropertyMetadata("requestedBy", "DomainOfExpertise", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "scale": new PropertyMetadata("scale", "MeasurementScale", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "stateDependence": new PropertyMetadata("stateDependence", "ActualFiniteStateList", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "valueSet": new PropertyMetadata("valueSet", "ParameterValueSet", 1, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const parameter = <Dto.Parameter>thing;
      return {
        "parameterSubscription": parameter.parameterSubscription,
        "valueSet": parameter.valueSet,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const parameter = <Dto.Parameter>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Parameter) => any } = {
      "allowDifferentOwnerOfOverride": (dto : Dto.Parameter) => { return dto.allowDifferentOwnerOfOverride },
      "classKind": (dto : Dto.Parameter) => { return dto.classKind },
      "excludedDomain": (dto : Dto.Parameter) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Parameter) => { return dto.excludedPerson },
      "expectsOverride": (dto : Dto.Parameter) => { return dto.expectsOverride },
      "group": (dto : Dto.Parameter) => { return dto.group },
      "iid": (dto : Dto.Parameter) => { return dto.iid },
      "isOptionDependent": (dto : Dto.Parameter) => { return dto.isOptionDependent },
      "modifiedOn": (dto : Dto.Parameter) => { return dto.modifiedOn },
      "owner": (dto : Dto.Parameter) => { return dto.owner },
      "parameterSubscription": (dto : Dto.Parameter) => { return dto.parameterSubscription },
      "parameterType": (dto : Dto.Parameter) => { return dto.parameterType },
      "requestedBy": (dto : Dto.Parameter) => { return dto.requestedBy },
      "revisionNumber": (dto : Dto.Parameter) => { return dto.revisionNumber },
      "scale": (dto : Dto.Parameter) => { return dto.scale },
      "stateDependence": (dto : Dto.Parameter) => { return dto.stateDependence },
      "valueSet": (dto : Dto.Parameter) => { return dto.valueSet },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Parameter>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Parameter>dtoThing;
      const clone = new Dto.Parameter(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.allowDifferentOwnerOfOverride = dto.allowDifferentOwnerOfOverride;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.expectsOverride = dto.expectsOverride;
      clone.group = dto.group;
      clone.isOptionDependent = dto.isOptionDependent;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;
      clone.parameterSubscription = (dto.parameterSubscription !== undefined && dto.parameterSubscription !== null) ? dto.parameterSubscription.slice(0) : dto.parameterSubscription;
      clone.parameterType = dto.parameterType;
      clone.requestedBy = dto.requestedBy;
      clone.scale = dto.scale;
      clone.stateDependence = dto.stateDependence;
      clone.valueSet = (dto.valueSet !== undefined && dto.valueSet !== null) ? dto.valueSet.slice(0) : dto.valueSet;

      return clone;
    }
  }

  /**
   * The metadata for ParameterGroup
   */
  class ParameterGroupMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ParameterGroup";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ElementDefinition", "parameterGroup");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "containingGroup": new PropertyMetadata("containingGroup", "ParameterGroup", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const parameterGroup = <Dto.ParameterGroup>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const parameterGroup = <Dto.ParameterGroup>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ParameterGroup) => any } = {
      "classKind": (dto : Dto.ParameterGroup) => { return dto.classKind },
      "containingGroup": (dto : Dto.ParameterGroup) => { return dto.containingGroup },
      "excludedDomain": (dto : Dto.ParameterGroup) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ParameterGroup) => { return dto.excludedPerson },
      "iid": (dto : Dto.ParameterGroup) => { return dto.iid },
      "modifiedOn": (dto : Dto.ParameterGroup) => { return dto.modifiedOn },
      "name": (dto : Dto.ParameterGroup) => { return dto.name },
      "revisionNumber": (dto : Dto.ParameterGroup) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ParameterGroup>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ParameterGroup>dtoThing;
      const clone = new Dto.ParameterGroup(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.containingGroup = dto.containingGroup;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;

      return clone;
    }
  }

  /**
   * The metadata for ParameterizedCategoryRule
   */
  class ParameterizedCategoryRuleMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ParameterizedCategoryRule";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Rule";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "rule");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "parameterType": new PropertyMetadata("parameterType", "ParameterType", 1, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const parameterizedCategoryRule = <Dto.ParameterizedCategoryRule>thing;
      return {
        "alias": parameterizedCategoryRule.alias,
        "definition": parameterizedCategoryRule.definition,
        "hyperLink": parameterizedCategoryRule.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const parameterizedCategoryRule = <Dto.ParameterizedCategoryRule>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ParameterizedCategoryRule) => any } = {
      "alias": (dto : Dto.ParameterizedCategoryRule) => { return dto.alias },
      "category": (dto : Dto.ParameterizedCategoryRule) => { return dto.category },
      "classKind": (dto : Dto.ParameterizedCategoryRule) => { return dto.classKind },
      "definition": (dto : Dto.ParameterizedCategoryRule) => { return dto.definition },
      "excludedDomain": (dto : Dto.ParameterizedCategoryRule) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ParameterizedCategoryRule) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.ParameterizedCategoryRule) => { return dto.hyperLink },
      "iid": (dto : Dto.ParameterizedCategoryRule) => { return dto.iid },
      "isDeprecated": (dto : Dto.ParameterizedCategoryRule) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.ParameterizedCategoryRule) => { return dto.modifiedOn },
      "name": (dto : Dto.ParameterizedCategoryRule) => { return dto.name },
      "parameterType": (dto : Dto.ParameterizedCategoryRule) => { return dto.parameterType },
      "revisionNumber": (dto : Dto.ParameterizedCategoryRule) => { return dto.revisionNumber },
      "shortName": (dto : Dto.ParameterizedCategoryRule) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ParameterizedCategoryRule>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ParameterizedCategoryRule>dtoThing;
      const clone = new Dto.ParameterizedCategoryRule(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.parameterType = (dto.parameterType !== undefined && dto.parameterType !== null) ? dto.parameterType.slice(0) : dto.parameterType;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for ParameterOverride
   */
  class ParameterOverrideMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ParameterOverride";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ParameterOrOverrideBase";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ElementUsage", "parameterOverride");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "group": new PropertyMetadata("group", "ParameterGroup", 0, "1", AggregationKind.None, false, false, false, true, true, false, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isOptionDependent": new PropertyMetadata("isOptionDependent", "boolean", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "parameter": new PropertyMetadata("parameter", "Parameter", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "parameterSubscription": new PropertyMetadata("parameterSubscription", "ParameterSubscription", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "parameterType": new PropertyMetadata("parameterType", "ParameterType", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "scale": new PropertyMetadata("scale", "MeasurementScale", 0, "1", AggregationKind.None, false, false, false, true, true, false, "1.0.0"),
      "stateDependence": new PropertyMetadata("stateDependence", "ActualFiniteStateList", 0, "1", AggregationKind.None, false, false, false, true, true, false, "1.0.0"),
      "valueSet": new PropertyMetadata("valueSet", "ParameterOverrideValueSet", 1, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const parameterOverride = <Dto.ParameterOverride>thing;
      return {
        "parameterSubscription": parameterOverride.parameterSubscription,
        "valueSet": parameterOverride.valueSet,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const parameterOverride = <Dto.ParameterOverride>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ParameterOverride) => any } = {
      "classKind": (dto : Dto.ParameterOverride) => { return dto.classKind },
      "excludedDomain": (dto : Dto.ParameterOverride) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ParameterOverride) => { return dto.excludedPerson },
      "group": (dto : Dto.ParameterOverride) => { return dto.group },
      "iid": (dto : Dto.ParameterOverride) => { return dto.iid },
      "isOptionDependent": (dto : Dto.ParameterOverride) => { return dto.isOptionDependent },
      "modifiedOn": (dto : Dto.ParameterOverride) => { return dto.modifiedOn },
      "owner": (dto : Dto.ParameterOverride) => { return dto.owner },
      "parameter": (dto : Dto.ParameterOverride) => { return dto.parameter },
      "parameterSubscription": (dto : Dto.ParameterOverride) => { return dto.parameterSubscription },
      "parameterType": (dto : Dto.ParameterOverride) => { return dto.parameterType },
      "revisionNumber": (dto : Dto.ParameterOverride) => { return dto.revisionNumber },
      "scale": (dto : Dto.ParameterOverride) => { return dto.scale },
      "stateDependence": (dto : Dto.ParameterOverride) => { return dto.stateDependence },
      "valueSet": (dto : Dto.ParameterOverride) => { return dto.valueSet },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ParameterOverride>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ParameterOverride>dtoThing;
      const clone = new Dto.ParameterOverride(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;
      clone.parameter = dto.parameter;
      clone.parameterSubscription = (dto.parameterSubscription !== undefined && dto.parameterSubscription !== null) ? dto.parameterSubscription.slice(0) : dto.parameterSubscription;
      clone.valueSet = (dto.valueSet !== undefined && dto.valueSet !== null) ? dto.valueSet.slice(0) : dto.valueSet;

      return clone;
    }
  }

  /**
   * The metadata for ParameterOverrideValueSet
   */
  class ParameterOverrideValueSetMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ParameterOverrideValueSet";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ParameterValueSetBase";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ParameterOverride", "valueSet");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "actualOption": new PropertyMetadata("actualOption", "Option", 0, "1", AggregationKind.None, false, false, false, true, true, false, "1.0.0"),
      "actualState": new PropertyMetadata("actualState", "ActualFiniteState", 0, "1", AggregationKind.None, false, false, false, true, true, false, "1.0.0"),
      "actualValue": new PropertyMetadata("actualValue", "string", 1, "*", AggregationKind.None, false, true, true, true, false, false, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "computed": new PropertyMetadata("computed", "string", 1, "*", AggregationKind.None, false, true, true, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "formula": new PropertyMetadata("formula", "string", 1, "*", AggregationKind.None, false, true, true, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "manual": new PropertyMetadata("manual", "string", 1, "*", AggregationKind.None, false, true, true, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "parameterValueSet": new PropertyMetadata("parameterValueSet", "ParameterValueSet", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "published": new PropertyMetadata("published", "string", 1, "*", AggregationKind.None, false, true, true, false, false, true, "1.0.0"),
      "reference": new PropertyMetadata("reference", "string", 1, "*", AggregationKind.None, false, true, true, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "valueSwitch": new PropertyMetadata("valueSwitch", "ParameterSwitchKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const parameterOverrideValueSet = <Dto.ParameterOverrideValueSet>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const parameterOverrideValueSet = <Dto.ParameterOverrideValueSet>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ParameterOverrideValueSet) => any } = {
      "actualOption": (dto : Dto.ParameterOverrideValueSet) => { return dto.actualOption },
      "actualState": (dto : Dto.ParameterOverrideValueSet) => { return dto.actualState },
      "actualValue": (dto : Dto.ParameterOverrideValueSet) => { return dto.actualValue },
      "classKind": (dto : Dto.ParameterOverrideValueSet) => { return dto.classKind },
      "computed": (dto : Dto.ParameterOverrideValueSet) => { return dto.computed },
      "excludedDomain": (dto : Dto.ParameterOverrideValueSet) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ParameterOverrideValueSet) => { return dto.excludedPerson },
      "formula": (dto : Dto.ParameterOverrideValueSet) => { return dto.formula },
      "iid": (dto : Dto.ParameterOverrideValueSet) => { return dto.iid },
      "manual": (dto : Dto.ParameterOverrideValueSet) => { return dto.manual },
      "modifiedOn": (dto : Dto.ParameterOverrideValueSet) => { return dto.modifiedOn },
      "owner": (dto : Dto.ParameterOverrideValueSet) => { return dto.owner },
      "parameterValueSet": (dto : Dto.ParameterOverrideValueSet) => { return dto.parameterValueSet },
      "published": (dto : Dto.ParameterOverrideValueSet) => { return dto.published },
      "reference": (dto : Dto.ParameterOverrideValueSet) => { return dto.reference },
      "revisionNumber": (dto : Dto.ParameterOverrideValueSet) => { return dto.revisionNumber },
      "valueSwitch": (dto : Dto.ParameterOverrideValueSet) => { return dto.valueSwitch },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ParameterOverrideValueSet>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ParameterOverrideValueSet>dtoThing;
      const clone = new Dto.ParameterOverrideValueSet(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.computed = (dto.computed !== undefined && dto.computed !== null) ? dto.computed.slice(0) : dto.computed;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.formula = (dto.formula !== undefined && dto.formula !== null) ? dto.formula.slice(0) : dto.formula;
      clone.manual = (dto.manual !== undefined && dto.manual !== null) ? dto.manual.slice(0) : dto.manual;
      clone.modifiedOn = dto.modifiedOn;
      clone.parameterValueSet = dto.parameterValueSet;
      clone.published = (dto.published !== undefined && dto.published !== null) ? dto.published.slice(0) : dto.published;
      clone.reference = (dto.reference !== undefined && dto.reference !== null) ? dto.reference.slice(0) : dto.reference;
      clone.valueSwitch = dto.valueSwitch;

      return clone;
    }
  }

  /**
   * The metadata for ParameterSubscription
   */
  class ParameterSubscriptionMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ParameterSubscription";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ParameterBase";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ParameterOrOverrideBase", "parameterSubscription");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "group": new PropertyMetadata("group", "ParameterGroup", 0, "1", AggregationKind.None, false, false, false, true, true, false, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isOptionDependent": new PropertyMetadata("isOptionDependent", "boolean", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "parameterType": new PropertyMetadata("parameterType", "ParameterType", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "scale": new PropertyMetadata("scale", "MeasurementScale", 0, "1", AggregationKind.None, false, false, false, true, true, false, "1.0.0"),
      "stateDependence": new PropertyMetadata("stateDependence", "ActualFiniteStateList", 0, "1", AggregationKind.None, false, false, false, true, true, false, "1.0.0"),
      "valueSet": new PropertyMetadata("valueSet", "ParameterSubscriptionValueSet", 1, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const parameterSubscription = <Dto.ParameterSubscription>thing;
      return {
        "valueSet": parameterSubscription.valueSet,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const parameterSubscription = <Dto.ParameterSubscription>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ParameterSubscription) => any } = {
      "classKind": (dto : Dto.ParameterSubscription) => { return dto.classKind },
      "excludedDomain": (dto : Dto.ParameterSubscription) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ParameterSubscription) => { return dto.excludedPerson },
      "group": (dto : Dto.ParameterSubscription) => { return dto.group },
      "iid": (dto : Dto.ParameterSubscription) => { return dto.iid },
      "isOptionDependent": (dto : Dto.ParameterSubscription) => { return dto.isOptionDependent },
      "modifiedOn": (dto : Dto.ParameterSubscription) => { return dto.modifiedOn },
      "owner": (dto : Dto.ParameterSubscription) => { return dto.owner },
      "parameterType": (dto : Dto.ParameterSubscription) => { return dto.parameterType },
      "revisionNumber": (dto : Dto.ParameterSubscription) => { return dto.revisionNumber },
      "scale": (dto : Dto.ParameterSubscription) => { return dto.scale },
      "stateDependence": (dto : Dto.ParameterSubscription) => { return dto.stateDependence },
      "valueSet": (dto : Dto.ParameterSubscription) => { return dto.valueSet },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ParameterSubscription>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ParameterSubscription>dtoThing;
      const clone = new Dto.ParameterSubscription(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;
      clone.valueSet = (dto.valueSet !== undefined && dto.valueSet !== null) ? dto.valueSet.slice(0) : dto.valueSet;

      return clone;
    }
  }

  /**
   * The metadata for ParameterSubscriptionValueSet
   */
  class ParameterSubscriptionValueSetMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ParameterSubscriptionValueSet";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ParameterSubscription", "valueSet");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "actualOption": new PropertyMetadata("actualOption", "Option", 0, "1", AggregationKind.None, false, false, false, true, true, false, "1.0.0"),
      "actualState": new PropertyMetadata("actualState", "ActualFiniteState", 0, "1", AggregationKind.None, false, false, false, true, true, false, "1.0.0"),
      "actualValue": new PropertyMetadata("actualValue", "string", 1, "*", AggregationKind.None, false, true, true, true, false, false, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "computed": new PropertyMetadata("computed", "string", 1, "*", AggregationKind.None, false, true, true, true, false, false, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "manual": new PropertyMetadata("manual", "string", 1, "*", AggregationKind.None, false, true, true, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "reference": new PropertyMetadata("reference", "string", 1, "*", AggregationKind.None, false, true, true, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "subscribedValueSet": new PropertyMetadata("subscribedValueSet", "ParameterValueSetBase", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "valueSwitch": new PropertyMetadata("valueSwitch", "ParameterSwitchKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const parameterSubscriptionValueSet = <Dto.ParameterSubscriptionValueSet>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const parameterSubscriptionValueSet = <Dto.ParameterSubscriptionValueSet>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ParameterSubscriptionValueSet) => any } = {
      "actualOption": (dto : Dto.ParameterSubscriptionValueSet) => { return dto.actualOption },
      "actualState": (dto : Dto.ParameterSubscriptionValueSet) => { return dto.actualState },
      "actualValue": (dto : Dto.ParameterSubscriptionValueSet) => { return dto.actualValue },
      "classKind": (dto : Dto.ParameterSubscriptionValueSet) => { return dto.classKind },
      "computed": (dto : Dto.ParameterSubscriptionValueSet) => { return dto.computed },
      "excludedDomain": (dto : Dto.ParameterSubscriptionValueSet) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ParameterSubscriptionValueSet) => { return dto.excludedPerson },
      "iid": (dto : Dto.ParameterSubscriptionValueSet) => { return dto.iid },
      "manual": (dto : Dto.ParameterSubscriptionValueSet) => { return dto.manual },
      "modifiedOn": (dto : Dto.ParameterSubscriptionValueSet) => { return dto.modifiedOn },
      "owner": (dto : Dto.ParameterSubscriptionValueSet) => { return dto.owner },
      "reference": (dto : Dto.ParameterSubscriptionValueSet) => { return dto.reference },
      "revisionNumber": (dto : Dto.ParameterSubscriptionValueSet) => { return dto.revisionNumber },
      "subscribedValueSet": (dto : Dto.ParameterSubscriptionValueSet) => { return dto.subscribedValueSet },
      "valueSwitch": (dto : Dto.ParameterSubscriptionValueSet) => { return dto.valueSwitch },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ParameterSubscriptionValueSet>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ParameterSubscriptionValueSet>dtoThing;
      const clone = new Dto.ParameterSubscriptionValueSet(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.manual = (dto.manual !== undefined && dto.manual !== null) ? dto.manual.slice(0) : dto.manual;
      clone.modifiedOn = dto.modifiedOn;
      clone.subscribedValueSet = dto.subscribedValueSet;
      clone.valueSwitch = dto.valueSwitch;

      return clone;
    }
  }

  /**
   * The metadata for ParameterTypeComponent
   */
  class ParameterTypeComponentMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ParameterTypeComponent";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("CompoundParameterType", "component");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "parameterType": new PropertyMetadata("parameterType", "ParameterType", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "scale": new PropertyMetadata("scale", "MeasurementScale", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const parameterTypeComponent = <Dto.ParameterTypeComponent>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const parameterTypeComponent = <Dto.ParameterTypeComponent>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ParameterTypeComponent) => any } = {
      "classKind": (dto : Dto.ParameterTypeComponent) => { return dto.classKind },
      "excludedDomain": (dto : Dto.ParameterTypeComponent) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ParameterTypeComponent) => { return dto.excludedPerson },
      "iid": (dto : Dto.ParameterTypeComponent) => { return dto.iid },
      "modifiedOn": (dto : Dto.ParameterTypeComponent) => { return dto.modifiedOn },
      "parameterType": (dto : Dto.ParameterTypeComponent) => { return dto.parameterType },
      "revisionNumber": (dto : Dto.ParameterTypeComponent) => { return dto.revisionNumber },
      "scale": (dto : Dto.ParameterTypeComponent) => { return dto.scale },
      "shortName": (dto : Dto.ParameterTypeComponent) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ParameterTypeComponent>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ParameterTypeComponent>dtoThing;
      const clone = new Dto.ParameterTypeComponent(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.parameterType = dto.parameterType;
      clone.scale = dto.scale;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for ParameterValueSet
   */
  class ParameterValueSetMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ParameterValueSet";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ParameterValueSetBase";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Parameter", "valueSet");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "actualOption": new PropertyMetadata("actualOption", "Option", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "actualState": new PropertyMetadata("actualState", "ActualFiniteState", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "actualValue": new PropertyMetadata("actualValue", "string", 1, "*", AggregationKind.None, false, true, true, true, false, false, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "computed": new PropertyMetadata("computed", "string", 1, "*", AggregationKind.None, false, true, true, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "formula": new PropertyMetadata("formula", "string", 1, "*", AggregationKind.None, false, true, true, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "manual": new PropertyMetadata("manual", "string", 1, "*", AggregationKind.None, false, true, true, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "published": new PropertyMetadata("published", "string", 1, "*", AggregationKind.None, false, true, true, false, false, true, "1.0.0"),
      "reference": new PropertyMetadata("reference", "string", 1, "*", AggregationKind.None, false, true, true, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "valueSwitch": new PropertyMetadata("valueSwitch", "ParameterSwitchKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const parameterValueSet = <Dto.ParameterValueSet>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const parameterValueSet = <Dto.ParameterValueSet>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ParameterValueSet) => any } = {
      "actualOption": (dto : Dto.ParameterValueSet) => { return dto.actualOption },
      "actualState": (dto : Dto.ParameterValueSet) => { return dto.actualState },
      "actualValue": (dto : Dto.ParameterValueSet) => { return dto.actualValue },
      "classKind": (dto : Dto.ParameterValueSet) => { return dto.classKind },
      "computed": (dto : Dto.ParameterValueSet) => { return dto.computed },
      "excludedDomain": (dto : Dto.ParameterValueSet) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ParameterValueSet) => { return dto.excludedPerson },
      "formula": (dto : Dto.ParameterValueSet) => { return dto.formula },
      "iid": (dto : Dto.ParameterValueSet) => { return dto.iid },
      "manual": (dto : Dto.ParameterValueSet) => { return dto.manual },
      "modifiedOn": (dto : Dto.ParameterValueSet) => { return dto.modifiedOn },
      "owner": (dto : Dto.ParameterValueSet) => { return dto.owner },
      "published": (dto : Dto.ParameterValueSet) => { return dto.published },
      "reference": (dto : Dto.ParameterValueSet) => { return dto.reference },
      "revisionNumber": (dto : Dto.ParameterValueSet) => { return dto.revisionNumber },
      "valueSwitch": (dto : Dto.ParameterValueSet) => { return dto.valueSwitch },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ParameterValueSet>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ParameterValueSet>dtoThing;
      const clone = new Dto.ParameterValueSet(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.actualOption = dto.actualOption;
      clone.actualState = dto.actualState;
      clone.classKind = dto.classKind;
      clone.computed = (dto.computed !== undefined && dto.computed !== null) ? dto.computed.slice(0) : dto.computed;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.formula = (dto.formula !== undefined && dto.formula !== null) ? dto.formula.slice(0) : dto.formula;
      clone.manual = (dto.manual !== undefined && dto.manual !== null) ? dto.manual.slice(0) : dto.manual;
      clone.modifiedOn = dto.modifiedOn;
      clone.published = (dto.published !== undefined && dto.published !== null) ? dto.published.slice(0) : dto.published;
      clone.reference = (dto.reference !== undefined && dto.reference !== null) ? dto.reference.slice(0) : dto.reference;
      clone.valueSwitch = dto.valueSwitch;

      return clone;
    }
  }

  /**
   * The metadata for ParametricConstraint
   */
  class ParametricConstraintMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ParametricConstraint";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Requirement", "parametricConstraint");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "expression": new PropertyMetadata("expression", "BooleanExpression", 1, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "topExpression": new PropertyMetadata("topExpression", "BooleanExpression", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const parametricConstraint = <Dto.ParametricConstraint>thing;
      return {
        "expression": parametricConstraint.expression,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const parametricConstraint = <Dto.ParametricConstraint>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ParametricConstraint) => any } = {
      "classKind": (dto : Dto.ParametricConstraint) => { return dto.classKind },
      "excludedDomain": (dto : Dto.ParametricConstraint) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ParametricConstraint) => { return dto.excludedPerson },
      "expression": (dto : Dto.ParametricConstraint) => { return dto.expression },
      "iid": (dto : Dto.ParametricConstraint) => { return dto.iid },
      "modifiedOn": (dto : Dto.ParametricConstraint) => { return dto.modifiedOn },
      "owner": (dto : Dto.ParametricConstraint) => { return dto.owner },
      "revisionNumber": (dto : Dto.ParametricConstraint) => { return dto.revisionNumber },
      "topExpression": (dto : Dto.ParametricConstraint) => { return dto.topExpression },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ParametricConstraint>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ParametricConstraint>dtoThing;
      const clone = new Dto.ParametricConstraint(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.expression = (dto.expression !== undefined && dto.expression !== null) ? dto.expression.slice(0) : dto.expression;
      clone.modifiedOn = dto.modifiedOn;
      clone.topExpression = dto.topExpression;

      return clone;
    }
  }

  /**
   * The metadata for Participant
   */
  class ParticipantMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Participant";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModelSetup", "participant");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "domain": new PropertyMetadata("domain", "DomainOfExpertise", 1, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isActive": new PropertyMetadata("isActive", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "person": new PropertyMetadata("person", "Person", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "role": new PropertyMetadata("role", "ParticipantRole", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "selectedDomain": new PropertyMetadata("selectedDomain", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const participant = <Dto.Participant>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const participant = <Dto.Participant>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Participant) => any } = {
      "classKind": (dto : Dto.Participant) => { return dto.classKind },
      "domain": (dto : Dto.Participant) => { return dto.domain },
      "excludedDomain": (dto : Dto.Participant) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Participant) => { return dto.excludedPerson },
      "iid": (dto : Dto.Participant) => { return dto.iid },
      "isActive": (dto : Dto.Participant) => { return dto.isActive },
      "modifiedOn": (dto : Dto.Participant) => { return dto.modifiedOn },
      "person": (dto : Dto.Participant) => { return dto.person },
      "revisionNumber": (dto : Dto.Participant) => { return dto.revisionNumber },
      "role": (dto : Dto.Participant) => { return dto.role },
      "selectedDomain": (dto : Dto.Participant) => { return dto.selectedDomain },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Participant>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Participant>dtoThing;
      const clone = new Dto.Participant(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.domain = (dto.domain !== undefined && dto.domain !== null) ? dto.domain.slice(0) : dto.domain;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.isActive = dto.isActive;
      clone.modifiedOn = dto.modifiedOn;
      clone.person = dto.person;
      clone.role = dto.role;
      clone.selectedDomain = dto.selectedDomain;

      return clone;
    }
  }

  /**
   * The metadata for ParticipantPermission
   */
  class ParticipantPermissionMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ParticipantPermission";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ParticipantRole", "participantPermission");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "accessRight": new PropertyMetadata("accessRight", "ParticipantAccessRightKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "objectClass": new PropertyMetadata("objectClass", "ClassKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const participantPermission = <Dto.ParticipantPermission>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const participantPermission = <Dto.ParticipantPermission>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ParticipantPermission) => any } = {
      "accessRight": (dto : Dto.ParticipantPermission) => { return dto.accessRight },
      "classKind": (dto : Dto.ParticipantPermission) => { return dto.classKind },
      "excludedDomain": (dto : Dto.ParticipantPermission) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ParticipantPermission) => { return dto.excludedPerson },
      "iid": (dto : Dto.ParticipantPermission) => { return dto.iid },
      "isDeprecated": (dto : Dto.ParticipantPermission) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.ParticipantPermission) => { return dto.modifiedOn },
      "objectClass": (dto : Dto.ParticipantPermission) => { return dto.objectClass },
      "revisionNumber": (dto : Dto.ParticipantPermission) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ParticipantPermission>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ParticipantPermission>dtoThing;
      const clone = new Dto.ParticipantPermission(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.accessRight = dto.accessRight;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.objectClass = dto.objectClass;

      return clone;
    }
  }

  /**
   * The metadata for ParticipantRole
   */
  class ParticipantRoleMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ParticipantRole";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("SiteDirectory", "participantRole");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "participantPermission": new PropertyMetadata("participantPermission", "ParticipantPermission", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const participantRole = <Dto.ParticipantRole>thing;
      return {
        "alias": participantRole.alias,
        "definition": participantRole.definition,
        "hyperLink": participantRole.hyperLink,
        "participantPermission": participantRole.participantPermission,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const participantRole = <Dto.ParticipantRole>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ParticipantRole) => any } = {
      "alias": (dto : Dto.ParticipantRole) => { return dto.alias },
      "classKind": (dto : Dto.ParticipantRole) => { return dto.classKind },
      "definition": (dto : Dto.ParticipantRole) => { return dto.definition },
      "excludedDomain": (dto : Dto.ParticipantRole) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ParticipantRole) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.ParticipantRole) => { return dto.hyperLink },
      "iid": (dto : Dto.ParticipantRole) => { return dto.iid },
      "isDeprecated": (dto : Dto.ParticipantRole) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.ParticipantRole) => { return dto.modifiedOn },
      "name": (dto : Dto.ParticipantRole) => { return dto.name },
      "participantPermission": (dto : Dto.ParticipantRole) => { return dto.participantPermission },
      "revisionNumber": (dto : Dto.ParticipantRole) => { return dto.revisionNumber },
      "shortName": (dto : Dto.ParticipantRole) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ParticipantRole>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ParticipantRole>dtoThing;
      const clone = new Dto.ParticipantRole(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.participantPermission = (dto.participantPermission !== undefined && dto.participantPermission !== null) ? dto.participantPermission.slice(0) : dto.participantPermission;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for Person
   */
  class PersonMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Person";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("SiteDirectory", "person");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "defaultDomain": new PropertyMetadata("defaultDomain", "DomainOfExpertise", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "defaultEmailAddress": new PropertyMetadata("defaultEmailAddress", "EmailAddress", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "defaultTelephoneNumber": new PropertyMetadata("defaultTelephoneNumber", "TelephoneNumber", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "emailAddress": new PropertyMetadata("emailAddress", "EmailAddress", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "givenName": new PropertyMetadata("givenName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isActive": new PropertyMetadata("isActive", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "organization": new PropertyMetadata("organization", "Organization", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "organizationalUnit": new PropertyMetadata("organizationalUnit", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "password": new PropertyMetadata("password", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "role": new PropertyMetadata("role", "PersonRole", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "surname": new PropertyMetadata("surname", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "telephoneNumber": new PropertyMetadata("telephoneNumber", "TelephoneNumber", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "userPreference": new PropertyMetadata("userPreference", "UserPreference", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const person = <Dto.Person>thing;
      return {
        "emailAddress": person.emailAddress,
        "telephoneNumber": person.telephoneNumber,
        "userPreference": person.userPreference,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const person = <Dto.Person>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Person) => any } = {
      "classKind": (dto : Dto.Person) => { return dto.classKind },
      "defaultDomain": (dto : Dto.Person) => { return dto.defaultDomain },
      "defaultEmailAddress": (dto : Dto.Person) => { return dto.defaultEmailAddress },
      "defaultTelephoneNumber": (dto : Dto.Person) => { return dto.defaultTelephoneNumber },
      "emailAddress": (dto : Dto.Person) => { return dto.emailAddress },
      "excludedDomain": (dto : Dto.Person) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Person) => { return dto.excludedPerson },
      "givenName": (dto : Dto.Person) => { return dto.givenName },
      "iid": (dto : Dto.Person) => { return dto.iid },
      "isActive": (dto : Dto.Person) => { return dto.isActive },
      "isDeprecated": (dto : Dto.Person) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.Person) => { return dto.modifiedOn },
      "name": (dto : Dto.Person) => { return dto.name },
      "organization": (dto : Dto.Person) => { return dto.organization },
      "organizationalUnit": (dto : Dto.Person) => { return dto.organizationalUnit },
      "password": (dto : Dto.Person) => { return dto.password },
      "revisionNumber": (dto : Dto.Person) => { return dto.revisionNumber },
      "role": (dto : Dto.Person) => { return dto.role },
      "shortName": (dto : Dto.Person) => { return dto.shortName },
      "surname": (dto : Dto.Person) => { return dto.surname },
      "telephoneNumber": (dto : Dto.Person) => { return dto.telephoneNumber },
      "userPreference": (dto : Dto.Person) => { return dto.userPreference },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Person>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Person>dtoThing;
      const clone = new Dto.Person(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.defaultDomain = dto.defaultDomain;
      clone.defaultEmailAddress = dto.defaultEmailAddress;
      clone.defaultTelephoneNumber = dto.defaultTelephoneNumber;
      clone.emailAddress = (dto.emailAddress !== undefined && dto.emailAddress !== null) ? dto.emailAddress.slice(0) : dto.emailAddress;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.givenName = dto.givenName;
      clone.isActive = dto.isActive;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.organization = dto.organization;
      clone.organizationalUnit = dto.organizationalUnit;
      clone.password = dto.password;
      clone.role = dto.role;
      clone.shortName = dto.shortName;
      clone.surname = dto.surname;
      clone.telephoneNumber = (dto.telephoneNumber !== undefined && dto.telephoneNumber !== null) ? dto.telephoneNumber.slice(0) : dto.telephoneNumber;
      clone.userPreference = (dto.userPreference !== undefined && dto.userPreference !== null) ? dto.userPreference.slice(0) : dto.userPreference;

      return clone;
    }
  }

  /**
   * The metadata for PersonPermission
   */
  class PersonPermissionMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "PersonPermission";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("PersonRole", "personPermission");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "accessRight": new PropertyMetadata("accessRight", "PersonAccessRightKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "objectClass": new PropertyMetadata("objectClass", "ClassKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const personPermission = <Dto.PersonPermission>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const personPermission = <Dto.PersonPermission>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.PersonPermission) => any } = {
      "accessRight": (dto : Dto.PersonPermission) => { return dto.accessRight },
      "classKind": (dto : Dto.PersonPermission) => { return dto.classKind },
      "excludedDomain": (dto : Dto.PersonPermission) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.PersonPermission) => { return dto.excludedPerson },
      "iid": (dto : Dto.PersonPermission) => { return dto.iid },
      "isDeprecated": (dto : Dto.PersonPermission) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.PersonPermission) => { return dto.modifiedOn },
      "objectClass": (dto : Dto.PersonPermission) => { return dto.objectClass },
      "revisionNumber": (dto : Dto.PersonPermission) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.PersonPermission>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.PersonPermission>dtoThing;
      const clone = new Dto.PersonPermission(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.accessRight = dto.accessRight;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.objectClass = dto.objectClass;

      return clone;
    }
  }

  /**
   * The metadata for PersonRole
   */
  class PersonRoleMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "PersonRole";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("SiteDirectory", "personRole");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "personPermission": new PropertyMetadata("personPermission", "PersonPermission", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const personRole = <Dto.PersonRole>thing;
      return {
        "alias": personRole.alias,
        "definition": personRole.definition,
        "hyperLink": personRole.hyperLink,
        "personPermission": personRole.personPermission,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const personRole = <Dto.PersonRole>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.PersonRole) => any } = {
      "alias": (dto : Dto.PersonRole) => { return dto.alias },
      "classKind": (dto : Dto.PersonRole) => { return dto.classKind },
      "definition": (dto : Dto.PersonRole) => { return dto.definition },
      "excludedDomain": (dto : Dto.PersonRole) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.PersonRole) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.PersonRole) => { return dto.hyperLink },
      "iid": (dto : Dto.PersonRole) => { return dto.iid },
      "isDeprecated": (dto : Dto.PersonRole) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.PersonRole) => { return dto.modifiedOn },
      "name": (dto : Dto.PersonRole) => { return dto.name },
      "personPermission": (dto : Dto.PersonRole) => { return dto.personPermission },
      "revisionNumber": (dto : Dto.PersonRole) => { return dto.revisionNumber },
      "shortName": (dto : Dto.PersonRole) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.PersonRole>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.PersonRole>dtoThing;
      const clone = new Dto.PersonRole(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.personPermission = (dto.personPermission !== undefined && dto.personPermission !== null) ? dto.personPermission.slice(0) : dto.personPermission;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for Point
   */
  class PointMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Point";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DiagramThingBase";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("DiagramEdge", "point");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "x": new PropertyMetadata("x", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "y": new PropertyMetadata("y", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const point = <Dto.Point>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const point = <Dto.Point>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Point) => any } = {
      "classKind": (dto : Dto.Point) => { return dto.classKind },
      "excludedDomain": (dto : Dto.Point) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Point) => { return dto.excludedPerson },
      "iid": (dto : Dto.Point) => { return dto.iid },
      "modifiedOn": (dto : Dto.Point) => { return dto.modifiedOn },
      "name": (dto : Dto.Point) => { return dto.name },
      "revisionNumber": (dto : Dto.Point) => { return dto.revisionNumber },
      "x": (dto : Dto.Point) => { return dto.x },
      "y": (dto : Dto.Point) => { return dto.y },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Point>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Point>dtoThing;
      const clone = new Dto.Point(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.x = dto.x;
      clone.y = dto.y;

      return clone;
    }
  }

  /**
   * The metadata for PossibleFiniteState
   */
  class PossibleFiniteStateMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "PossibleFiniteState";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("PossibleFiniteStateList", "possibleState");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const possibleFiniteState = <Dto.PossibleFiniteState>thing;
      return {
        "alias": possibleFiniteState.alias,
        "definition": possibleFiniteState.definition,
        "hyperLink": possibleFiniteState.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const possibleFiniteState = <Dto.PossibleFiniteState>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.PossibleFiniteState) => any } = {
      "alias": (dto : Dto.PossibleFiniteState) => { return dto.alias },
      "classKind": (dto : Dto.PossibleFiniteState) => { return dto.classKind },
      "definition": (dto : Dto.PossibleFiniteState) => { return dto.definition },
      "excludedDomain": (dto : Dto.PossibleFiniteState) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.PossibleFiniteState) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.PossibleFiniteState) => { return dto.hyperLink },
      "iid": (dto : Dto.PossibleFiniteState) => { return dto.iid },
      "modifiedOn": (dto : Dto.PossibleFiniteState) => { return dto.modifiedOn },
      "name": (dto : Dto.PossibleFiniteState) => { return dto.name },
      "owner": (dto : Dto.PossibleFiniteState) => { return dto.owner },
      "revisionNumber": (dto : Dto.PossibleFiniteState) => { return dto.revisionNumber },
      "shortName": (dto : Dto.PossibleFiniteState) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.PossibleFiniteState>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.PossibleFiniteState>dtoThing;
      const clone = new Dto.PossibleFiniteState(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for PossibleFiniteStateList
   */
  class PossibleFiniteStateListMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "PossibleFiniteStateList";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "possibleFiniteStateList");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "defaultState": new PropertyMetadata("defaultState", "PossibleFiniteState", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "possibleState": new PropertyMetadata("possibleState", "PossibleFiniteState", 1, "*", AggregationKind.Composite, false, true, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const possibleFiniteStateList = <Dto.PossibleFiniteStateList>thing;
      return {
        "alias": possibleFiniteStateList.alias,
        "definition": possibleFiniteStateList.definition,
        "hyperLink": possibleFiniteStateList.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const possibleFiniteStateList = <Dto.PossibleFiniteStateList>thing;
      return {
        "possibleState": possibleFiniteStateList.possibleState,
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.PossibleFiniteStateList) => any } = {
      "alias": (dto : Dto.PossibleFiniteStateList) => { return dto.alias },
      "category": (dto : Dto.PossibleFiniteStateList) => { return dto.category },
      "classKind": (dto : Dto.PossibleFiniteStateList) => { return dto.classKind },
      "defaultState": (dto : Dto.PossibleFiniteStateList) => { return dto.defaultState },
      "definition": (dto : Dto.PossibleFiniteStateList) => { return dto.definition },
      "excludedDomain": (dto : Dto.PossibleFiniteStateList) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.PossibleFiniteStateList) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.PossibleFiniteStateList) => { return dto.hyperLink },
      "iid": (dto : Dto.PossibleFiniteStateList) => { return dto.iid },
      "modifiedOn": (dto : Dto.PossibleFiniteStateList) => { return dto.modifiedOn },
      "name": (dto : Dto.PossibleFiniteStateList) => { return dto.name },
      "owner": (dto : Dto.PossibleFiniteStateList) => { return dto.owner },
      "possibleState": (dto : Dto.PossibleFiniteStateList) => { return dto.possibleState },
      "revisionNumber": (dto : Dto.PossibleFiniteStateList) => { return dto.revisionNumber },
      "shortName": (dto : Dto.PossibleFiniteStateList) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.PossibleFiniteStateList>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.PossibleFiniteStateList>dtoThing;
      const clone = new Dto.PossibleFiniteStateList(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.defaultState = dto.defaultState;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.owner = dto.owner;
      clone.possibleState = (dto.possibleState !== undefined && dto.possibleState !== null) ? dto.possibleState.slice(0) : dto.possibleState;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for PrefixedUnit
   */
  class PrefixedUnitMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "PrefixedUnit";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ConversionBasedUnit";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "unit");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "conversionFactor": new PropertyMetadata("conversionFactor", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "prefix": new PropertyMetadata("prefix", "UnitPrefix", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "referenceUnit": new PropertyMetadata("referenceUnit", "MeasurementUnit", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const prefixedUnit = <Dto.PrefixedUnit>thing;
      return {
        "alias": prefixedUnit.alias,
        "definition": prefixedUnit.definition,
        "hyperLink": prefixedUnit.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const prefixedUnit = <Dto.PrefixedUnit>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.PrefixedUnit) => any } = {
      "alias": (dto : Dto.PrefixedUnit) => { return dto.alias },
      "classKind": (dto : Dto.PrefixedUnit) => { return dto.classKind },
      "conversionFactor": (dto : Dto.PrefixedUnit) => { return dto.conversionFactor },
      "definition": (dto : Dto.PrefixedUnit) => { return dto.definition },
      "excludedDomain": (dto : Dto.PrefixedUnit) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.PrefixedUnit) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.PrefixedUnit) => { return dto.hyperLink },
      "iid": (dto : Dto.PrefixedUnit) => { return dto.iid },
      "isDeprecated": (dto : Dto.PrefixedUnit) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.PrefixedUnit) => { return dto.modifiedOn },
      "name": (dto : Dto.PrefixedUnit) => { return dto.name },
      "prefix": (dto : Dto.PrefixedUnit) => { return dto.prefix },
      "referenceUnit": (dto : Dto.PrefixedUnit) => { return dto.referenceUnit },
      "revisionNumber": (dto : Dto.PrefixedUnit) => { return dto.revisionNumber },
      "shortName": (dto : Dto.PrefixedUnit) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.PrefixedUnit>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.PrefixedUnit>dtoThing;
      const clone = new Dto.PrefixedUnit(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.prefix = dto.prefix;
      clone.referenceUnit = dto.referenceUnit;

      return clone;
    }
  }

  /**
   * The metadata for Publication
   */
  class PublicationMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Publication";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "publication");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "domain": new PropertyMetadata("domain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "publishedParameter": new PropertyMetadata("publishedParameter", "ParameterOrOverrideBase", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const publication = <Dto.Publication>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const publication = <Dto.Publication>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Publication) => any } = {
      "classKind": (dto : Dto.Publication) => { return dto.classKind },
      "createdOn": (dto : Dto.Publication) => { return dto.createdOn },
      "domain": (dto : Dto.Publication) => { return dto.domain },
      "excludedDomain": (dto : Dto.Publication) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Publication) => { return dto.excludedPerson },
      "iid": (dto : Dto.Publication) => { return dto.iid },
      "modifiedOn": (dto : Dto.Publication) => { return dto.modifiedOn },
      "publishedParameter": (dto : Dto.Publication) => { return dto.publishedParameter },
      "revisionNumber": (dto : Dto.Publication) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Publication>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Publication>dtoThing;
      const clone = new Dto.Publication(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.createdOn = dto.createdOn;
      clone.domain = (dto.domain !== undefined && dto.domain !== null) ? dto.domain.slice(0) : dto.domain;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.publishedParameter = (dto.publishedParameter !== undefined && dto.publishedParameter !== null) ? dto.publishedParameter.slice(0) : dto.publishedParameter;

      return clone;
    }
  }

  /**
   * The metadata for QuantityKindFactor
   */
  class QuantityKindFactorMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "QuantityKindFactor";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("DerivedQuantityKind", "quantityKindFactor");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "exponent": new PropertyMetadata("exponent", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "quantityKind": new PropertyMetadata("quantityKind", "QuantityKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const quantityKindFactor = <Dto.QuantityKindFactor>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const quantityKindFactor = <Dto.QuantityKindFactor>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.QuantityKindFactor) => any } = {
      "classKind": (dto : Dto.QuantityKindFactor) => { return dto.classKind },
      "excludedDomain": (dto : Dto.QuantityKindFactor) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.QuantityKindFactor) => { return dto.excludedPerson },
      "exponent": (dto : Dto.QuantityKindFactor) => { return dto.exponent },
      "iid": (dto : Dto.QuantityKindFactor) => { return dto.iid },
      "modifiedOn": (dto : Dto.QuantityKindFactor) => { return dto.modifiedOn },
      "quantityKind": (dto : Dto.QuantityKindFactor) => { return dto.quantityKind },
      "revisionNumber": (dto : Dto.QuantityKindFactor) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.QuantityKindFactor>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.QuantityKindFactor>dtoThing;
      const clone = new Dto.QuantityKindFactor(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.exponent = dto.exponent;
      clone.modifiedOn = dto.modifiedOn;
      clone.quantityKind = dto.quantityKind;

      return clone;
    }
  }

  /**
   * The metadata for RatioScale
   */
  class RatioScaleMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "RatioScale";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "MeasurementScale";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "scale");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isMaximumInclusive": new PropertyMetadata("isMaximumInclusive", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isMinimumInclusive": new PropertyMetadata("isMinimumInclusive", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "mappingToReferenceScale": new PropertyMetadata("mappingToReferenceScale", "MappingToReferenceScale", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "maximumPermissibleValue": new PropertyMetadata("maximumPermissibleValue", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "minimumPermissibleValue": new PropertyMetadata("minimumPermissibleValue", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "negativeValueConnotation": new PropertyMetadata("negativeValueConnotation", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "numberSet": new PropertyMetadata("numberSet", "NumberSetKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "positiveValueConnotation": new PropertyMetadata("positiveValueConnotation", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "unit": new PropertyMetadata("unit", "MeasurementUnit", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "valueDefinition": new PropertyMetadata("valueDefinition", "ScaleValueDefinition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const ratioScale = <Dto.RatioScale>thing;
      return {
        "alias": ratioScale.alias,
        "definition": ratioScale.definition,
        "hyperLink": ratioScale.hyperLink,
        "mappingToReferenceScale": ratioScale.mappingToReferenceScale,
        "valueDefinition": ratioScale.valueDefinition,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const ratioScale = <Dto.RatioScale>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.RatioScale) => any } = {
      "alias": (dto : Dto.RatioScale) => { return dto.alias },
      "classKind": (dto : Dto.RatioScale) => { return dto.classKind },
      "definition": (dto : Dto.RatioScale) => { return dto.definition },
      "excludedDomain": (dto : Dto.RatioScale) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.RatioScale) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.RatioScale) => { return dto.hyperLink },
      "iid": (dto : Dto.RatioScale) => { return dto.iid },
      "isDeprecated": (dto : Dto.RatioScale) => { return dto.isDeprecated },
      "isMaximumInclusive": (dto : Dto.RatioScale) => { return dto.isMaximumInclusive },
      "isMinimumInclusive": (dto : Dto.RatioScale) => { return dto.isMinimumInclusive },
      "mappingToReferenceScale": (dto : Dto.RatioScale) => { return dto.mappingToReferenceScale },
      "maximumPermissibleValue": (dto : Dto.RatioScale) => { return dto.maximumPermissibleValue },
      "minimumPermissibleValue": (dto : Dto.RatioScale) => { return dto.minimumPermissibleValue },
      "modifiedOn": (dto : Dto.RatioScale) => { return dto.modifiedOn },
      "name": (dto : Dto.RatioScale) => { return dto.name },
      "negativeValueConnotation": (dto : Dto.RatioScale) => { return dto.negativeValueConnotation },
      "numberSet": (dto : Dto.RatioScale) => { return dto.numberSet },
      "positiveValueConnotation": (dto : Dto.RatioScale) => { return dto.positiveValueConnotation },
      "revisionNumber": (dto : Dto.RatioScale) => { return dto.revisionNumber },
      "shortName": (dto : Dto.RatioScale) => { return dto.shortName },
      "unit": (dto : Dto.RatioScale) => { return dto.unit },
      "valueDefinition": (dto : Dto.RatioScale) => { return dto.valueDefinition },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.RatioScale>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.RatioScale>dtoThing;
      const clone = new Dto.RatioScale(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.isMaximumInclusive = dto.isMaximumInclusive;
      clone.isMinimumInclusive = dto.isMinimumInclusive;
      clone.mappingToReferenceScale = (dto.mappingToReferenceScale !== undefined && dto.mappingToReferenceScale !== null) ? dto.mappingToReferenceScale.slice(0) : dto.mappingToReferenceScale;
      clone.maximumPermissibleValue = dto.maximumPermissibleValue;
      clone.minimumPermissibleValue = dto.minimumPermissibleValue;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.negativeValueConnotation = dto.negativeValueConnotation;
      clone.numberSet = dto.numberSet;
      clone.positiveValueConnotation = dto.positiveValueConnotation;
      clone.shortName = dto.shortName;
      clone.unit = dto.unit;
      clone.valueDefinition = (dto.valueDefinition !== undefined && dto.valueDefinition !== null) ? dto.valueDefinition.slice(0) : dto.valueDefinition;

      return clone;
    }
  }

  /**
   * The metadata for ReferencerRule
   */
  class ReferencerRuleMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ReferencerRule";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Rule";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "rule");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "maxReferenced": new PropertyMetadata("maxReferenced", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "minReferenced": new PropertyMetadata("minReferenced", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "referencedCategory": new PropertyMetadata("referencedCategory", "Category", 1, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "referencingCategory": new PropertyMetadata("referencingCategory", "Category", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const referencerRule = <Dto.ReferencerRule>thing;
      return {
        "alias": referencerRule.alias,
        "definition": referencerRule.definition,
        "hyperLink": referencerRule.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const referencerRule = <Dto.ReferencerRule>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ReferencerRule) => any } = {
      "alias": (dto : Dto.ReferencerRule) => { return dto.alias },
      "classKind": (dto : Dto.ReferencerRule) => { return dto.classKind },
      "definition": (dto : Dto.ReferencerRule) => { return dto.definition },
      "excludedDomain": (dto : Dto.ReferencerRule) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ReferencerRule) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.ReferencerRule) => { return dto.hyperLink },
      "iid": (dto : Dto.ReferencerRule) => { return dto.iid },
      "isDeprecated": (dto : Dto.ReferencerRule) => { return dto.isDeprecated },
      "maxReferenced": (dto : Dto.ReferencerRule) => { return dto.maxReferenced },
      "minReferenced": (dto : Dto.ReferencerRule) => { return dto.minReferenced },
      "modifiedOn": (dto : Dto.ReferencerRule) => { return dto.modifiedOn },
      "name": (dto : Dto.ReferencerRule) => { return dto.name },
      "referencedCategory": (dto : Dto.ReferencerRule) => { return dto.referencedCategory },
      "referencingCategory": (dto : Dto.ReferencerRule) => { return dto.referencingCategory },
      "revisionNumber": (dto : Dto.ReferencerRule) => { return dto.revisionNumber },
      "shortName": (dto : Dto.ReferencerRule) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ReferencerRule>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ReferencerRule>dtoThing;
      const clone = new Dto.ReferencerRule(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.maxReferenced = dto.maxReferenced;
      clone.minReferenced = dto.minReferenced;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.referencedCategory = (dto.referencedCategory !== undefined && dto.referencedCategory !== null) ? dto.referencedCategory.slice(0) : dto.referencedCategory;
      clone.referencingCategory = dto.referencingCategory;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for ReferenceSource
   */
  class ReferenceSourceMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ReferenceSource";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "referenceSource");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "author": new PropertyMetadata("author", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "language": new PropertyMetadata("language", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "publicationYear": new PropertyMetadata("publicationYear", "number", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "publishedIn": new PropertyMetadata("publishedIn", "ReferenceSource", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "publisher": new PropertyMetadata("publisher", "Organization", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "versionDate": new PropertyMetadata("versionDate", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "versionIdentifier": new PropertyMetadata("versionIdentifier", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const referenceSource = <Dto.ReferenceSource>thing;
      return {
        "alias": referenceSource.alias,
        "definition": referenceSource.definition,
        "hyperLink": referenceSource.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const referenceSource = <Dto.ReferenceSource>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ReferenceSource) => any } = {
      "alias": (dto : Dto.ReferenceSource) => { return dto.alias },
      "author": (dto : Dto.ReferenceSource) => { return dto.author },
      "category": (dto : Dto.ReferenceSource) => { return dto.category },
      "classKind": (dto : Dto.ReferenceSource) => { return dto.classKind },
      "definition": (dto : Dto.ReferenceSource) => { return dto.definition },
      "excludedDomain": (dto : Dto.ReferenceSource) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ReferenceSource) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.ReferenceSource) => { return dto.hyperLink },
      "iid": (dto : Dto.ReferenceSource) => { return dto.iid },
      "isDeprecated": (dto : Dto.ReferenceSource) => { return dto.isDeprecated },
      "language": (dto : Dto.ReferenceSource) => { return dto.language },
      "modifiedOn": (dto : Dto.ReferenceSource) => { return dto.modifiedOn },
      "name": (dto : Dto.ReferenceSource) => { return dto.name },
      "publicationYear": (dto : Dto.ReferenceSource) => { return dto.publicationYear },
      "publishedIn": (dto : Dto.ReferenceSource) => { return dto.publishedIn },
      "publisher": (dto : Dto.ReferenceSource) => { return dto.publisher },
      "revisionNumber": (dto : Dto.ReferenceSource) => { return dto.revisionNumber },
      "shortName": (dto : Dto.ReferenceSource) => { return dto.shortName },
      "versionDate": (dto : Dto.ReferenceSource) => { return dto.versionDate },
      "versionIdentifier": (dto : Dto.ReferenceSource) => { return dto.versionIdentifier },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ReferenceSource>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ReferenceSource>dtoThing;
      const clone = new Dto.ReferenceSource(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.author = dto.author;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.language = dto.language;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.publicationYear = dto.publicationYear;
      clone.publishedIn = dto.publishedIn;
      clone.publisher = dto.publisher;
      clone.shortName = dto.shortName;
      clone.versionDate = dto.versionDate;
      clone.versionIdentifier = dto.versionIdentifier;

      return clone;
    }
  }

  /**
   * The metadata for RelationalExpression
   */
  class RelationalExpressionMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "RelationalExpression";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "BooleanExpression";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ParametricConstraint", "expression");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "parameterType": new PropertyMetadata("parameterType", "ParameterType", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "relationalOperator": new PropertyMetadata("relationalOperator", "RelationalOperatorKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "scale": new PropertyMetadata("scale", "MeasurementScale", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "value": new PropertyMetadata("value", "string", 1, "*", AggregationKind.None, false, true, true, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const relationalExpression = <Dto.RelationalExpression>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const relationalExpression = <Dto.RelationalExpression>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.RelationalExpression) => any } = {
      "classKind": (dto : Dto.RelationalExpression) => { return dto.classKind },
      "excludedDomain": (dto : Dto.RelationalExpression) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.RelationalExpression) => { return dto.excludedPerson },
      "iid": (dto : Dto.RelationalExpression) => { return dto.iid },
      "modifiedOn": (dto : Dto.RelationalExpression) => { return dto.modifiedOn },
      "parameterType": (dto : Dto.RelationalExpression) => { return dto.parameterType },
      "relationalOperator": (dto : Dto.RelationalExpression) => { return dto.relationalOperator },
      "revisionNumber": (dto : Dto.RelationalExpression) => { return dto.revisionNumber },
      "scale": (dto : Dto.RelationalExpression) => { return dto.scale },
      "value": (dto : Dto.RelationalExpression) => { return dto.value },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.RelationalExpression>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.RelationalExpression>dtoThing;
      const clone = new Dto.RelationalExpression(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.parameterType = dto.parameterType;
      clone.relationalOperator = dto.relationalOperator;
      clone.scale = dto.scale;
      clone.value = (dto.value !== undefined && dto.value !== null) ? dto.value.slice(0) : dto.value;

      return clone;
    }
  }

  /**
   * The metadata for RelationshipParameterValue
   */
  class RelationshipParameterValueMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "RelationshipParameterValue";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ParameterValue";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Relationship", "parameterValue");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "parameterType": new PropertyMetadata("parameterType", "ParameterType", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "scale": new PropertyMetadata("scale", "MeasurementScale", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "value": new PropertyMetadata("value", "string", 1, "*", AggregationKind.None, false, true, true, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const relationshipParameterValue = <Dto.RelationshipParameterValue>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const relationshipParameterValue = <Dto.RelationshipParameterValue>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.RelationshipParameterValue) => any } = {
      "classKind": (dto : Dto.RelationshipParameterValue) => { return dto.classKind },
      "excludedDomain": (dto : Dto.RelationshipParameterValue) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.RelationshipParameterValue) => { return dto.excludedPerson },
      "iid": (dto : Dto.RelationshipParameterValue) => { return dto.iid },
      "modifiedOn": (dto : Dto.RelationshipParameterValue) => { return dto.modifiedOn },
      "parameterType": (dto : Dto.RelationshipParameterValue) => { return dto.parameterType },
      "revisionNumber": (dto : Dto.RelationshipParameterValue) => { return dto.revisionNumber },
      "scale": (dto : Dto.RelationshipParameterValue) => { return dto.scale },
      "value": (dto : Dto.RelationshipParameterValue) => { return dto.value },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.RelationshipParameterValue>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.RelationshipParameterValue>dtoThing;
      const clone = new Dto.RelationshipParameterValue(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.parameterType = dto.parameterType;
      clone.scale = dto.scale;
      clone.value = (dto.value !== undefined && dto.value !== null) ? dto.value.slice(0) : dto.value;

      return clone;
    }
  }

  /**
   * The metadata for RequestForDeviation
   */
  class RequestForDeviationMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "RequestForDeviation";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ContractDeviation";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModel", "modellingAnnotation");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "approvedBy": new PropertyMetadata("approvedBy", "Approval", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "author": new PropertyMetadata("author", "Participant", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classification": new PropertyMetadata("classification", "AnnotationClassificationKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "discussion": new PropertyMetadata("discussion", "EngineeringModelDataDiscussionItem", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "primaryAnnotatedThing": new PropertyMetadata("primaryAnnotatedThing", "ModellingThingReference", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "relatedThing": new PropertyMetadata("relatedThing", "ModellingThingReference", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "sourceAnnotation": new PropertyMetadata("sourceAnnotation", "ModellingAnnotationItem", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "status": new PropertyMetadata("status", "AnnotationStatusKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "title": new PropertyMetadata("title", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const requestForDeviation = <Dto.RequestForDeviation>thing;
      return {
        "approvedBy": requestForDeviation.approvedBy,
        "discussion": requestForDeviation.discussion,
        "relatedThing": requestForDeviation.relatedThing,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const requestForDeviation = <Dto.RequestForDeviation>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.RequestForDeviation) => any } = {
      "approvedBy": (dto : Dto.RequestForDeviation) => { return dto.approvedBy },
      "author": (dto : Dto.RequestForDeviation) => { return dto.author },
      "category": (dto : Dto.RequestForDeviation) => { return dto.category },
      "classification": (dto : Dto.RequestForDeviation) => { return dto.classification },
      "classKind": (dto : Dto.RequestForDeviation) => { return dto.classKind },
      "content": (dto : Dto.RequestForDeviation) => { return dto.content },
      "createdOn": (dto : Dto.RequestForDeviation) => { return dto.createdOn },
      "discussion": (dto : Dto.RequestForDeviation) => { return dto.discussion },
      "excludedDomain": (dto : Dto.RequestForDeviation) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.RequestForDeviation) => { return dto.excludedPerson },
      "iid": (dto : Dto.RequestForDeviation) => { return dto.iid },
      "languageCode": (dto : Dto.RequestForDeviation) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.RequestForDeviation) => { return dto.modifiedOn },
      "owner": (dto : Dto.RequestForDeviation) => { return dto.owner },
      "primaryAnnotatedThing": (dto : Dto.RequestForDeviation) => { return dto.primaryAnnotatedThing },
      "relatedThing": (dto : Dto.RequestForDeviation) => { return dto.relatedThing },
      "revisionNumber": (dto : Dto.RequestForDeviation) => { return dto.revisionNumber },
      "shortName": (dto : Dto.RequestForDeviation) => { return dto.shortName },
      "sourceAnnotation": (dto : Dto.RequestForDeviation) => { return dto.sourceAnnotation },
      "status": (dto : Dto.RequestForDeviation) => { return dto.status },
      "title": (dto : Dto.RequestForDeviation) => { return dto.title },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.RequestForDeviation>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.RequestForDeviation>dtoThing;
      const clone = new Dto.RequestForDeviation(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.approvedBy = (dto.approvedBy !== undefined && dto.approvedBy !== null) ? dto.approvedBy.slice(0) : dto.approvedBy;
      clone.author = dto.author;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classification = dto.classification;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.createdOn = dto.createdOn;
      clone.discussion = (dto.discussion !== undefined && dto.discussion !== null) ? dto.discussion.slice(0) : dto.discussion;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;
      clone.primaryAnnotatedThing = dto.primaryAnnotatedThing;
      clone.relatedThing = (dto.relatedThing !== undefined && dto.relatedThing !== null) ? dto.relatedThing.slice(0) : dto.relatedThing;
      clone.shortName = dto.shortName;
      clone.sourceAnnotation = (dto.sourceAnnotation !== undefined && dto.sourceAnnotation !== null) ? dto.sourceAnnotation.slice(0) : dto.sourceAnnotation;
      clone.status = dto.status;
      clone.title = dto.title;

      return clone;
    }
  }

  /**
   * The metadata for RequestForWaiver
   */
  class RequestForWaiverMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "RequestForWaiver";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ContractDeviation";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModel", "modellingAnnotation");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "approvedBy": new PropertyMetadata("approvedBy", "Approval", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "author": new PropertyMetadata("author", "Participant", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classification": new PropertyMetadata("classification", "AnnotationClassificationKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "discussion": new PropertyMetadata("discussion", "EngineeringModelDataDiscussionItem", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "primaryAnnotatedThing": new PropertyMetadata("primaryAnnotatedThing", "ModellingThingReference", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "relatedThing": new PropertyMetadata("relatedThing", "ModellingThingReference", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "sourceAnnotation": new PropertyMetadata("sourceAnnotation", "ModellingAnnotationItem", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "status": new PropertyMetadata("status", "AnnotationStatusKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "title": new PropertyMetadata("title", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const requestForWaiver = <Dto.RequestForWaiver>thing;
      return {
        "approvedBy": requestForWaiver.approvedBy,
        "discussion": requestForWaiver.discussion,
        "relatedThing": requestForWaiver.relatedThing,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const requestForWaiver = <Dto.RequestForWaiver>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.RequestForWaiver) => any } = {
      "approvedBy": (dto : Dto.RequestForWaiver) => { return dto.approvedBy },
      "author": (dto : Dto.RequestForWaiver) => { return dto.author },
      "category": (dto : Dto.RequestForWaiver) => { return dto.category },
      "classification": (dto : Dto.RequestForWaiver) => { return dto.classification },
      "classKind": (dto : Dto.RequestForWaiver) => { return dto.classKind },
      "content": (dto : Dto.RequestForWaiver) => { return dto.content },
      "createdOn": (dto : Dto.RequestForWaiver) => { return dto.createdOn },
      "discussion": (dto : Dto.RequestForWaiver) => { return dto.discussion },
      "excludedDomain": (dto : Dto.RequestForWaiver) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.RequestForWaiver) => { return dto.excludedPerson },
      "iid": (dto : Dto.RequestForWaiver) => { return dto.iid },
      "languageCode": (dto : Dto.RequestForWaiver) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.RequestForWaiver) => { return dto.modifiedOn },
      "owner": (dto : Dto.RequestForWaiver) => { return dto.owner },
      "primaryAnnotatedThing": (dto : Dto.RequestForWaiver) => { return dto.primaryAnnotatedThing },
      "relatedThing": (dto : Dto.RequestForWaiver) => { return dto.relatedThing },
      "revisionNumber": (dto : Dto.RequestForWaiver) => { return dto.revisionNumber },
      "shortName": (dto : Dto.RequestForWaiver) => { return dto.shortName },
      "sourceAnnotation": (dto : Dto.RequestForWaiver) => { return dto.sourceAnnotation },
      "status": (dto : Dto.RequestForWaiver) => { return dto.status },
      "title": (dto : Dto.RequestForWaiver) => { return dto.title },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.RequestForWaiver>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.RequestForWaiver>dtoThing;
      const clone = new Dto.RequestForWaiver(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.approvedBy = (dto.approvedBy !== undefined && dto.approvedBy !== null) ? dto.approvedBy.slice(0) : dto.approvedBy;
      clone.author = dto.author;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classification = dto.classification;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.createdOn = dto.createdOn;
      clone.discussion = (dto.discussion !== undefined && dto.discussion !== null) ? dto.discussion.slice(0) : dto.discussion;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;
      clone.primaryAnnotatedThing = dto.primaryAnnotatedThing;
      clone.relatedThing = (dto.relatedThing !== undefined && dto.relatedThing !== null) ? dto.relatedThing.slice(0) : dto.relatedThing;
      clone.shortName = dto.shortName;
      clone.sourceAnnotation = (dto.sourceAnnotation !== undefined && dto.sourceAnnotation !== null) ? dto.sourceAnnotation.slice(0) : dto.sourceAnnotation;
      clone.status = dto.status;
      clone.title = dto.title;

      return clone;
    }
  }

  /**
   * The metadata for Requirement
   */
  class RequirementMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Requirement";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "SimpleParameterizableThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("RequirementsSpecification", "requirement");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "group": new PropertyMetadata("group", "RequirementsGroup", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "parameterValue": new PropertyMetadata("parameterValue", "SimpleParameterValue", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "parametricConstraint": new PropertyMetadata("parametricConstraint", "ParametricConstraint", 0, "*", AggregationKind.Composite, false, true, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const requirement = <Dto.Requirement>thing;
      return {
        "alias": requirement.alias,
        "definition": requirement.definition,
        "hyperLink": requirement.hyperLink,
        "parameterValue": requirement.parameterValue,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const requirement = <Dto.Requirement>thing;
      return {
        "parametricConstraint": requirement.parametricConstraint,
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Requirement) => any } = {
      "alias": (dto : Dto.Requirement) => { return dto.alias },
      "category": (dto : Dto.Requirement) => { return dto.category },
      "classKind": (dto : Dto.Requirement) => { return dto.classKind },
      "definition": (dto : Dto.Requirement) => { return dto.definition },
      "excludedDomain": (dto : Dto.Requirement) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Requirement) => { return dto.excludedPerson },
      "group": (dto : Dto.Requirement) => { return dto.group },
      "hyperLink": (dto : Dto.Requirement) => { return dto.hyperLink },
      "iid": (dto : Dto.Requirement) => { return dto.iid },
      "isDeprecated": (dto : Dto.Requirement) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.Requirement) => { return dto.modifiedOn },
      "name": (dto : Dto.Requirement) => { return dto.name },
      "owner": (dto : Dto.Requirement) => { return dto.owner },
      "parameterValue": (dto : Dto.Requirement) => { return dto.parameterValue },
      "parametricConstraint": (dto : Dto.Requirement) => { return dto.parametricConstraint },
      "revisionNumber": (dto : Dto.Requirement) => { return dto.revisionNumber },
      "shortName": (dto : Dto.Requirement) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Requirement>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Requirement>dtoThing;
      const clone = new Dto.Requirement(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.group = dto.group;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.owner = dto.owner;
      clone.parameterValue = (dto.parameterValue !== undefined && dto.parameterValue !== null) ? dto.parameterValue.slice(0) : dto.parameterValue;
      clone.parametricConstraint = (dto.parametricConstraint !== undefined && dto.parametricConstraint !== null) ? dto.parametricConstraint.slice(0) : dto.parametricConstraint;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for RequirementsContainerParameterValue
   */
  class RequirementsContainerParameterValueMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "RequirementsContainerParameterValue";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ParameterValue";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("RequirementsContainer", "parameterValue");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "parameterType": new PropertyMetadata("parameterType", "ParameterType", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "scale": new PropertyMetadata("scale", "MeasurementScale", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "value": new PropertyMetadata("value", "string", 1, "*", AggregationKind.None, false, true, true, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const requirementsContainerParameterValue = <Dto.RequirementsContainerParameterValue>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const requirementsContainerParameterValue = <Dto.RequirementsContainerParameterValue>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.RequirementsContainerParameterValue) => any } = {
      "classKind": (dto : Dto.RequirementsContainerParameterValue) => { return dto.classKind },
      "excludedDomain": (dto : Dto.RequirementsContainerParameterValue) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.RequirementsContainerParameterValue) => { return dto.excludedPerson },
      "iid": (dto : Dto.RequirementsContainerParameterValue) => { return dto.iid },
      "modifiedOn": (dto : Dto.RequirementsContainerParameterValue) => { return dto.modifiedOn },
      "parameterType": (dto : Dto.RequirementsContainerParameterValue) => { return dto.parameterType },
      "revisionNumber": (dto : Dto.RequirementsContainerParameterValue) => { return dto.revisionNumber },
      "scale": (dto : Dto.RequirementsContainerParameterValue) => { return dto.scale },
      "value": (dto : Dto.RequirementsContainerParameterValue) => { return dto.value },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.RequirementsContainerParameterValue>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.RequirementsContainerParameterValue>dtoThing;
      const clone = new Dto.RequirementsContainerParameterValue(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.parameterType = dto.parameterType;
      clone.scale = dto.scale;
      clone.value = (dto.value !== undefined && dto.value !== null) ? dto.value.slice(0) : dto.value;

      return clone;
    }
  }

  /**
   * The metadata for RequirementsGroup
   */
  class RequirementsGroupMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "RequirementsGroup";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "RequirementsContainer";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("RequirementsContainer", "group");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "group": new PropertyMetadata("group", "RequirementsGroup", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "parameterValue": new PropertyMetadata("parameterValue", "RequirementsContainerParameterValue", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const requirementsGroup = <Dto.RequirementsGroup>thing;
      return {
        "alias": requirementsGroup.alias,
        "definition": requirementsGroup.definition,
        "group": requirementsGroup.group,
        "hyperLink": requirementsGroup.hyperLink,
        "parameterValue": requirementsGroup.parameterValue,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const requirementsGroup = <Dto.RequirementsGroup>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.RequirementsGroup) => any } = {
      "alias": (dto : Dto.RequirementsGroup) => { return dto.alias },
      "category": (dto : Dto.RequirementsGroup) => { return dto.category },
      "classKind": (dto : Dto.RequirementsGroup) => { return dto.classKind },
      "definition": (dto : Dto.RequirementsGroup) => { return dto.definition },
      "excludedDomain": (dto : Dto.RequirementsGroup) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.RequirementsGroup) => { return dto.excludedPerson },
      "group": (dto : Dto.RequirementsGroup) => { return dto.group },
      "hyperLink": (dto : Dto.RequirementsGroup) => { return dto.hyperLink },
      "iid": (dto : Dto.RequirementsGroup) => { return dto.iid },
      "modifiedOn": (dto : Dto.RequirementsGroup) => { return dto.modifiedOn },
      "name": (dto : Dto.RequirementsGroup) => { return dto.name },
      "owner": (dto : Dto.RequirementsGroup) => { return dto.owner },
      "parameterValue": (dto : Dto.RequirementsGroup) => { return dto.parameterValue },
      "revisionNumber": (dto : Dto.RequirementsGroup) => { return dto.revisionNumber },
      "shortName": (dto : Dto.RequirementsGroup) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.RequirementsGroup>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.RequirementsGroup>dtoThing;
      const clone = new Dto.RequirementsGroup(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.group = (dto.group !== undefined && dto.group !== null) ? dto.group.slice(0) : dto.group;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.owner = dto.owner;
      clone.parameterValue = (dto.parameterValue !== undefined && dto.parameterValue !== null) ? dto.parameterValue.slice(0) : dto.parameterValue;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for RequirementsSpecification
   */
  class RequirementsSpecificationMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "RequirementsSpecification";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "RequirementsContainer";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "requirementsSpecification");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "group": new PropertyMetadata("group", "RequirementsGroup", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "parameterValue": new PropertyMetadata("parameterValue", "RequirementsContainerParameterValue", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.1.0"),
      "requirement": new PropertyMetadata("requirement", "Requirement", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const requirementsSpecification = <Dto.RequirementsSpecification>thing;
      return {
        "alias": requirementsSpecification.alias,
        "definition": requirementsSpecification.definition,
        "group": requirementsSpecification.group,
        "hyperLink": requirementsSpecification.hyperLink,
        "parameterValue": requirementsSpecification.parameterValue,
        "requirement": requirementsSpecification.requirement,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const requirementsSpecification = <Dto.RequirementsSpecification>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.RequirementsSpecification) => any } = {
      "alias": (dto : Dto.RequirementsSpecification) => { return dto.alias },
      "category": (dto : Dto.RequirementsSpecification) => { return dto.category },
      "classKind": (dto : Dto.RequirementsSpecification) => { return dto.classKind },
      "definition": (dto : Dto.RequirementsSpecification) => { return dto.definition },
      "excludedDomain": (dto : Dto.RequirementsSpecification) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.RequirementsSpecification) => { return dto.excludedPerson },
      "group": (dto : Dto.RequirementsSpecification) => { return dto.group },
      "hyperLink": (dto : Dto.RequirementsSpecification) => { return dto.hyperLink },
      "iid": (dto : Dto.RequirementsSpecification) => { return dto.iid },
      "isDeprecated": (dto : Dto.RequirementsSpecification) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.RequirementsSpecification) => { return dto.modifiedOn },
      "name": (dto : Dto.RequirementsSpecification) => { return dto.name },
      "owner": (dto : Dto.RequirementsSpecification) => { return dto.owner },
      "parameterValue": (dto : Dto.RequirementsSpecification) => { return dto.parameterValue },
      "requirement": (dto : Dto.RequirementsSpecification) => { return dto.requirement },
      "revisionNumber": (dto : Dto.RequirementsSpecification) => { return dto.revisionNumber },
      "shortName": (dto : Dto.RequirementsSpecification) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.RequirementsSpecification>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.RequirementsSpecification>dtoThing;
      const clone = new Dto.RequirementsSpecification(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.group = (dto.group !== undefined && dto.group !== null) ? dto.group.slice(0) : dto.group;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.owner = dto.owner;
      clone.parameterValue = (dto.parameterValue !== undefined && dto.parameterValue !== null) ? dto.parameterValue.slice(0) : dto.parameterValue;
      clone.requirement = (dto.requirement !== undefined && dto.requirement !== null) ? dto.requirement.slice(0) : dto.requirement;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for ReviewItemDiscrepancy
   */
  class ReviewItemDiscrepancyMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ReviewItemDiscrepancy";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ModellingAnnotationItem";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("EngineeringModel", "modellingAnnotation");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "approvedBy": new PropertyMetadata("approvedBy", "Approval", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "author": new PropertyMetadata("author", "Participant", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classification": new PropertyMetadata("classification", "AnnotationClassificationKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "discussion": new PropertyMetadata("discussion", "EngineeringModelDataDiscussionItem", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "primaryAnnotatedThing": new PropertyMetadata("primaryAnnotatedThing", "ModellingThingReference", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "relatedThing": new PropertyMetadata("relatedThing", "ModellingThingReference", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "solution": new PropertyMetadata("solution", "Solution", 0, "1", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "sourceAnnotation": new PropertyMetadata("sourceAnnotation", "ModellingAnnotationItem", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "status": new PropertyMetadata("status", "AnnotationStatusKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "title": new PropertyMetadata("title", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const reviewItemDiscrepancy = <Dto.ReviewItemDiscrepancy>thing;
      return {
        "approvedBy": reviewItemDiscrepancy.approvedBy,
        "discussion": reviewItemDiscrepancy.discussion,
        "relatedThing": reviewItemDiscrepancy.relatedThing,
        "solution": reviewItemDiscrepancy.solution,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const reviewItemDiscrepancy = <Dto.ReviewItemDiscrepancy>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ReviewItemDiscrepancy) => any } = {
      "approvedBy": (dto : Dto.ReviewItemDiscrepancy) => { return dto.approvedBy },
      "author": (dto : Dto.ReviewItemDiscrepancy) => { return dto.author },
      "category": (dto : Dto.ReviewItemDiscrepancy) => { return dto.category },
      "classification": (dto : Dto.ReviewItemDiscrepancy) => { return dto.classification },
      "classKind": (dto : Dto.ReviewItemDiscrepancy) => { return dto.classKind },
      "content": (dto : Dto.ReviewItemDiscrepancy) => { return dto.content },
      "createdOn": (dto : Dto.ReviewItemDiscrepancy) => { return dto.createdOn },
      "discussion": (dto : Dto.ReviewItemDiscrepancy) => { return dto.discussion },
      "excludedDomain": (dto : Dto.ReviewItemDiscrepancy) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ReviewItemDiscrepancy) => { return dto.excludedPerson },
      "iid": (dto : Dto.ReviewItemDiscrepancy) => { return dto.iid },
      "languageCode": (dto : Dto.ReviewItemDiscrepancy) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.ReviewItemDiscrepancy) => { return dto.modifiedOn },
      "owner": (dto : Dto.ReviewItemDiscrepancy) => { return dto.owner },
      "primaryAnnotatedThing": (dto : Dto.ReviewItemDiscrepancy) => { return dto.primaryAnnotatedThing },
      "relatedThing": (dto : Dto.ReviewItemDiscrepancy) => { return dto.relatedThing },
      "revisionNumber": (dto : Dto.ReviewItemDiscrepancy) => { return dto.revisionNumber },
      "shortName": (dto : Dto.ReviewItemDiscrepancy) => { return dto.shortName },
      "solution": (dto : Dto.ReviewItemDiscrepancy) => { return dto.solution },
      "sourceAnnotation": (dto : Dto.ReviewItemDiscrepancy) => { return dto.sourceAnnotation },
      "status": (dto : Dto.ReviewItemDiscrepancy) => { return dto.status },
      "title": (dto : Dto.ReviewItemDiscrepancy) => { return dto.title },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ReviewItemDiscrepancy>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ReviewItemDiscrepancy>dtoThing;
      const clone = new Dto.ReviewItemDiscrepancy(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.approvedBy = (dto.approvedBy !== undefined && dto.approvedBy !== null) ? dto.approvedBy.slice(0) : dto.approvedBy;
      clone.author = dto.author;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classification = dto.classification;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.createdOn = dto.createdOn;
      clone.discussion = (dto.discussion !== undefined && dto.discussion !== null) ? dto.discussion.slice(0) : dto.discussion;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;
      clone.primaryAnnotatedThing = dto.primaryAnnotatedThing;
      clone.relatedThing = (dto.relatedThing !== undefined && dto.relatedThing !== null) ? dto.relatedThing.slice(0) : dto.relatedThing;
      clone.shortName = dto.shortName;
      clone.solution = dto.solution;
      clone.sourceAnnotation = (dto.sourceAnnotation !== undefined && dto.sourceAnnotation !== null) ? dto.sourceAnnotation.slice(0) : dto.sourceAnnotation;
      clone.status = dto.status;
      clone.title = dto.title;

      return clone;
    }
  }

  /**
   * The metadata for RuleVerificationList
   */
  class RuleVerificationListMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "RuleVerificationList";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "ruleVerificationList");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "ruleVerification": new PropertyMetadata("ruleVerification", "RuleVerification", 0, "*", AggregationKind.Composite, false, true, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const ruleVerificationList = <Dto.RuleVerificationList>thing;
      return {
        "alias": ruleVerificationList.alias,
        "definition": ruleVerificationList.definition,
        "hyperLink": ruleVerificationList.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const ruleVerificationList = <Dto.RuleVerificationList>thing;
      return {
        "ruleVerification": ruleVerificationList.ruleVerification,
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.RuleVerificationList) => any } = {
      "alias": (dto : Dto.RuleVerificationList) => { return dto.alias },
      "classKind": (dto : Dto.RuleVerificationList) => { return dto.classKind },
      "definition": (dto : Dto.RuleVerificationList) => { return dto.definition },
      "excludedDomain": (dto : Dto.RuleVerificationList) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.RuleVerificationList) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.RuleVerificationList) => { return dto.hyperLink },
      "iid": (dto : Dto.RuleVerificationList) => { return dto.iid },
      "modifiedOn": (dto : Dto.RuleVerificationList) => { return dto.modifiedOn },
      "name": (dto : Dto.RuleVerificationList) => { return dto.name },
      "owner": (dto : Dto.RuleVerificationList) => { return dto.owner },
      "revisionNumber": (dto : Dto.RuleVerificationList) => { return dto.revisionNumber },
      "ruleVerification": (dto : Dto.RuleVerificationList) => { return dto.ruleVerification },
      "shortName": (dto : Dto.RuleVerificationList) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.RuleVerificationList>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.RuleVerificationList>dtoThing;
      const clone = new Dto.RuleVerificationList(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.owner = dto.owner;
      clone.ruleVerification = (dto.ruleVerification !== undefined && dto.ruleVerification !== null) ? dto.ruleVerification.slice(0) : dto.ruleVerification;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for RuleViolation
   */
  class RuleViolationMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "RuleViolation";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("RuleVerification", "violation");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "description": new PropertyMetadata("description", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "violatingThing": new PropertyMetadata("violatingThing", "string", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const ruleViolation = <Dto.RuleViolation>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const ruleViolation = <Dto.RuleViolation>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.RuleViolation) => any } = {
      "classKind": (dto : Dto.RuleViolation) => { return dto.classKind },
      "description": (dto : Dto.RuleViolation) => { return dto.description },
      "excludedDomain": (dto : Dto.RuleViolation) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.RuleViolation) => { return dto.excludedPerson },
      "iid": (dto : Dto.RuleViolation) => { return dto.iid },
      "modifiedOn": (dto : Dto.RuleViolation) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.RuleViolation) => { return dto.revisionNumber },
      "violatingThing": (dto : Dto.RuleViolation) => { return dto.violatingThing },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.RuleViolation>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.RuleViolation>dtoThing;
      const clone = new Dto.RuleViolation(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.description = dto.description;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.violatingThing = (dto.violatingThing !== undefined && dto.violatingThing !== null) ? dto.violatingThing.slice(0) : dto.violatingThing;

      return clone;
    }
  }

  /**
   * The metadata for ScaleReferenceQuantityValue
   */
  class ScaleReferenceQuantityValueMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ScaleReferenceQuantityValue";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("LogarithmicScale", "referenceQuantityValue");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "scale": new PropertyMetadata("scale", "MeasurementScale", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "value": new PropertyMetadata("value", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const scaleReferenceQuantityValue = <Dto.ScaleReferenceQuantityValue>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const scaleReferenceQuantityValue = <Dto.ScaleReferenceQuantityValue>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ScaleReferenceQuantityValue) => any } = {
      "classKind": (dto : Dto.ScaleReferenceQuantityValue) => { return dto.classKind },
      "excludedDomain": (dto : Dto.ScaleReferenceQuantityValue) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ScaleReferenceQuantityValue) => { return dto.excludedPerson },
      "iid": (dto : Dto.ScaleReferenceQuantityValue) => { return dto.iid },
      "modifiedOn": (dto : Dto.ScaleReferenceQuantityValue) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.ScaleReferenceQuantityValue) => { return dto.revisionNumber },
      "scale": (dto : Dto.ScaleReferenceQuantityValue) => { return dto.scale },
      "value": (dto : Dto.ScaleReferenceQuantityValue) => { return dto.value },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ScaleReferenceQuantityValue>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ScaleReferenceQuantityValue>dtoThing;
      const clone = new Dto.ScaleReferenceQuantityValue(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.scale = dto.scale;
      clone.value = dto.value;

      return clone;
    }
  }

  /**
   * The metadata for ScaleValueDefinition
   */
  class ScaleValueDefinitionMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ScaleValueDefinition";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("MeasurementScale", "valueDefinition");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "value": new PropertyMetadata("value", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const scaleValueDefinition = <Dto.ScaleValueDefinition>thing;
      return {
        "alias": scaleValueDefinition.alias,
        "definition": scaleValueDefinition.definition,
        "hyperLink": scaleValueDefinition.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const scaleValueDefinition = <Dto.ScaleValueDefinition>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ScaleValueDefinition) => any } = {
      "alias": (dto : Dto.ScaleValueDefinition) => { return dto.alias },
      "classKind": (dto : Dto.ScaleValueDefinition) => { return dto.classKind },
      "definition": (dto : Dto.ScaleValueDefinition) => { return dto.definition },
      "excludedDomain": (dto : Dto.ScaleValueDefinition) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ScaleValueDefinition) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.ScaleValueDefinition) => { return dto.hyperLink },
      "iid": (dto : Dto.ScaleValueDefinition) => { return dto.iid },
      "modifiedOn": (dto : Dto.ScaleValueDefinition) => { return dto.modifiedOn },
      "name": (dto : Dto.ScaleValueDefinition) => { return dto.name },
      "revisionNumber": (dto : Dto.ScaleValueDefinition) => { return dto.revisionNumber },
      "shortName": (dto : Dto.ScaleValueDefinition) => { return dto.shortName },
      "value": (dto : Dto.ScaleValueDefinition) => { return dto.value },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ScaleValueDefinition>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ScaleValueDefinition>dtoThing;
      const clone = new Dto.ScaleValueDefinition(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;
      clone.value = dto.value;

      return clone;
    }
  }

  /**
   * The metadata for Section
   */
  class SectionMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Section";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Book", "section");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "page": new PropertyMetadata("page", "Page", 0, "*", AggregationKind.Composite, false, true, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const section = <Dto.Section>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const section = <Dto.Section>thing;
      return {
        "page": section.page,
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Section) => any } = {
      "category": (dto : Dto.Section) => { return dto.category },
      "classKind": (dto : Dto.Section) => { return dto.classKind },
      "createdOn": (dto : Dto.Section) => { return dto.createdOn },
      "excludedDomain": (dto : Dto.Section) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Section) => { return dto.excludedPerson },
      "iid": (dto : Dto.Section) => { return dto.iid },
      "modifiedOn": (dto : Dto.Section) => { return dto.modifiedOn },
      "name": (dto : Dto.Section) => { return dto.name },
      "owner": (dto : Dto.Section) => { return dto.owner },
      "page": (dto : Dto.Section) => { return dto.page },
      "revisionNumber": (dto : Dto.Section) => { return dto.revisionNumber },
      "shortName": (dto : Dto.Section) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Section>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Section>dtoThing;
      const clone = new Dto.Section(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.createdOn = dto.createdOn;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.owner = dto.owner;
      clone.page = (dto.page !== undefined && dto.page !== null) ? dto.page.slice(0) : dto.page;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for SharedStyle
   */
  class SharedStyleMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "SharedStyle";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DiagrammingStyle";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "sharedDiagramStyle");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "fillColor": new PropertyMetadata("fillColor", "Color", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "fillOpacity": new PropertyMetadata("fillOpacity", "number", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "fontBold": new PropertyMetadata("fontBold", "boolean", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "fontColor": new PropertyMetadata("fontColor", "Color", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "fontItalic": new PropertyMetadata("fontItalic", "boolean", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "fontName": new PropertyMetadata("fontName", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "fontSize": new PropertyMetadata("fontSize", "number", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "fontStrokeThrough": new PropertyMetadata("fontStrokeThrough", "boolean", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "fontUnderline": new PropertyMetadata("fontUnderline", "boolean", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "strokeColor": new PropertyMetadata("strokeColor", "Color", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "strokeOpacity": new PropertyMetadata("strokeOpacity", "number", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "strokeWidth": new PropertyMetadata("strokeWidth", "number", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "usedColor": new PropertyMetadata("usedColor", "Color", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const sharedStyle = <Dto.SharedStyle>thing;
      return {
        "usedColor": sharedStyle.usedColor,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const sharedStyle = <Dto.SharedStyle>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.SharedStyle) => any } = {
      "classKind": (dto : Dto.SharedStyle) => { return dto.classKind },
      "excludedDomain": (dto : Dto.SharedStyle) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.SharedStyle) => { return dto.excludedPerson },
      "fillColor": (dto : Dto.SharedStyle) => { return dto.fillColor },
      "fillOpacity": (dto : Dto.SharedStyle) => { return dto.fillOpacity },
      "fontBold": (dto : Dto.SharedStyle) => { return dto.fontBold },
      "fontColor": (dto : Dto.SharedStyle) => { return dto.fontColor },
      "fontItalic": (dto : Dto.SharedStyle) => { return dto.fontItalic },
      "fontName": (dto : Dto.SharedStyle) => { return dto.fontName },
      "fontSize": (dto : Dto.SharedStyle) => { return dto.fontSize },
      "fontStrokeThrough": (dto : Dto.SharedStyle) => { return dto.fontStrokeThrough },
      "fontUnderline": (dto : Dto.SharedStyle) => { return dto.fontUnderline },
      "iid": (dto : Dto.SharedStyle) => { return dto.iid },
      "modifiedOn": (dto : Dto.SharedStyle) => { return dto.modifiedOn },
      "name": (dto : Dto.SharedStyle) => { return dto.name },
      "revisionNumber": (dto : Dto.SharedStyle) => { return dto.revisionNumber },
      "strokeColor": (dto : Dto.SharedStyle) => { return dto.strokeColor },
      "strokeOpacity": (dto : Dto.SharedStyle) => { return dto.strokeOpacity },
      "strokeWidth": (dto : Dto.SharedStyle) => { return dto.strokeWidth },
      "usedColor": (dto : Dto.SharedStyle) => { return dto.usedColor },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.SharedStyle>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.SharedStyle>dtoThing;
      const clone = new Dto.SharedStyle(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.fillColor = dto.fillColor;
      clone.fillOpacity = dto.fillOpacity;
      clone.fontBold = dto.fontBold;
      clone.fontColor = dto.fontColor;
      clone.fontItalic = dto.fontItalic;
      clone.fontName = dto.fontName;
      clone.fontSize = dto.fontSize;
      clone.fontStrokeThrough = dto.fontStrokeThrough;
      clone.fontUnderline = dto.fontUnderline;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.strokeColor = dto.strokeColor;
      clone.strokeOpacity = dto.strokeOpacity;
      clone.strokeWidth = dto.strokeWidth;
      clone.usedColor = (dto.usedColor !== undefined && dto.usedColor !== null) ? dto.usedColor.slice(0) : dto.usedColor;

      return clone;
    }
  }

  /**
   * The metadata for SimpleParameterValue
   */
  class SimpleParameterValueMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "SimpleParameterValue";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("SimpleParameterizableThing", "parameterValue");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "parameterType": new PropertyMetadata("parameterType", "ParameterType", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "scale": new PropertyMetadata("scale", "MeasurementScale", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "value": new PropertyMetadata("value", "string", 1, "*", AggregationKind.None, false, true, true, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const simpleParameterValue = <Dto.SimpleParameterValue>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const simpleParameterValue = <Dto.SimpleParameterValue>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.SimpleParameterValue) => any } = {
      "classKind": (dto : Dto.SimpleParameterValue) => { return dto.classKind },
      "excludedDomain": (dto : Dto.SimpleParameterValue) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.SimpleParameterValue) => { return dto.excludedPerson },
      "iid": (dto : Dto.SimpleParameterValue) => { return dto.iid },
      "modifiedOn": (dto : Dto.SimpleParameterValue) => { return dto.modifiedOn },
      "owner": (dto : Dto.SimpleParameterValue) => { return dto.owner },
      "parameterType": (dto : Dto.SimpleParameterValue) => { return dto.parameterType },
      "revisionNumber": (dto : Dto.SimpleParameterValue) => { return dto.revisionNumber },
      "scale": (dto : Dto.SimpleParameterValue) => { return dto.scale },
      "value": (dto : Dto.SimpleParameterValue) => { return dto.value },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.SimpleParameterValue>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.SimpleParameterValue>dtoThing;
      const clone = new Dto.SimpleParameterValue(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.parameterType = dto.parameterType;
      clone.scale = dto.scale;
      clone.value = (dto.value !== undefined && dto.value !== null) ? dto.value.slice(0) : dto.value;

      return clone;
    }
  }

  /**
   * The metadata for SimpleQuantityKind
   */
  class SimpleQuantityKindMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "SimpleQuantityKind";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "QuantityKind";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "parameterType");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "allPossibleScale": new PropertyMetadata("allPossibleScale", "MeasurementScale", 0, "*", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "defaultScale": new PropertyMetadata("defaultScale", "MeasurementScale", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "numberOfValues": new PropertyMetadata("numberOfValues", "number", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "possibleScale": new PropertyMetadata("possibleScale", "MeasurementScale", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "quantityDimensionExponent": new PropertyMetadata("quantityDimensionExponent", "string", 0, "*", AggregationKind.None, false, true, false, true, false, false, "1.0.0"),
      "quantityDimensionExpression": new PropertyMetadata("quantityDimensionExpression", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "quantityDimensionSymbol": new PropertyMetadata("quantityDimensionSymbol", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "symbol": new PropertyMetadata("symbol", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const simpleQuantityKind = <Dto.SimpleQuantityKind>thing;
      return {
        "alias": simpleQuantityKind.alias,
        "definition": simpleQuantityKind.definition,
        "hyperLink": simpleQuantityKind.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const simpleQuantityKind = <Dto.SimpleQuantityKind>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.SimpleQuantityKind) => any } = {
      "alias": (dto : Dto.SimpleQuantityKind) => { return dto.alias },
      "allPossibleScale": (dto : Dto.SimpleQuantityKind) => { return dto.allPossibleScale },
      "category": (dto : Dto.SimpleQuantityKind) => { return dto.category },
      "classKind": (dto : Dto.SimpleQuantityKind) => { return dto.classKind },
      "defaultScale": (dto : Dto.SimpleQuantityKind) => { return dto.defaultScale },
      "definition": (dto : Dto.SimpleQuantityKind) => { return dto.definition },
      "excludedDomain": (dto : Dto.SimpleQuantityKind) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.SimpleQuantityKind) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.SimpleQuantityKind) => { return dto.hyperLink },
      "iid": (dto : Dto.SimpleQuantityKind) => { return dto.iid },
      "isDeprecated": (dto : Dto.SimpleQuantityKind) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.SimpleQuantityKind) => { return dto.modifiedOn },
      "name": (dto : Dto.SimpleQuantityKind) => { return dto.name },
      "numberOfValues": (dto : Dto.SimpleQuantityKind) => { return dto.numberOfValues },
      "possibleScale": (dto : Dto.SimpleQuantityKind) => { return dto.possibleScale },
      "quantityDimensionExponent": (dto : Dto.SimpleQuantityKind) => { return dto.quantityDimensionExponent },
      "quantityDimensionExpression": (dto : Dto.SimpleQuantityKind) => { return dto.quantityDimensionExpression },
      "quantityDimensionSymbol": (dto : Dto.SimpleQuantityKind) => { return dto.quantityDimensionSymbol },
      "revisionNumber": (dto : Dto.SimpleQuantityKind) => { return dto.revisionNumber },
      "shortName": (dto : Dto.SimpleQuantityKind) => { return dto.shortName },
      "symbol": (dto : Dto.SimpleQuantityKind) => { return dto.symbol },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.SimpleQuantityKind>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.SimpleQuantityKind>dtoThing;
      const clone = new Dto.SimpleQuantityKind(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.defaultScale = dto.defaultScale;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.possibleScale = (dto.possibleScale !== undefined && dto.possibleScale !== null) ? dto.possibleScale.slice(0) : dto.possibleScale;
      clone.quantityDimensionSymbol = dto.quantityDimensionSymbol;
      clone.shortName = dto.shortName;
      clone.symbol = dto.symbol;

      return clone;
    }
  }

  /**
   * The metadata for SimpleUnit
   */
  class SimpleUnitMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "SimpleUnit";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "MeasurementUnit";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "unit");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const simpleUnit = <Dto.SimpleUnit>thing;
      return {
        "alias": simpleUnit.alias,
        "definition": simpleUnit.definition,
        "hyperLink": simpleUnit.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const simpleUnit = <Dto.SimpleUnit>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.SimpleUnit) => any } = {
      "alias": (dto : Dto.SimpleUnit) => { return dto.alias },
      "classKind": (dto : Dto.SimpleUnit) => { return dto.classKind },
      "definition": (dto : Dto.SimpleUnit) => { return dto.definition },
      "excludedDomain": (dto : Dto.SimpleUnit) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.SimpleUnit) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.SimpleUnit) => { return dto.hyperLink },
      "iid": (dto : Dto.SimpleUnit) => { return dto.iid },
      "isDeprecated": (dto : Dto.SimpleUnit) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.SimpleUnit) => { return dto.modifiedOn },
      "name": (dto : Dto.SimpleUnit) => { return dto.name },
      "revisionNumber": (dto : Dto.SimpleUnit) => { return dto.revisionNumber },
      "shortName": (dto : Dto.SimpleUnit) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.SimpleUnit>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.SimpleUnit>dtoThing;
      const clone = new Dto.SimpleUnit(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for SiteDirectory
   */
  class SiteDirectoryMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "SiteDirectory";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "TopContainer";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("", "");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "annotation": new PropertyMetadata("annotation", "SiteDirectoryDataAnnotation", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.1.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "defaultParticipantRole": new PropertyMetadata("defaultParticipantRole", "ParticipantRole", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "defaultPersonRole": new PropertyMetadata("defaultPersonRole", "PersonRole", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "domain": new PropertyMetadata("domain", "DomainOfExpertise", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "domainGroup": new PropertyMetadata("domainGroup", "DomainOfExpertiseGroup", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "lastModifiedOn": new PropertyMetadata("lastModifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "logEntry": new PropertyMetadata("logEntry", "SiteLogEntry", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "model": new PropertyMetadata("model", "EngineeringModelSetup", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "naturalLanguage": new PropertyMetadata("naturalLanguage", "NaturalLanguage", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "organization": new PropertyMetadata("organization", "Organization", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "participantRole": new PropertyMetadata("participantRole", "ParticipantRole", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "person": new PropertyMetadata("person", "Person", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "personRole": new PropertyMetadata("personRole", "PersonRole", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "siteReferenceDataLibrary": new PropertyMetadata("siteReferenceDataLibrary", "SiteReferenceDataLibrary", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const siteDirectory = <Dto.SiteDirectory>thing;
      return {
        "annotation": siteDirectory.annotation,
        "domain": siteDirectory.domain,
        "domainGroup": siteDirectory.domainGroup,
        "logEntry": siteDirectory.logEntry,
        "model": siteDirectory.model,
        "naturalLanguage": siteDirectory.naturalLanguage,
        "organization": siteDirectory.organization,
        "participantRole": siteDirectory.participantRole,
        "person": siteDirectory.person,
        "personRole": siteDirectory.personRole,
        "siteReferenceDataLibrary": siteDirectory.siteReferenceDataLibrary,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const siteDirectory = <Dto.SiteDirectory>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.SiteDirectory) => any } = {
      "annotation": (dto : Dto.SiteDirectory) => { return dto.annotation },
      "classKind": (dto : Dto.SiteDirectory) => { return dto.classKind },
      "createdOn": (dto : Dto.SiteDirectory) => { return dto.createdOn },
      "defaultParticipantRole": (dto : Dto.SiteDirectory) => { return dto.defaultParticipantRole },
      "defaultPersonRole": (dto : Dto.SiteDirectory) => { return dto.defaultPersonRole },
      "domain": (dto : Dto.SiteDirectory) => { return dto.domain },
      "domainGroup": (dto : Dto.SiteDirectory) => { return dto.domainGroup },
      "excludedDomain": (dto : Dto.SiteDirectory) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.SiteDirectory) => { return dto.excludedPerson },
      "iid": (dto : Dto.SiteDirectory) => { return dto.iid },
      "lastModifiedOn": (dto : Dto.SiteDirectory) => { return dto.lastModifiedOn },
      "logEntry": (dto : Dto.SiteDirectory) => { return dto.logEntry },
      "model": (dto : Dto.SiteDirectory) => { return dto.model },
      "modifiedOn": (dto : Dto.SiteDirectory) => { return dto.modifiedOn },
      "name": (dto : Dto.SiteDirectory) => { return dto.name },
      "naturalLanguage": (dto : Dto.SiteDirectory) => { return dto.naturalLanguage },
      "organization": (dto : Dto.SiteDirectory) => { return dto.organization },
      "participantRole": (dto : Dto.SiteDirectory) => { return dto.participantRole },
      "person": (dto : Dto.SiteDirectory) => { return dto.person },
      "personRole": (dto : Dto.SiteDirectory) => { return dto.personRole },
      "revisionNumber": (dto : Dto.SiteDirectory) => { return dto.revisionNumber },
      "shortName": (dto : Dto.SiteDirectory) => { return dto.shortName },
      "siteReferenceDataLibrary": (dto : Dto.SiteDirectory) => { return dto.siteReferenceDataLibrary },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.SiteDirectory>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.SiteDirectory>dtoThing;
      const clone = new Dto.SiteDirectory(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.annotation = (dto.annotation !== undefined && dto.annotation !== null) ? dto.annotation.slice(0) : dto.annotation;
      clone.classKind = dto.classKind;
      clone.createdOn = dto.createdOn;
      clone.defaultParticipantRole = dto.defaultParticipantRole;
      clone.defaultPersonRole = dto.defaultPersonRole;
      clone.domain = (dto.domain !== undefined && dto.domain !== null) ? dto.domain.slice(0) : dto.domain;
      clone.domainGroup = (dto.domainGroup !== undefined && dto.domainGroup !== null) ? dto.domainGroup.slice(0) : dto.domainGroup;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.lastModifiedOn = dto.lastModifiedOn;
      clone.logEntry = (dto.logEntry !== undefined && dto.logEntry !== null) ? dto.logEntry.slice(0) : dto.logEntry;
      clone.model = (dto.model !== undefined && dto.model !== null) ? dto.model.slice(0) : dto.model;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.naturalLanguage = (dto.naturalLanguage !== undefined && dto.naturalLanguage !== null) ? dto.naturalLanguage.slice(0) : dto.naturalLanguage;
      clone.organization = (dto.organization !== undefined && dto.organization !== null) ? dto.organization.slice(0) : dto.organization;
      clone.participantRole = (dto.participantRole !== undefined && dto.participantRole !== null) ? dto.participantRole.slice(0) : dto.participantRole;
      clone.person = (dto.person !== undefined && dto.person !== null) ? dto.person.slice(0) : dto.person;
      clone.personRole = (dto.personRole !== undefined && dto.personRole !== null) ? dto.personRole.slice(0) : dto.personRole;
      clone.shortName = dto.shortName;
      clone.siteReferenceDataLibrary = (dto.siteReferenceDataLibrary !== undefined && dto.siteReferenceDataLibrary !== null) ? dto.siteReferenceDataLibrary.slice(0) : dto.siteReferenceDataLibrary;

      return clone;
    }
  }

  /**
   * The metadata for SiteDirectoryDataAnnotation
   */
  class SiteDirectoryDataAnnotationMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "SiteDirectoryDataAnnotation";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "GenericAnnotation";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("SiteDirectory", "annotation");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "author": new PropertyMetadata("author", "Person", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "discussion": new PropertyMetadata("discussion", "SiteDirectoryDataDiscussionItem", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "primaryAnnotatedThing": new PropertyMetadata("primaryAnnotatedThing", "SiteDirectoryThingReference", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "relatedThing": new PropertyMetadata("relatedThing", "SiteDirectoryThingReference", 1, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const siteDirectoryDataAnnotation = <Dto.SiteDirectoryDataAnnotation>thing;
      return {
        "discussion": siteDirectoryDataAnnotation.discussion,
        "relatedThing": siteDirectoryDataAnnotation.relatedThing,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const siteDirectoryDataAnnotation = <Dto.SiteDirectoryDataAnnotation>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.SiteDirectoryDataAnnotation) => any } = {
      "author": (dto : Dto.SiteDirectoryDataAnnotation) => { return dto.author },
      "classKind": (dto : Dto.SiteDirectoryDataAnnotation) => { return dto.classKind },
      "content": (dto : Dto.SiteDirectoryDataAnnotation) => { return dto.content },
      "createdOn": (dto : Dto.SiteDirectoryDataAnnotation) => { return dto.createdOn },
      "discussion": (dto : Dto.SiteDirectoryDataAnnotation) => { return dto.discussion },
      "excludedDomain": (dto : Dto.SiteDirectoryDataAnnotation) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.SiteDirectoryDataAnnotation) => { return dto.excludedPerson },
      "iid": (dto : Dto.SiteDirectoryDataAnnotation) => { return dto.iid },
      "languageCode": (dto : Dto.SiteDirectoryDataAnnotation) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.SiteDirectoryDataAnnotation) => { return dto.modifiedOn },
      "primaryAnnotatedThing": (dto : Dto.SiteDirectoryDataAnnotation) => { return dto.primaryAnnotatedThing },
      "relatedThing": (dto : Dto.SiteDirectoryDataAnnotation) => { return dto.relatedThing },
      "revisionNumber": (dto : Dto.SiteDirectoryDataAnnotation) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.SiteDirectoryDataAnnotation>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.SiteDirectoryDataAnnotation>dtoThing;
      const clone = new Dto.SiteDirectoryDataAnnotation(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.author = dto.author;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.createdOn = dto.createdOn;
      clone.discussion = (dto.discussion !== undefined && dto.discussion !== null) ? dto.discussion.slice(0) : dto.discussion;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.primaryAnnotatedThing = dto.primaryAnnotatedThing;
      clone.relatedThing = (dto.relatedThing !== undefined && dto.relatedThing !== null) ? dto.relatedThing.slice(0) : dto.relatedThing;

      return clone;
    }
  }

  /**
   * The metadata for SiteDirectoryDataDiscussionItem
   */
  class SiteDirectoryDataDiscussionItemMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "SiteDirectoryDataDiscussionItem";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DiscussionItem";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("SiteDirectoryDataAnnotation", "discussion");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "author": new PropertyMetadata("author", "Person", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "replyTo": new PropertyMetadata("replyTo", "DiscussionItem", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const siteDirectoryDataDiscussionItem = <Dto.SiteDirectoryDataDiscussionItem>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const siteDirectoryDataDiscussionItem = <Dto.SiteDirectoryDataDiscussionItem>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.SiteDirectoryDataDiscussionItem) => any } = {
      "author": (dto : Dto.SiteDirectoryDataDiscussionItem) => { return dto.author },
      "classKind": (dto : Dto.SiteDirectoryDataDiscussionItem) => { return dto.classKind },
      "content": (dto : Dto.SiteDirectoryDataDiscussionItem) => { return dto.content },
      "createdOn": (dto : Dto.SiteDirectoryDataDiscussionItem) => { return dto.createdOn },
      "excludedDomain": (dto : Dto.SiteDirectoryDataDiscussionItem) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.SiteDirectoryDataDiscussionItem) => { return dto.excludedPerson },
      "iid": (dto : Dto.SiteDirectoryDataDiscussionItem) => { return dto.iid },
      "languageCode": (dto : Dto.SiteDirectoryDataDiscussionItem) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.SiteDirectoryDataDiscussionItem) => { return dto.modifiedOn },
      "replyTo": (dto : Dto.SiteDirectoryDataDiscussionItem) => { return dto.replyTo },
      "revisionNumber": (dto : Dto.SiteDirectoryDataDiscussionItem) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.SiteDirectoryDataDiscussionItem>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.SiteDirectoryDataDiscussionItem>dtoThing;
      const clone = new Dto.SiteDirectoryDataDiscussionItem(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.author = dto.author;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.createdOn = dto.createdOn;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.replyTo = dto.replyTo;

      return clone;
    }
  }

  /**
   * The metadata for SiteDirectoryThingReference
   */
  class SiteDirectoryThingReferenceMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "SiteDirectoryThingReference";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ThingReference";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("SiteDirectoryDataAnnotation", "relatedThing");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "referencedRevisionNumber": new PropertyMetadata("referencedRevisionNumber", "number", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "referencedThing": new PropertyMetadata("referencedThing", "Thing", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const siteDirectoryThingReference = <Dto.SiteDirectoryThingReference>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const siteDirectoryThingReference = <Dto.SiteDirectoryThingReference>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.SiteDirectoryThingReference) => any } = {
      "classKind": (dto : Dto.SiteDirectoryThingReference) => { return dto.classKind },
      "excludedDomain": (dto : Dto.SiteDirectoryThingReference) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.SiteDirectoryThingReference) => { return dto.excludedPerson },
      "iid": (dto : Dto.SiteDirectoryThingReference) => { return dto.iid },
      "modifiedOn": (dto : Dto.SiteDirectoryThingReference) => { return dto.modifiedOn },
      "referencedRevisionNumber": (dto : Dto.SiteDirectoryThingReference) => { return dto.referencedRevisionNumber },
      "referencedThing": (dto : Dto.SiteDirectoryThingReference) => { return dto.referencedThing },
      "revisionNumber": (dto : Dto.SiteDirectoryThingReference) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.SiteDirectoryThingReference>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.SiteDirectoryThingReference>dtoThing;
      const clone = new Dto.SiteDirectoryThingReference(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.referencedRevisionNumber = dto.referencedRevisionNumber;
      clone.referencedThing = dto.referencedThing;

      return clone;
    }
  }

  /**
   * The metadata for SiteLogEntry
   */
  class SiteLogEntryMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "SiteLogEntry";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("SiteDirectory", "logEntry");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "affectedItemIid": new PropertyMetadata("affectedItemIid", "string", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "author": new PropertyMetadata("author", "Person", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "level": new PropertyMetadata("level", "LogLevelKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const siteLogEntry = <Dto.SiteLogEntry>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const siteLogEntry = <Dto.SiteLogEntry>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.SiteLogEntry) => any } = {
      "affectedItemIid": (dto : Dto.SiteLogEntry) => { return dto.affectedItemIid },
      "author": (dto : Dto.SiteLogEntry) => { return dto.author },
      "category": (dto : Dto.SiteLogEntry) => { return dto.category },
      "classKind": (dto : Dto.SiteLogEntry) => { return dto.classKind },
      "content": (dto : Dto.SiteLogEntry) => { return dto.content },
      "createdOn": (dto : Dto.SiteLogEntry) => { return dto.createdOn },
      "excludedDomain": (dto : Dto.SiteLogEntry) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.SiteLogEntry) => { return dto.excludedPerson },
      "iid": (dto : Dto.SiteLogEntry) => { return dto.iid },
      "languageCode": (dto : Dto.SiteLogEntry) => { return dto.languageCode },
      "level": (dto : Dto.SiteLogEntry) => { return dto.level },
      "modifiedOn": (dto : Dto.SiteLogEntry) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.SiteLogEntry) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.SiteLogEntry>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.SiteLogEntry>dtoThing;
      const clone = new Dto.SiteLogEntry(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.affectedItemIid = (dto.affectedItemIid !== undefined && dto.affectedItemIid !== null) ? dto.affectedItemIid.slice(0) : dto.affectedItemIid;
      clone.author = dto.author;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.createdOn = dto.createdOn;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.level = dto.level;
      clone.modifiedOn = dto.modifiedOn;

      return clone;
    }
  }

  /**
   * The metadata for SiteReferenceDataLibrary
   */
  class SiteReferenceDataLibraryMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "SiteReferenceDataLibrary";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ReferenceDataLibrary";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("SiteDirectory", "siteReferenceDataLibrary");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "baseQuantityKind": new PropertyMetadata("baseQuantityKind", "QuantityKind", 0, "*", AggregationKind.None, false, true, false, false, false, true, "1.0.0"),
      "baseUnit": new PropertyMetadata("baseUnit", "MeasurementUnit", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "constant": new PropertyMetadata("constant", "Constant", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "definedCategory": new PropertyMetadata("definedCategory", "Category", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "fileType": new PropertyMetadata("fileType", "FileType", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "glossary": new PropertyMetadata("glossary", "Glossary", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "parameterType": new PropertyMetadata("parameterType", "ParameterType", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "referenceSource": new PropertyMetadata("referenceSource", "ReferenceSource", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "requiredRdl": new PropertyMetadata("requiredRdl", "SiteReferenceDataLibrary", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "rule": new PropertyMetadata("rule", "Rule", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "scale": new PropertyMetadata("scale", "MeasurementScale", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "unit": new PropertyMetadata("unit", "MeasurementUnit", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "unitPrefix": new PropertyMetadata("unitPrefix", "UnitPrefix", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const siteReferenceDataLibrary = <Dto.SiteReferenceDataLibrary>thing;
      return {
        "alias": siteReferenceDataLibrary.alias,
        "constant": siteReferenceDataLibrary.constant,
        "definedCategory": siteReferenceDataLibrary.definedCategory,
        "definition": siteReferenceDataLibrary.definition,
        "fileType": siteReferenceDataLibrary.fileType,
        "glossary": siteReferenceDataLibrary.glossary,
        "hyperLink": siteReferenceDataLibrary.hyperLink,
        "parameterType": siteReferenceDataLibrary.parameterType,
        "referenceSource": siteReferenceDataLibrary.referenceSource,
        "rule": siteReferenceDataLibrary.rule,
        "scale": siteReferenceDataLibrary.scale,
        "unit": siteReferenceDataLibrary.unit,
        "unitPrefix": siteReferenceDataLibrary.unitPrefix,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const siteReferenceDataLibrary = <Dto.SiteReferenceDataLibrary>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.SiteReferenceDataLibrary) => any } = {
      "alias": (dto : Dto.SiteReferenceDataLibrary) => { return dto.alias },
      "baseQuantityKind": (dto : Dto.SiteReferenceDataLibrary) => { return dto.baseQuantityKind },
      "baseUnit": (dto : Dto.SiteReferenceDataLibrary) => { return dto.baseUnit },
      "classKind": (dto : Dto.SiteReferenceDataLibrary) => { return dto.classKind },
      "constant": (dto : Dto.SiteReferenceDataLibrary) => { return dto.constant },
      "definedCategory": (dto : Dto.SiteReferenceDataLibrary) => { return dto.definedCategory },
      "definition": (dto : Dto.SiteReferenceDataLibrary) => { return dto.definition },
      "excludedDomain": (dto : Dto.SiteReferenceDataLibrary) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.SiteReferenceDataLibrary) => { return dto.excludedPerson },
      "fileType": (dto : Dto.SiteReferenceDataLibrary) => { return dto.fileType },
      "glossary": (dto : Dto.SiteReferenceDataLibrary) => { return dto.glossary },
      "hyperLink": (dto : Dto.SiteReferenceDataLibrary) => { return dto.hyperLink },
      "iid": (dto : Dto.SiteReferenceDataLibrary) => { return dto.iid },
      "isDeprecated": (dto : Dto.SiteReferenceDataLibrary) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.SiteReferenceDataLibrary) => { return dto.modifiedOn },
      "name": (dto : Dto.SiteReferenceDataLibrary) => { return dto.name },
      "parameterType": (dto : Dto.SiteReferenceDataLibrary) => { return dto.parameterType },
      "referenceSource": (dto : Dto.SiteReferenceDataLibrary) => { return dto.referenceSource },
      "requiredRdl": (dto : Dto.SiteReferenceDataLibrary) => { return dto.requiredRdl },
      "revisionNumber": (dto : Dto.SiteReferenceDataLibrary) => { return dto.revisionNumber },
      "rule": (dto : Dto.SiteReferenceDataLibrary) => { return dto.rule },
      "scale": (dto : Dto.SiteReferenceDataLibrary) => { return dto.scale },
      "shortName": (dto : Dto.SiteReferenceDataLibrary) => { return dto.shortName },
      "unit": (dto : Dto.SiteReferenceDataLibrary) => { return dto.unit },
      "unitPrefix": (dto : Dto.SiteReferenceDataLibrary) => { return dto.unitPrefix },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.SiteReferenceDataLibrary>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.SiteReferenceDataLibrary>dtoThing;
      const clone = new Dto.SiteReferenceDataLibrary(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.baseQuantityKind = (dto.baseQuantityKind !== undefined && dto.baseQuantityKind !== null) ? dto.baseQuantityKind.slice(0) : dto.baseQuantityKind;
      clone.baseUnit = (dto.baseUnit !== undefined && dto.baseUnit !== null) ? dto.baseUnit.slice(0) : dto.baseUnit;
      clone.classKind = dto.classKind;
      clone.constant = (dto.constant !== undefined && dto.constant !== null) ? dto.constant.slice(0) : dto.constant;
      clone.definedCategory = (dto.definedCategory !== undefined && dto.definedCategory !== null) ? dto.definedCategory.slice(0) : dto.definedCategory;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.fileType = (dto.fileType !== undefined && dto.fileType !== null) ? dto.fileType.slice(0) : dto.fileType;
      clone.glossary = (dto.glossary !== undefined && dto.glossary !== null) ? dto.glossary.slice(0) : dto.glossary;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.parameterType = (dto.parameterType !== undefined && dto.parameterType !== null) ? dto.parameterType.slice(0) : dto.parameterType;
      clone.referenceSource = (dto.referenceSource !== undefined && dto.referenceSource !== null) ? dto.referenceSource.slice(0) : dto.referenceSource;
      clone.requiredRdl = dto.requiredRdl;
      clone.rule = (dto.rule !== undefined && dto.rule !== null) ? dto.rule.slice(0) : dto.rule;
      clone.scale = (dto.scale !== undefined && dto.scale !== null) ? dto.scale.slice(0) : dto.scale;
      clone.shortName = dto.shortName;
      clone.unit = (dto.unit !== undefined && dto.unit !== null) ? dto.unit.slice(0) : dto.unit;
      clone.unitPrefix = (dto.unitPrefix !== undefined && dto.unitPrefix !== null) ? dto.unitPrefix.slice(0) : dto.unitPrefix;

      return clone;
    }
  }

  /**
   * The metadata for Solution
   */
  class SolutionMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Solution";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "GenericAnnotation";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReviewItemDiscrepancy", "solution");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "author": new PropertyMetadata("author", "Participant", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const solution = <Dto.Solution>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const solution = <Dto.Solution>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Solution) => any } = {
      "author": (dto : Dto.Solution) => { return dto.author },
      "classKind": (dto : Dto.Solution) => { return dto.classKind },
      "content": (dto : Dto.Solution) => { return dto.content },
      "createdOn": (dto : Dto.Solution) => { return dto.createdOn },
      "excludedDomain": (dto : Dto.Solution) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Solution) => { return dto.excludedPerson },
      "iid": (dto : Dto.Solution) => { return dto.iid },
      "languageCode": (dto : Dto.Solution) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.Solution) => { return dto.modifiedOn },
      "owner": (dto : Dto.Solution) => { return dto.owner },
      "revisionNumber": (dto : Dto.Solution) => { return dto.revisionNumber },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Solution>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Solution>dtoThing;
      const clone = new Dto.Solution(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.author = dto.author;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.createdOn = dto.createdOn;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.owner = dto.owner;

      return clone;
    }
  }

  /**
   * The metadata for SpecializedQuantityKind
   */
  class SpecializedQuantityKindMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "SpecializedQuantityKind";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "QuantityKind";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "parameterType");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "allPossibleScale": new PropertyMetadata("allPossibleScale", "MeasurementScale", 0, "*", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "defaultScale": new PropertyMetadata("defaultScale", "MeasurementScale", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "general": new PropertyMetadata("general", "QuantityKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "numberOfValues": new PropertyMetadata("numberOfValues", "number", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "possibleScale": new PropertyMetadata("possibleScale", "MeasurementScale", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "quantityDimensionExponent": new PropertyMetadata("quantityDimensionExponent", "string", 0, "*", AggregationKind.None, false, true, false, true, false, false, "1.0.0"),
      "quantityDimensionExpression": new PropertyMetadata("quantityDimensionExpression", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "quantityDimensionSymbol": new PropertyMetadata("quantityDimensionSymbol", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "symbol": new PropertyMetadata("symbol", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const specializedQuantityKind = <Dto.SpecializedQuantityKind>thing;
      return {
        "alias": specializedQuantityKind.alias,
        "definition": specializedQuantityKind.definition,
        "hyperLink": specializedQuantityKind.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const specializedQuantityKind = <Dto.SpecializedQuantityKind>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.SpecializedQuantityKind) => any } = {
      "alias": (dto : Dto.SpecializedQuantityKind) => { return dto.alias },
      "allPossibleScale": (dto : Dto.SpecializedQuantityKind) => { return dto.allPossibleScale },
      "category": (dto : Dto.SpecializedQuantityKind) => { return dto.category },
      "classKind": (dto : Dto.SpecializedQuantityKind) => { return dto.classKind },
      "defaultScale": (dto : Dto.SpecializedQuantityKind) => { return dto.defaultScale },
      "definition": (dto : Dto.SpecializedQuantityKind) => { return dto.definition },
      "excludedDomain": (dto : Dto.SpecializedQuantityKind) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.SpecializedQuantityKind) => { return dto.excludedPerson },
      "general": (dto : Dto.SpecializedQuantityKind) => { return dto.general },
      "hyperLink": (dto : Dto.SpecializedQuantityKind) => { return dto.hyperLink },
      "iid": (dto : Dto.SpecializedQuantityKind) => { return dto.iid },
      "isDeprecated": (dto : Dto.SpecializedQuantityKind) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.SpecializedQuantityKind) => { return dto.modifiedOn },
      "name": (dto : Dto.SpecializedQuantityKind) => { return dto.name },
      "numberOfValues": (dto : Dto.SpecializedQuantityKind) => { return dto.numberOfValues },
      "possibleScale": (dto : Dto.SpecializedQuantityKind) => { return dto.possibleScale },
      "quantityDimensionExponent": (dto : Dto.SpecializedQuantityKind) => { return dto.quantityDimensionExponent },
      "quantityDimensionExpression": (dto : Dto.SpecializedQuantityKind) => { return dto.quantityDimensionExpression },
      "quantityDimensionSymbol": (dto : Dto.SpecializedQuantityKind) => { return dto.quantityDimensionSymbol },
      "revisionNumber": (dto : Dto.SpecializedQuantityKind) => { return dto.revisionNumber },
      "shortName": (dto : Dto.SpecializedQuantityKind) => { return dto.shortName },
      "symbol": (dto : Dto.SpecializedQuantityKind) => { return dto.symbol },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.SpecializedQuantityKind>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.SpecializedQuantityKind>dtoThing;
      const clone = new Dto.SpecializedQuantityKind(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.defaultScale = dto.defaultScale;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.general = dto.general;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.possibleScale = (dto.possibleScale !== undefined && dto.possibleScale !== null) ? dto.possibleScale.slice(0) : dto.possibleScale;
      clone.quantityDimensionSymbol = dto.quantityDimensionSymbol;
      clone.shortName = dto.shortName;
      clone.symbol = dto.symbol;

      return clone;
    }
  }

  /**
   * The metadata for Stakeholder
   */
  class StakeholderMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Stakeholder";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "stakeholder");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "stakeholderValue": new PropertyMetadata("stakeholderValue", "StakeholderValue", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const stakeholder = <Dto.Stakeholder>thing;
      return {
        "alias": stakeholder.alias,
        "definition": stakeholder.definition,
        "hyperLink": stakeholder.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const stakeholder = <Dto.Stakeholder>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Stakeholder) => any } = {
      "alias": (dto : Dto.Stakeholder) => { return dto.alias },
      "category": (dto : Dto.Stakeholder) => { return dto.category },
      "classKind": (dto : Dto.Stakeholder) => { return dto.classKind },
      "definition": (dto : Dto.Stakeholder) => { return dto.definition },
      "excludedDomain": (dto : Dto.Stakeholder) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Stakeholder) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.Stakeholder) => { return dto.hyperLink },
      "iid": (dto : Dto.Stakeholder) => { return dto.iid },
      "modifiedOn": (dto : Dto.Stakeholder) => { return dto.modifiedOn },
      "name": (dto : Dto.Stakeholder) => { return dto.name },
      "revisionNumber": (dto : Dto.Stakeholder) => { return dto.revisionNumber },
      "shortName": (dto : Dto.Stakeholder) => { return dto.shortName },
      "stakeholderValue": (dto : Dto.Stakeholder) => { return dto.stakeholderValue },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Stakeholder>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Stakeholder>dtoThing;
      const clone = new Dto.Stakeholder(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;
      clone.stakeholderValue = (dto.stakeholderValue !== undefined && dto.stakeholderValue !== null) ? dto.stakeholderValue.slice(0) : dto.stakeholderValue;

      return clone;
    }
  }

  /**
   * The metadata for StakeholderValue
   */
  class StakeholderValueMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "StakeholderValue";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "stakeholderValue");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const stakeholderValue = <Dto.StakeholderValue>thing;
      return {
        "alias": stakeholderValue.alias,
        "definition": stakeholderValue.definition,
        "hyperLink": stakeholderValue.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const stakeholderValue = <Dto.StakeholderValue>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.StakeholderValue) => any } = {
      "alias": (dto : Dto.StakeholderValue) => { return dto.alias },
      "category": (dto : Dto.StakeholderValue) => { return dto.category },
      "classKind": (dto : Dto.StakeholderValue) => { return dto.classKind },
      "definition": (dto : Dto.StakeholderValue) => { return dto.definition },
      "excludedDomain": (dto : Dto.StakeholderValue) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.StakeholderValue) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.StakeholderValue) => { return dto.hyperLink },
      "iid": (dto : Dto.StakeholderValue) => { return dto.iid },
      "modifiedOn": (dto : Dto.StakeholderValue) => { return dto.modifiedOn },
      "name": (dto : Dto.StakeholderValue) => { return dto.name },
      "revisionNumber": (dto : Dto.StakeholderValue) => { return dto.revisionNumber },
      "shortName": (dto : Dto.StakeholderValue) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.StakeholderValue>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.StakeholderValue>dtoThing;
      const clone = new Dto.StakeholderValue(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for StakeHolderValueMap
   */
  class StakeHolderValueMapMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "StakeHolderValueMap";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "stakeholderValueMap");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "goal": new PropertyMetadata("goal", "Goal", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "requirement": new PropertyMetadata("requirement", "Requirement", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "settings": new PropertyMetadata("settings", "StakeHolderValueMapSettings", 1, "1", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "stakeholderValue": new PropertyMetadata("stakeholderValue", "StakeholderValue", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "valueGroup": new PropertyMetadata("valueGroup", "ValueGroup", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const stakeHolderValueMap = <Dto.StakeHolderValueMap>thing;
      return {
        "alias": stakeHolderValueMap.alias,
        "definition": stakeHolderValueMap.definition,
        "hyperLink": stakeHolderValueMap.hyperLink,
        "settings": stakeHolderValueMap.settings,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const stakeHolderValueMap = <Dto.StakeHolderValueMap>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.StakeHolderValueMap) => any } = {
      "alias": (dto : Dto.StakeHolderValueMap) => { return dto.alias },
      "category": (dto : Dto.StakeHolderValueMap) => { return dto.category },
      "classKind": (dto : Dto.StakeHolderValueMap) => { return dto.classKind },
      "definition": (dto : Dto.StakeHolderValueMap) => { return dto.definition },
      "excludedDomain": (dto : Dto.StakeHolderValueMap) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.StakeHolderValueMap) => { return dto.excludedPerson },
      "goal": (dto : Dto.StakeHolderValueMap) => { return dto.goal },
      "hyperLink": (dto : Dto.StakeHolderValueMap) => { return dto.hyperLink },
      "iid": (dto : Dto.StakeHolderValueMap) => { return dto.iid },
      "modifiedOn": (dto : Dto.StakeHolderValueMap) => { return dto.modifiedOn },
      "name": (dto : Dto.StakeHolderValueMap) => { return dto.name },
      "requirement": (dto : Dto.StakeHolderValueMap) => { return dto.requirement },
      "revisionNumber": (dto : Dto.StakeHolderValueMap) => { return dto.revisionNumber },
      "settings": (dto : Dto.StakeHolderValueMap) => { return dto.settings },
      "shortName": (dto : Dto.StakeHolderValueMap) => { return dto.shortName },
      "stakeholderValue": (dto : Dto.StakeHolderValueMap) => { return dto.stakeholderValue },
      "valueGroup": (dto : Dto.StakeHolderValueMap) => { return dto.valueGroup },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.StakeHolderValueMap>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.StakeHolderValueMap>dtoThing;
      const clone = new Dto.StakeHolderValueMap(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.goal = (dto.goal !== undefined && dto.goal !== null) ? dto.goal.slice(0) : dto.goal;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.requirement = (dto.requirement !== undefined && dto.requirement !== null) ? dto.requirement.slice(0) : dto.requirement;
      clone.settings = dto.settings;
      clone.shortName = dto.shortName;
      clone.stakeholderValue = (dto.stakeholderValue !== undefined && dto.stakeholderValue !== null) ? dto.stakeholderValue.slice(0) : dto.stakeholderValue;
      clone.valueGroup = (dto.valueGroup !== undefined && dto.valueGroup !== null) ? dto.valueGroup.slice(0) : dto.valueGroup;

      return clone;
    }
  }

  /**
   * The metadata for StakeHolderValueMapSettings
   */
  class StakeHolderValueMapSettingsMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "StakeHolderValueMapSettings";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("StakeHolderValueMap", "settings");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "goalToValueGroupRelationship": new PropertyMetadata("goalToValueGroupRelationship", "BinaryRelationshipRule", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "stakeholderValueToRequirementRelationship": new PropertyMetadata("stakeholderValueToRequirementRelationship", "BinaryRelationshipRule", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
      "valueGroupToStakeholderValueRelationship": new PropertyMetadata("valueGroupToStakeholderValueRelationship", "BinaryRelationshipRule", 0, "1", AggregationKind.None, false, false, false, false, true, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const stakeHolderValueMapSettings = <Dto.StakeHolderValueMapSettings>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const stakeHolderValueMapSettings = <Dto.StakeHolderValueMapSettings>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.StakeHolderValueMapSettings) => any } = {
      "classKind": (dto : Dto.StakeHolderValueMapSettings) => { return dto.classKind },
      "excludedDomain": (dto : Dto.StakeHolderValueMapSettings) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.StakeHolderValueMapSettings) => { return dto.excludedPerson },
      "goalToValueGroupRelationship": (dto : Dto.StakeHolderValueMapSettings) => { return dto.goalToValueGroupRelationship },
      "iid": (dto : Dto.StakeHolderValueMapSettings) => { return dto.iid },
      "modifiedOn": (dto : Dto.StakeHolderValueMapSettings) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.StakeHolderValueMapSettings) => { return dto.revisionNumber },
      "stakeholderValueToRequirementRelationship": (dto : Dto.StakeHolderValueMapSettings) => { return dto.stakeholderValueToRequirementRelationship },
      "valueGroupToStakeholderValueRelationship": (dto : Dto.StakeHolderValueMapSettings) => { return dto.valueGroupToStakeholderValueRelationship },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.StakeHolderValueMapSettings>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.StakeHolderValueMapSettings>dtoThing;
      const clone = new Dto.StakeHolderValueMapSettings(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.goalToValueGroupRelationship = dto.goalToValueGroupRelationship;
      clone.modifiedOn = dto.modifiedOn;
      clone.stakeholderValueToRequirementRelationship = dto.stakeholderValueToRequirementRelationship;
      clone.valueGroupToStakeholderValueRelationship = dto.valueGroupToStakeholderValueRelationship;

      return clone;
    }
  }

  /**
   * The metadata for TelephoneNumber
   */
  class TelephoneNumberMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "TelephoneNumber";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Person", "telephoneNumber");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "value": new PropertyMetadata("value", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "vcardType": new PropertyMetadata("vcardType", "VcardTelephoneNumberKind", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const telephoneNumber = <Dto.TelephoneNumber>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const telephoneNumber = <Dto.TelephoneNumber>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.TelephoneNumber) => any } = {
      "classKind": (dto : Dto.TelephoneNumber) => { return dto.classKind },
      "excludedDomain": (dto : Dto.TelephoneNumber) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.TelephoneNumber) => { return dto.excludedPerson },
      "iid": (dto : Dto.TelephoneNumber) => { return dto.iid },
      "modifiedOn": (dto : Dto.TelephoneNumber) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.TelephoneNumber) => { return dto.revisionNumber },
      "value": (dto : Dto.TelephoneNumber) => { return dto.value },
      "vcardType": (dto : Dto.TelephoneNumber) => { return dto.vcardType },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.TelephoneNumber>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.TelephoneNumber>dtoThing;
      const clone = new Dto.TelephoneNumber(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.value = dto.value;
      clone.vcardType = (dto.vcardType !== undefined && dto.vcardType !== null) ? dto.vcardType.slice(0) : dto.vcardType;

      return clone;
    }
  }

  /**
   * The metadata for Term
   */
  class TermMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "Term";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Glossary", "term");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const term = <Dto.Term>thing;
      return {
        "alias": term.alias,
        "definition": term.definition,
        "hyperLink": term.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const term = <Dto.Term>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.Term) => any } = {
      "alias": (dto : Dto.Term) => { return dto.alias },
      "classKind": (dto : Dto.Term) => { return dto.classKind },
      "definition": (dto : Dto.Term) => { return dto.definition },
      "excludedDomain": (dto : Dto.Term) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.Term) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.Term) => { return dto.hyperLink },
      "iid": (dto : Dto.Term) => { return dto.iid },
      "isDeprecated": (dto : Dto.Term) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.Term) => { return dto.modifiedOn },
      "name": (dto : Dto.Term) => { return dto.name },
      "revisionNumber": (dto : Dto.Term) => { return dto.revisionNumber },
      "shortName": (dto : Dto.Term) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.Term>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.Term>dtoThing;
      const clone = new Dto.Term(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for TextParameterType
   */
  class TextParameterTypeMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "TextParameterType";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ScalarParameterType";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "parameterType");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "numberOfValues": new PropertyMetadata("numberOfValues", "number", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "symbol": new PropertyMetadata("symbol", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const textParameterType = <Dto.TextParameterType>thing;
      return {
        "alias": textParameterType.alias,
        "definition": textParameterType.definition,
        "hyperLink": textParameterType.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const textParameterType = <Dto.TextParameterType>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.TextParameterType) => any } = {
      "alias": (dto : Dto.TextParameterType) => { return dto.alias },
      "category": (dto : Dto.TextParameterType) => { return dto.category },
      "classKind": (dto : Dto.TextParameterType) => { return dto.classKind },
      "definition": (dto : Dto.TextParameterType) => { return dto.definition },
      "excludedDomain": (dto : Dto.TextParameterType) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.TextParameterType) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.TextParameterType) => { return dto.hyperLink },
      "iid": (dto : Dto.TextParameterType) => { return dto.iid },
      "isDeprecated": (dto : Dto.TextParameterType) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.TextParameterType) => { return dto.modifiedOn },
      "name": (dto : Dto.TextParameterType) => { return dto.name },
      "numberOfValues": (dto : Dto.TextParameterType) => { return dto.numberOfValues },
      "revisionNumber": (dto : Dto.TextParameterType) => { return dto.revisionNumber },
      "shortName": (dto : Dto.TextParameterType) => { return dto.shortName },
      "symbol": (dto : Dto.TextParameterType) => { return dto.symbol },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.TextParameterType>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.TextParameterType>dtoThing;
      const clone = new Dto.TextParameterType(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;
      clone.symbol = dto.symbol;

      return clone;
    }
  }

  /**
   * The metadata for TextualNote
   */
  class TextualNoteMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "TextualNote";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Note";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Page", "note");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "content": new PropertyMetadata("content", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "createdOn": new PropertyMetadata("createdOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "languageCode": new PropertyMetadata("languageCode", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const textualNote = <Dto.TextualNote>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const textualNote = <Dto.TextualNote>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.TextualNote) => any } = {
      "category": (dto : Dto.TextualNote) => { return dto.category },
      "classKind": (dto : Dto.TextualNote) => { return dto.classKind },
      "content": (dto : Dto.TextualNote) => { return dto.content },
      "createdOn": (dto : Dto.TextualNote) => { return dto.createdOn },
      "excludedDomain": (dto : Dto.TextualNote) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.TextualNote) => { return dto.excludedPerson },
      "iid": (dto : Dto.TextualNote) => { return dto.iid },
      "languageCode": (dto : Dto.TextualNote) => { return dto.languageCode },
      "modifiedOn": (dto : Dto.TextualNote) => { return dto.modifiedOn },
      "name": (dto : Dto.TextualNote) => { return dto.name },
      "owner": (dto : Dto.TextualNote) => { return dto.owner },
      "revisionNumber": (dto : Dto.TextualNote) => { return dto.revisionNumber },
      "shortName": (dto : Dto.TextualNote) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.TextualNote>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.TextualNote>dtoThing;
      const clone = new Dto.TextualNote(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.content = dto.content;
      clone.createdOn = dto.createdOn;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.languageCode = dto.languageCode;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.owner = dto.owner;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for TimeOfDayParameterType
   */
  class TimeOfDayParameterTypeMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "TimeOfDayParameterType";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "ScalarParameterType";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "parameterType");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "numberOfValues": new PropertyMetadata("numberOfValues", "number", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "symbol": new PropertyMetadata("symbol", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const timeOfDayParameterType = <Dto.TimeOfDayParameterType>thing;
      return {
        "alias": timeOfDayParameterType.alias,
        "definition": timeOfDayParameterType.definition,
        "hyperLink": timeOfDayParameterType.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const timeOfDayParameterType = <Dto.TimeOfDayParameterType>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.TimeOfDayParameterType) => any } = {
      "alias": (dto : Dto.TimeOfDayParameterType) => { return dto.alias },
      "category": (dto : Dto.TimeOfDayParameterType) => { return dto.category },
      "classKind": (dto : Dto.TimeOfDayParameterType) => { return dto.classKind },
      "definition": (dto : Dto.TimeOfDayParameterType) => { return dto.definition },
      "excludedDomain": (dto : Dto.TimeOfDayParameterType) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.TimeOfDayParameterType) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.TimeOfDayParameterType) => { return dto.hyperLink },
      "iid": (dto : Dto.TimeOfDayParameterType) => { return dto.iid },
      "isDeprecated": (dto : Dto.TimeOfDayParameterType) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.TimeOfDayParameterType) => { return dto.modifiedOn },
      "name": (dto : Dto.TimeOfDayParameterType) => { return dto.name },
      "numberOfValues": (dto : Dto.TimeOfDayParameterType) => { return dto.numberOfValues },
      "revisionNumber": (dto : Dto.TimeOfDayParameterType) => { return dto.revisionNumber },
      "shortName": (dto : Dto.TimeOfDayParameterType) => { return dto.shortName },
      "symbol": (dto : Dto.TimeOfDayParameterType) => { return dto.symbol },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.TimeOfDayParameterType>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.TimeOfDayParameterType>dtoThing;
      const clone = new Dto.TimeOfDayParameterType(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;
      clone.symbol = dto.symbol;

      return clone;
    }
  }

  /**
   * The metadata for UnitFactor
   */
  class UnitFactorMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "UnitFactor";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("DerivedUnit", "unitFactor");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "exponent": new PropertyMetadata("exponent", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "unit": new PropertyMetadata("unit", "MeasurementUnit", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const unitFactor = <Dto.UnitFactor>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const unitFactor = <Dto.UnitFactor>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.UnitFactor) => any } = {
      "classKind": (dto : Dto.UnitFactor) => { return dto.classKind },
      "excludedDomain": (dto : Dto.UnitFactor) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.UnitFactor) => { return dto.excludedPerson },
      "exponent": (dto : Dto.UnitFactor) => { return dto.exponent },
      "iid": (dto : Dto.UnitFactor) => { return dto.iid },
      "modifiedOn": (dto : Dto.UnitFactor) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.UnitFactor) => { return dto.revisionNumber },
      "unit": (dto : Dto.UnitFactor) => { return dto.unit },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.UnitFactor>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.UnitFactor>dtoThing;
      const clone = new Dto.UnitFactor(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.exponent = dto.exponent;
      clone.modifiedOn = dto.modifiedOn;
      clone.unit = dto.unit;

      return clone;
    }
  }

  /**
   * The metadata for UnitPrefix
   */
  class UnitPrefixMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "UnitPrefix";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("ReferenceDataLibrary", "unitPrefix");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "conversionFactor": new PropertyMetadata("conversionFactor", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isDeprecated": new PropertyMetadata("isDeprecated", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const unitPrefix = <Dto.UnitPrefix>thing;
      return {
        "alias": unitPrefix.alias,
        "definition": unitPrefix.definition,
        "hyperLink": unitPrefix.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const unitPrefix = <Dto.UnitPrefix>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.UnitPrefix) => any } = {
      "alias": (dto : Dto.UnitPrefix) => { return dto.alias },
      "classKind": (dto : Dto.UnitPrefix) => { return dto.classKind },
      "conversionFactor": (dto : Dto.UnitPrefix) => { return dto.conversionFactor },
      "definition": (dto : Dto.UnitPrefix) => { return dto.definition },
      "excludedDomain": (dto : Dto.UnitPrefix) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.UnitPrefix) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.UnitPrefix) => { return dto.hyperLink },
      "iid": (dto : Dto.UnitPrefix) => { return dto.iid },
      "isDeprecated": (dto : Dto.UnitPrefix) => { return dto.isDeprecated },
      "modifiedOn": (dto : Dto.UnitPrefix) => { return dto.modifiedOn },
      "name": (dto : Dto.UnitPrefix) => { return dto.name },
      "revisionNumber": (dto : Dto.UnitPrefix) => { return dto.revisionNumber },
      "shortName": (dto : Dto.UnitPrefix) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.UnitPrefix>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.UnitPrefix>dtoThing;
      const clone = new Dto.UnitPrefix(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.classKind = dto.classKind;
      clone.conversionFactor = dto.conversionFactor;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.isDeprecated = dto.isDeprecated;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The metadata for UserPreference
   */
  class UserPreferenceMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "UserPreference";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "Thing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Person", "userPreference");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "value": new PropertyMetadata("value", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const userPreference = <Dto.UserPreference>thing;
      return {
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const userPreference = <Dto.UserPreference>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.UserPreference) => any } = {
      "classKind": (dto : Dto.UserPreference) => { return dto.classKind },
      "excludedDomain": (dto : Dto.UserPreference) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.UserPreference) => { return dto.excludedPerson },
      "iid": (dto : Dto.UserPreference) => { return dto.iid },
      "modifiedOn": (dto : Dto.UserPreference) => { return dto.modifiedOn },
      "revisionNumber": (dto : Dto.UserPreference) => { return dto.revisionNumber },
      "shortName": (dto : Dto.UserPreference) => { return dto.shortName },
      "value": (dto : Dto.UserPreference) => { return dto.value },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.UserPreference>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.UserPreference>dtoThing;
      const clone = new Dto.UserPreference(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.modifiedOn = dto.modifiedOn;
      clone.shortName = dto.shortName;
      clone.value = dto.value;

      return clone;
    }
  }

  /**
   * The metadata for UserRuleVerification
   */
  class UserRuleVerificationMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "UserRuleVerification";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "RuleVerification";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("RuleVerificationList", "ruleVerification");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.0.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "executedOn": new PropertyMetadata("executedOn", "string", 0, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "isActive": new PropertyMetadata("isActive", "boolean", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "owner": new PropertyMetadata("owner", "DomainOfExpertise", 1, "1", AggregationKind.None, false, false, false, true, false, false, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "rule": new PropertyMetadata("rule", "Rule", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "status": new PropertyMetadata("status", "RuleVerificationStatusKind", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "violation": new PropertyMetadata("violation", "RuleViolation", 0, "*", AggregationKind.Composite, false, false, false, false, false, false, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const userRuleVerification = <Dto.UserRuleVerification>thing;
      return {
        "violation": userRuleVerification.violation,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const userRuleVerification = <Dto.UserRuleVerification>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.UserRuleVerification) => any } = {
      "classKind": (dto : Dto.UserRuleVerification) => { return dto.classKind },
      "excludedDomain": (dto : Dto.UserRuleVerification) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.UserRuleVerification) => { return dto.excludedPerson },
      "executedOn": (dto : Dto.UserRuleVerification) => { return dto.executedOn },
      "iid": (dto : Dto.UserRuleVerification) => { return dto.iid },
      "isActive": (dto : Dto.UserRuleVerification) => { return dto.isActive },
      "modifiedOn": (dto : Dto.UserRuleVerification) => { return dto.modifiedOn },
      "name": (dto : Dto.UserRuleVerification) => { return dto.name },
      "owner": (dto : Dto.UserRuleVerification) => { return dto.owner },
      "revisionNumber": (dto : Dto.UserRuleVerification) => { return dto.revisionNumber },
      "rule": (dto : Dto.UserRuleVerification) => { return dto.rule },
      "status": (dto : Dto.UserRuleVerification) => { return dto.status },
      "violation": (dto : Dto.UserRuleVerification) => { return dto.violation },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.UserRuleVerification>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.UserRuleVerification>dtoThing;
      const clone = new Dto.UserRuleVerification(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.classKind = dto.classKind;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.executedOn = dto.executedOn;
      clone.isActive = dto.isActive;
      clone.modifiedOn = dto.modifiedOn;
      clone.rule = dto.rule;
      clone.status = dto.status;
      clone.violation = (dto.violation !== undefined && dto.violation !== null) ? dto.violation.slice(0) : dto.violation;

      return clone;
    }
  }

  /**
   * The metadata for ValueGroup
   */
  class ValueGroupMetadata implements IThingMetadata {

    /**
     * Gets the name of the property
     */
    public get name(): string {
      return "ValueGroup";
    }

    /**
     * Gets or sets the name of the base type
     */
    public get baseTypeName(): string {
      return "DefinedThing";
    }

    /**
     * Gets a value indicating whether the thing type is abstract
     */
    public get isAbstract(): boolean {
      return false;
    }

    /**
     * Gets the name of the container
     */
    public get container(): ContainerMetadata {
      return new ContainerMetadata("Iteration", "valueGroup");
    }

    /**
     * Gets the version of the data-model related to this property
     */
    public get version(): string {
      return "1.1.0";
    }

    /**
     * Gets property metadata map
     */
    public propertyMetaData: { [property: string] : PropertyMetadata } = {
      "alias": new PropertyMetadata("alias", "Alias", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "category": new PropertyMetadata("category", "Category", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "classKind": new PropertyMetadata("classKind", "ClassKind", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "definition": new PropertyMetadata("definition", "Definition", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "excludedDomain": new PropertyMetadata("excludedDomain", "DomainOfExpertise", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "excludedPerson": new PropertyMetadata("excludedPerson", "Person", 0, "*", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "hyperLink": new PropertyMetadata("hyperLink", "HyperLink", 0, "*", AggregationKind.Composite, false, false, false, false, false, true, "1.0.0"),
      "iid": new PropertyMetadata("iid", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "modifiedOn": new PropertyMetadata("modifiedOn", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.1.0"),
      "name": new PropertyMetadata("name", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
      "revisionNumber": new PropertyMetadata("revisionNumber", "number", 1, "1", AggregationKind.None, true, false, false, false, false, true, "1.0.0"),
      "shortName": new PropertyMetadata("shortName", "string", 1, "1", AggregationKind.None, false, false, false, false, false, true, "1.0.0"),
    };

    /**
     * Get the container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the container list
     */
    public getContainerList(thing: Dto.Thing): { [property: string]: string[] } {
      const valueGroup = <Dto.ValueGroup>thing;
      return {
        "alias": valueGroup.alias,
        "definition": valueGroup.definition,
        "hyperLink": valueGroup.hyperLink,
      };
    }

    /**
     * Get the ordered container lists for a thing
     * @param thing the thing
     * @returns {} A map containing the ordered container list
     */
    public getOrderedContainerList(thing: Dto.Thing): { [property: string]: Cdp4Type.OrderedItem[] } {
      const valueGroup = <Dto.ValueGroup>thing;
      return {
      };
    }

    /**
     * The map that stores the get-value method for a specific property
     */
    private getValueMap: { [property: string] : (dto : Dto.ValueGroup) => any } = {
      "alias": (dto : Dto.ValueGroup) => { return dto.alias },
      "category": (dto : Dto.ValueGroup) => { return dto.category },
      "classKind": (dto : Dto.ValueGroup) => { return dto.classKind },
      "definition": (dto : Dto.ValueGroup) => { return dto.definition },
      "excludedDomain": (dto : Dto.ValueGroup) => { return dto.excludedDomain },
      "excludedPerson": (dto : Dto.ValueGroup) => { return dto.excludedPerson },
      "hyperLink": (dto : Dto.ValueGroup) => { return dto.hyperLink },
      "iid": (dto : Dto.ValueGroup) => { return dto.iid },
      "modifiedOn": (dto : Dto.ValueGroup) => { return dto.modifiedOn },
      "name": (dto : Dto.ValueGroup) => { return dto.name },
      "revisionNumber": (dto : Dto.ValueGroup) => { return dto.revisionNumber },
      "shortName": (dto : Dto.ValueGroup) => { return dto.shortName },
    };

    /**
     * Gets the value of a Thing for a specific property
     * @param dto the thing
     * @param property the property
     * @returns {} The value for the thing instance
     */
    public getValue(dto: Dto.Thing, property: string) : any {
      const getValueFunc = this.getValueMap[property];
      if (Utils.isUndefinedOrNull(getValueFunc)) {
        throw new Error("Cannot find the property: " + property);
      }

      return getValueFunc(<Dto.ValueGroup>dto);
    }

    /**
     * Clones a Thing
     * @param dtoThing the thing to clone
     * @param container the container thing for the created clone
     * @returns The clone of the thing
     */
    public clone(dtoThing: Dto.Thing, container: Dto.Thing): Dto.Thing {
      if (Utils.isUndefinedOrNull(dtoThing))
      {
        throw new Error("Cloning error: the thing to clone is null or undefined");
      }

      if (Utils.isUndefinedOrNull(container) && !(dtoThing instanceof Dto.TopContainer))
      {
        throw new Error("Cloning error: the container of the thing to clone is null or undefined");
      }

      const dto = <Dto.ValueGroup>dtoThing;
      const clone = new Dto.ValueGroup(dto.iid, dto.revisionNumber, false);
      clone.iterationContainerId = dto.iterationContainerId;
      clone.container = container;
      clone.alias = (dto.alias !== undefined && dto.alias !== null) ? dto.alias.slice(0) : dto.alias;
      clone.category = (dto.category !== undefined && dto.category !== null) ? dto.category.slice(0) : dto.category;
      clone.classKind = dto.classKind;
      clone.definition = (dto.definition !== undefined && dto.definition !== null) ? dto.definition.slice(0) : dto.definition;
      clone.excludedDomain = (dto.excludedDomain !== undefined && dto.excludedDomain !== null) ? dto.excludedDomain.slice(0) : dto.excludedDomain;
      clone.excludedPerson = (dto.excludedPerson !== undefined && dto.excludedPerson !== null) ? dto.excludedPerson.slice(0) : dto.excludedPerson;
      clone.hyperLink = (dto.hyperLink !== undefined && dto.hyperLink !== null) ? dto.hyperLink.slice(0) : dto.hyperLink;
      clone.modifiedOn = dto.modifiedOn;
      clone.name = dto.name;
      clone.shortName = dto.shortName;

      return clone;
    }
  }

  /**
   * The dictionary of metadata classes
   */
  const thingMetadata = {
    "ActionItem": new ActionItemMetadata(),
    "ActualFiniteState": new ActualFiniteStateMetadata(),
    "ActualFiniteStateList": new ActualFiniteStateListMetadata(),
    "Alias": new AliasMetadata(),
    "AndExpression": new AndExpressionMetadata(),
    "Approval": new ApprovalMetadata(),
    "ArrayParameterType": new ArrayParameterTypeMetadata(),
    "BinaryNote": new BinaryNoteMetadata(),
    "BinaryRelationship": new BinaryRelationshipMetadata(),
    "BinaryRelationshipRule": new BinaryRelationshipRuleMetadata(),
    "Book": new BookMetadata(),
    "BooleanParameterType": new BooleanParameterTypeMetadata(),
    "Bounds": new BoundsMetadata(),
    "BuiltInRuleVerification": new BuiltInRuleVerificationMetadata(),
    "Category": new CategoryMetadata(),
    "ChangeProposal": new ChangeProposalMetadata(),
    "ChangeRequest": new ChangeRequestMetadata(),
    "Citation": new CitationMetadata(),
    "Color": new ColorMetadata(),
    "CommonFileStore": new CommonFileStoreMetadata(),
    "CompoundParameterType": new CompoundParameterTypeMetadata(),
    "Constant": new ConstantMetadata(),
    "ContractChangeNotice": new ContractChangeNoticeMetadata(),
    "CyclicRatioScale": new CyclicRatioScaleMetadata(),
    "DateParameterType": new DateParameterTypeMetadata(),
    "DateTimeParameterType": new DateTimeParameterTypeMetadata(),
    "DecompositionRule": new DecompositionRuleMetadata(),
    "Definition": new DefinitionMetadata(),
    "DerivedQuantityKind": new DerivedQuantityKindMetadata(),
    "DerivedUnit": new DerivedUnitMetadata(),
    "DiagramCanvas": new DiagramCanvasMetadata(),
    "DiagramEdge": new DiagramEdgeMetadata(),
    "DiagramObject": new DiagramObjectMetadata(),
    "DomainFileStore": new DomainFileStoreMetadata(),
    "DomainOfExpertise": new DomainOfExpertiseMetadata(),
    "DomainOfExpertiseGroup": new DomainOfExpertiseGroupMetadata(),
    "ElementDefinition": new ElementDefinitionMetadata(),
    "ElementUsage": new ElementUsageMetadata(),
    "EmailAddress": new EmailAddressMetadata(),
    "EngineeringModel": new EngineeringModelMetadata(),
    "EngineeringModelDataDiscussionItem": new EngineeringModelDataDiscussionItemMetadata(),
    "EngineeringModelDataNote": new EngineeringModelDataNoteMetadata(),
    "EngineeringModelSetup": new EngineeringModelSetupMetadata(),
    "EnumerationParameterType": new EnumerationParameterTypeMetadata(),
    "EnumerationValueDefinition": new EnumerationValueDefinitionMetadata(),
    "ExclusiveOrExpression": new ExclusiveOrExpressionMetadata(),
    "ExternalIdentifierMap": new ExternalIdentifierMapMetadata(),
    "File": new FileMetadata(),
    "FileRevision": new FileRevisionMetadata(),
    "FileType": new FileTypeMetadata(),
    "Folder": new FolderMetadata(),
    "Glossary": new GlossaryMetadata(),
    "Goal": new GoalMetadata(),
    "HyperLink": new HyperLinkMetadata(),
    "IdCorrespondence": new IdCorrespondenceMetadata(),
    "IntervalScale": new IntervalScaleMetadata(),
    "Iteration": new IterationMetadata(),
    "IterationSetup": new IterationSetupMetadata(),
    "LinearConversionUnit": new LinearConversionUnitMetadata(),
    "LogarithmicScale": new LogarithmicScaleMetadata(),
    "MappingToReferenceScale": new MappingToReferenceScaleMetadata(),
    "ModellingThingReference": new ModellingThingReferenceMetadata(),
    "ModelLogEntry": new ModelLogEntryMetadata(),
    "ModelReferenceDataLibrary": new ModelReferenceDataLibraryMetadata(),
    "MultiRelationship": new MultiRelationshipMetadata(),
    "MultiRelationshipRule": new MultiRelationshipRuleMetadata(),
    "NaturalLanguage": new NaturalLanguageMetadata(),
    "NestedElement": new NestedElementMetadata(),
    "NestedParameter": new NestedParameterMetadata(),
    "NotExpression": new NotExpressionMetadata(),
    "Option": new OptionMetadata(),
    "OrdinalScale": new OrdinalScaleMetadata(),
    "OrExpression": new OrExpressionMetadata(),
    "Organization": new OrganizationMetadata(),
    "OwnedStyle": new OwnedStyleMetadata(),
    "Page": new PageMetadata(),
    "Parameter": new ParameterMetadata(),
    "ParameterGroup": new ParameterGroupMetadata(),
    "ParameterizedCategoryRule": new ParameterizedCategoryRuleMetadata(),
    "ParameterOverride": new ParameterOverrideMetadata(),
    "ParameterOverrideValueSet": new ParameterOverrideValueSetMetadata(),
    "ParameterSubscription": new ParameterSubscriptionMetadata(),
    "ParameterSubscriptionValueSet": new ParameterSubscriptionValueSetMetadata(),
    "ParameterTypeComponent": new ParameterTypeComponentMetadata(),
    "ParameterValueSet": new ParameterValueSetMetadata(),
    "ParametricConstraint": new ParametricConstraintMetadata(),
    "Participant": new ParticipantMetadata(),
    "ParticipantPermission": new ParticipantPermissionMetadata(),
    "ParticipantRole": new ParticipantRoleMetadata(),
    "Person": new PersonMetadata(),
    "PersonPermission": new PersonPermissionMetadata(),
    "PersonRole": new PersonRoleMetadata(),
    "Point": new PointMetadata(),
    "PossibleFiniteState": new PossibleFiniteStateMetadata(),
    "PossibleFiniteStateList": new PossibleFiniteStateListMetadata(),
    "PrefixedUnit": new PrefixedUnitMetadata(),
    "Publication": new PublicationMetadata(),
    "QuantityKindFactor": new QuantityKindFactorMetadata(),
    "RatioScale": new RatioScaleMetadata(),
    "ReferencerRule": new ReferencerRuleMetadata(),
    "ReferenceSource": new ReferenceSourceMetadata(),
    "RelationalExpression": new RelationalExpressionMetadata(),
    "RelationshipParameterValue": new RelationshipParameterValueMetadata(),
    "RequestForDeviation": new RequestForDeviationMetadata(),
    "RequestForWaiver": new RequestForWaiverMetadata(),
    "Requirement": new RequirementMetadata(),
    "RequirementsContainerParameterValue": new RequirementsContainerParameterValueMetadata(),
    "RequirementsGroup": new RequirementsGroupMetadata(),
    "RequirementsSpecification": new RequirementsSpecificationMetadata(),
    "ReviewItemDiscrepancy": new ReviewItemDiscrepancyMetadata(),
    "RuleVerificationList": new RuleVerificationListMetadata(),
    "RuleViolation": new RuleViolationMetadata(),
    "ScaleReferenceQuantityValue": new ScaleReferenceQuantityValueMetadata(),
    "ScaleValueDefinition": new ScaleValueDefinitionMetadata(),
    "Section": new SectionMetadata(),
    "SharedStyle": new SharedStyleMetadata(),
    "SimpleParameterValue": new SimpleParameterValueMetadata(),
    "SimpleQuantityKind": new SimpleQuantityKindMetadata(),
    "SimpleUnit": new SimpleUnitMetadata(),
    "SiteDirectory": new SiteDirectoryMetadata(),
    "SiteDirectoryDataAnnotation": new SiteDirectoryDataAnnotationMetadata(),
    "SiteDirectoryDataDiscussionItem": new SiteDirectoryDataDiscussionItemMetadata(),
    "SiteDirectoryThingReference": new SiteDirectoryThingReferenceMetadata(),
    "SiteLogEntry": new SiteLogEntryMetadata(),
    "SiteReferenceDataLibrary": new SiteReferenceDataLibraryMetadata(),
    "Solution": new SolutionMetadata(),
    "SpecializedQuantityKind": new SpecializedQuantityKindMetadata(),
    "Stakeholder": new StakeholderMetadata(),
    "StakeholderValue": new StakeholderValueMetadata(),
    "StakeHolderValueMap": new StakeHolderValueMapMetadata(),
    "StakeHolderValueMapSettings": new StakeHolderValueMapSettingsMetadata(),
    "TelephoneNumber": new TelephoneNumberMetadata(),
    "Term": new TermMetadata(),
    "TextParameterType": new TextParameterTypeMetadata(),
    "TextualNote": new TextualNoteMetadata(),
    "TimeOfDayParameterType": new TimeOfDayParameterTypeMetadata(),
    "UnitFactor": new UnitFactorMetadata(),
    "UnitPrefix": new UnitPrefixMetadata(),
    "UserPreference": new UserPreferenceMetadata(),
    "UserRuleVerification": new UserRuleVerificationMetadata(),
    "ValueGroup": new ValueGroupMetadata(),
  };

  /**
   * The dictionary of container information
   */
  const containerInfoData = {
    "ActionItem": new ContainerMetadata("EngineeringModel", "modellingAnnotation"),
    "ActualFiniteState": new ContainerMetadata("ActualFiniteStateList", "actualState"),
    "ActualFiniteStateList": new ContainerMetadata("Iteration", "actualFiniteStateList"),
    "Alias": new ContainerMetadata("DefinedThing", "alias"),
    "AndExpression": new ContainerMetadata("ParametricConstraint", "expression"),
    "Approval": new ContainerMetadata("ModellingAnnotationItem", "approvedBy"),
    "ArrayParameterType": new ContainerMetadata("ReferenceDataLibrary", "parameterType"),
    "BinaryNote": new ContainerMetadata("Page", "note"),
    "BinaryRelationship": new ContainerMetadata("Iteration", "relationship"),
    "BinaryRelationshipRule": new ContainerMetadata("ReferenceDataLibrary", "rule"),
    "Book": new ContainerMetadata("EngineeringModel", "book"),
    "BooleanExpression": new ContainerMetadata("ParametricConstraint", "expression"),
    "BooleanParameterType": new ContainerMetadata("ReferenceDataLibrary", "parameterType"),
    "Bounds": new ContainerMetadata("DiagramElementContainer", "bounds"),
    "BuiltInRuleVerification": new ContainerMetadata("RuleVerificationList", "ruleVerification"),
    "Category": new ContainerMetadata("ReferenceDataLibrary", "definedCategory"),
    "ChangeProposal": new ContainerMetadata("EngineeringModel", "modellingAnnotation"),
    "ChangeRequest": new ContainerMetadata("EngineeringModel", "modellingAnnotation"),
    "Citation": new ContainerMetadata("Definition", "citation"),
    "Color": new ContainerMetadata("DiagrammingStyle", "usedColor"),
    "CommonFileStore": new ContainerMetadata("EngineeringModel", "commonFileStore"),
    "CompoundParameterType": new ContainerMetadata("ReferenceDataLibrary", "parameterType"),
    "Constant": new ContainerMetadata("ReferenceDataLibrary", "constant"),
    "ContractChangeNotice": new ContainerMetadata("EngineeringModel", "modellingAnnotation"),
    "ContractDeviation": new ContainerMetadata("EngineeringModel", "modellingAnnotation"),
    "ConversionBasedUnit": new ContainerMetadata("ReferenceDataLibrary", "unit"),
    "CyclicRatioScale": new ContainerMetadata("ReferenceDataLibrary", "scale"),
    "DateParameterType": new ContainerMetadata("ReferenceDataLibrary", "parameterType"),
    "DateTimeParameterType": new ContainerMetadata("ReferenceDataLibrary", "parameterType"),
    "DecompositionRule": new ContainerMetadata("ReferenceDataLibrary", "rule"),
    "Definition": new ContainerMetadata("DefinedThing", "definition"),
    "DerivedQuantityKind": new ContainerMetadata("ReferenceDataLibrary", "parameterType"),
    "DerivedUnit": new ContainerMetadata("ReferenceDataLibrary", "unit"),
    "DiagramCanvas": new ContainerMetadata("Iteration", "diagramCanvas"),
    "DiagramEdge": new ContainerMetadata("DiagramElementContainer", "diagramElement"),
    "DiagramElementThing": new ContainerMetadata("DiagramElementContainer", "diagramElement"),
    "DiagramObject": new ContainerMetadata("DiagramElementContainer", "diagramElement"),
    "DiagramShape": new ContainerMetadata("DiagramElementContainer", "diagramElement"),
    "DomainFileStore": new ContainerMetadata("Iteration", "domainFileStore"),
    "DomainOfExpertise": new ContainerMetadata("SiteDirectory", "domain"),
    "DomainOfExpertiseGroup": new ContainerMetadata("SiteDirectory", "domainGroup"),
    "ElementDefinition": new ContainerMetadata("Iteration", "element"),
    "ElementUsage": new ContainerMetadata("ElementDefinition", "containedElement"),
    "EmailAddress": new ContainerMetadata("Person", "emailAddress"),
    "EngineeringModel": new ContainerMetadata("EngineeringModel", "EngineeringModel"),
    "EngineeringModelDataDiscussionItem": new ContainerMetadata("EngineeringModelDataAnnotation", "discussion"),
    "EngineeringModelDataNote": new ContainerMetadata("EngineeringModel", "genericNote"),
    "EngineeringModelSetup": new ContainerMetadata("SiteDirectory", "model"),
    "EnumerationParameterType": new ContainerMetadata("ReferenceDataLibrary", "parameterType"),
    "EnumerationValueDefinition": new ContainerMetadata("EnumerationParameterType", "valueDefinition"),
    "ExclusiveOrExpression": new ContainerMetadata("ParametricConstraint", "expression"),
    "ExternalIdentifierMap": new ContainerMetadata("Iteration", "externalIdentifierMap"),
    "File": new ContainerMetadata("FileStore", "file"),
    "FileRevision": new ContainerMetadata("File", "fileRevision"),
    "FileType": new ContainerMetadata("ReferenceDataLibrary", "fileType"),
    "Folder": new ContainerMetadata("FileStore", "folder"),
    "Glossary": new ContainerMetadata("ReferenceDataLibrary", "glossary"),
    "Goal": new ContainerMetadata("Iteration", "goal"),
    "HyperLink": new ContainerMetadata("DefinedThing", "hyperLink"),
    "IdCorrespondence": new ContainerMetadata("ExternalIdentifierMap", "correspondence"),
    "IntervalScale": new ContainerMetadata("ReferenceDataLibrary", "scale"),
    "Iteration": new ContainerMetadata("EngineeringModel", "iteration"),
    "IterationSetup": new ContainerMetadata("EngineeringModelSetup", "iterationSetup"),
    "LinearConversionUnit": new ContainerMetadata("ReferenceDataLibrary", "unit"),
    "LogarithmicScale": new ContainerMetadata("ReferenceDataLibrary", "scale"),
    "MappingToReferenceScale": new ContainerMetadata("MeasurementScale", "mappingToReferenceScale"),
    "MeasurementScale": new ContainerMetadata("ReferenceDataLibrary", "scale"),
    "MeasurementUnit": new ContainerMetadata("ReferenceDataLibrary", "unit"),
    "ModellingAnnotationItem": new ContainerMetadata("EngineeringModel", "modellingAnnotation"),
    "ModellingThingReference": new ContainerMetadata("EngineeringModelDataAnnotation", "relatedThing"),
    "ModelLogEntry": new ContainerMetadata("EngineeringModel", "logEntry"),
    "ModelReferenceDataLibrary": new ContainerMetadata("EngineeringModelSetup", "requiredRdl"),
    "MultiRelationship": new ContainerMetadata("Iteration", "relationship"),
    "MultiRelationshipRule": new ContainerMetadata("ReferenceDataLibrary", "rule"),
    "NaturalLanguage": new ContainerMetadata("SiteDirectory", "naturalLanguage"),
    "NestedElement": new ContainerMetadata("Option", "nestedElement"),
    "NestedParameter": new ContainerMetadata("NestedElement", "nestedParameter"),
    "Note": new ContainerMetadata("Page", "note"),
    "NotExpression": new ContainerMetadata("ParametricConstraint", "expression"),
    "Option": new ContainerMetadata("Iteration", "option"),
    "OrdinalScale": new ContainerMetadata("ReferenceDataLibrary", "scale"),
    "OrExpression": new ContainerMetadata("ParametricConstraint", "expression"),
    "Organization": new ContainerMetadata("SiteDirectory", "organization"),
    "OwnedStyle": new ContainerMetadata("DiagramElementThing", "localStyle"),
    "Page": new ContainerMetadata("Section", "page"),
    "Parameter": new ContainerMetadata("ElementDefinition", "parameter"),
    "ParameterGroup": new ContainerMetadata("ElementDefinition", "parameterGroup"),
    "ParameterizedCategoryRule": new ContainerMetadata("ReferenceDataLibrary", "rule"),
    "ParameterOverride": new ContainerMetadata("ElementUsage", "parameterOverride"),
    "ParameterOverrideValueSet": new ContainerMetadata("ParameterOverride", "valueSet"),
    "ParameterSubscription": new ContainerMetadata("ParameterOrOverrideBase", "parameterSubscription"),
    "ParameterSubscriptionValueSet": new ContainerMetadata("ParameterSubscription", "valueSet"),
    "ParameterType": new ContainerMetadata("ReferenceDataLibrary", "parameterType"),
    "ParameterTypeComponent": new ContainerMetadata("CompoundParameterType", "component"),
    "ParameterValueSet": new ContainerMetadata("Parameter", "valueSet"),
    "ParametricConstraint": new ContainerMetadata("Requirement", "parametricConstraint"),
    "Participant": new ContainerMetadata("EngineeringModelSetup", "participant"),
    "ParticipantPermission": new ContainerMetadata("ParticipantRole", "participantPermission"),
    "ParticipantRole": new ContainerMetadata("SiteDirectory", "participantRole"),
    "Person": new ContainerMetadata("SiteDirectory", "person"),
    "PersonPermission": new ContainerMetadata("PersonRole", "personPermission"),
    "PersonRole": new ContainerMetadata("SiteDirectory", "personRole"),
    "Point": new ContainerMetadata("DiagramEdge", "point"),
    "PossibleFiniteState": new ContainerMetadata("PossibleFiniteStateList", "possibleState"),
    "PossibleFiniteStateList": new ContainerMetadata("Iteration", "possibleFiniteStateList"),
    "PrefixedUnit": new ContainerMetadata("ReferenceDataLibrary", "unit"),
    "Publication": new ContainerMetadata("Iteration", "publication"),
    "QuantityKind": new ContainerMetadata("ReferenceDataLibrary", "parameterType"),
    "QuantityKindFactor": new ContainerMetadata("DerivedQuantityKind", "quantityKindFactor"),
    "RatioScale": new ContainerMetadata("ReferenceDataLibrary", "scale"),
    "ReferencerRule": new ContainerMetadata("ReferenceDataLibrary", "rule"),
    "ReferenceSource": new ContainerMetadata("ReferenceDataLibrary", "referenceSource"),
    "RelationalExpression": new ContainerMetadata("ParametricConstraint", "expression"),
    "Relationship": new ContainerMetadata("Iteration", "relationship"),
    "RelationshipParameterValue": new ContainerMetadata("Relationship", "parameterValue"),
    "RequestForDeviation": new ContainerMetadata("EngineeringModel", "modellingAnnotation"),
    "RequestForWaiver": new ContainerMetadata("EngineeringModel", "modellingAnnotation"),
    "Requirement": new ContainerMetadata("RequirementsSpecification", "requirement"),
    "RequirementsContainerParameterValue": new ContainerMetadata("RequirementsContainer", "parameterValue"),
    "RequirementsGroup": new ContainerMetadata("RequirementsContainer", "group"),
    "RequirementsSpecification": new ContainerMetadata("Iteration", "requirementsSpecification"),
    "ReviewItemDiscrepancy": new ContainerMetadata("EngineeringModel", "modellingAnnotation"),
    "Rule": new ContainerMetadata("ReferenceDataLibrary", "rule"),
    "RuleVerification": new ContainerMetadata("RuleVerificationList", "ruleVerification"),
    "RuleVerificationList": new ContainerMetadata("Iteration", "ruleVerificationList"),
    "RuleViolation": new ContainerMetadata("RuleVerification", "violation"),
    "ScalarParameterType": new ContainerMetadata("ReferenceDataLibrary", "parameterType"),
    "ScaleReferenceQuantityValue": new ContainerMetadata("LogarithmicScale", "referenceQuantityValue"),
    "ScaleValueDefinition": new ContainerMetadata("MeasurementScale", "valueDefinition"),
    "Section": new ContainerMetadata("Book", "section"),
    "SharedStyle": new ContainerMetadata("Iteration", "sharedDiagramStyle"),
    "SimpleParameterValue": new ContainerMetadata("SimpleParameterizableThing", "parameterValue"),
    "SimpleQuantityKind": new ContainerMetadata("ReferenceDataLibrary", "parameterType"),
    "SimpleUnit": new ContainerMetadata("ReferenceDataLibrary", "unit"),
    "SiteDirectory": new ContainerMetadata("SiteDirectory", "SiteDirectory"),
    "SiteDirectoryDataAnnotation": new ContainerMetadata("SiteDirectory", "annotation"),
    "SiteDirectoryDataDiscussionItem": new ContainerMetadata("SiteDirectoryDataAnnotation", "discussion"),
    "SiteDirectoryThingReference": new ContainerMetadata("SiteDirectoryDataAnnotation", "relatedThing"),
    "SiteLogEntry": new ContainerMetadata("SiteDirectory", "logEntry"),
    "SiteReferenceDataLibrary": new ContainerMetadata("SiteDirectory", "siteReferenceDataLibrary"),
    "Solution": new ContainerMetadata("ReviewItemDiscrepancy", "solution"),
    "SpecializedQuantityKind": new ContainerMetadata("ReferenceDataLibrary", "parameterType"),
    "Stakeholder": new ContainerMetadata("Iteration", "stakeholder"),
    "StakeholderValue": new ContainerMetadata("Iteration", "stakeholderValue"),
    "StakeHolderValueMap": new ContainerMetadata("Iteration", "stakeholderValueMap"),
    "StakeHolderValueMapSettings": new ContainerMetadata("StakeHolderValueMap", "settings"),
    "TelephoneNumber": new ContainerMetadata("Person", "telephoneNumber"),
    "Term": new ContainerMetadata("Glossary", "term"),
    "TextParameterType": new ContainerMetadata("ReferenceDataLibrary", "parameterType"),
    "TextualNote": new ContainerMetadata("Page", "note"),
    "TimeOfDayParameterType": new ContainerMetadata("ReferenceDataLibrary", "parameterType"),
    "UnitFactor": new ContainerMetadata("DerivedUnit", "unitFactor"),
    "UnitPrefix": new ContainerMetadata("ReferenceDataLibrary", "unitPrefix"),
    "UserPreference": new ContainerMetadata("Person", "userPreference"),
    "UserRuleVerification": new ContainerMetadata("RuleVerificationList", "ruleVerification"),
    "ValueGroup": new ContainerMetadata("Iteration", "valueGroup"),
  };

  /**
   * The dictionary of base type information
   */
  const baseTypeData = {
    "ActionItem": "ModellingAnnotationItem",
    "ActualFiniteState": "Thing",
    "ActualFiniteStateList": "Thing",
    "Alias": "Thing",
    "AndExpression": "BooleanExpression",
    "Approval": "GenericAnnotation",
    "ArrayParameterType": "CompoundParameterType",
    "BinaryNote": "Note",
    "BinaryRelationship": "Relationship",
    "BinaryRelationshipRule": "Rule",
    "Book": "Thing",
    "BooleanExpression": "Thing",
    "BooleanParameterType": "ScalarParameterType",
    "Bounds": "DiagramThingBase",
    "BuiltInRuleVerification": "RuleVerification",
    "Category": "DefinedThing",
    "ChangeProposal": "ModellingAnnotationItem",
    "ChangeRequest": "ContractDeviation",
    "Citation": "Thing",
    "Color": "DiagramThingBase",
    "CommonFileStore": "FileStore",
    "CompoundParameterType": "ParameterType",
    "Constant": "DefinedThing",
    "ContractChangeNotice": "ModellingAnnotationItem",
    "ContractDeviation": "ModellingAnnotationItem",
    "ConversionBasedUnit": "MeasurementUnit",
    "CyclicRatioScale": "RatioScale",
    "DateParameterType": "ScalarParameterType",
    "DateTimeParameterType": "ScalarParameterType",
    "DecompositionRule": "Rule",
    "DefinedThing": "Thing",
    "Definition": "Thing",
    "DerivedQuantityKind": "QuantityKind",
    "DerivedUnit": "MeasurementUnit",
    "DiagramCanvas": "DiagramElementContainer",
    "DiagramEdge": "DiagramElementThing",
    "DiagramElementContainer": "DiagramThingBase",
    "DiagramElementThing": "DiagramElementContainer",
    "DiagrammingStyle": "DiagramThingBase",
    "DiagramObject": "DiagramShape",
    "DiagramShape": "DiagramElementThing",
    "DiagramThingBase": "Thing",
    "DiscussionItem": "GenericAnnotation",
    "DomainFileStore": "FileStore",
    "DomainOfExpertise": "DefinedThing",
    "DomainOfExpertiseGroup": "DefinedThing",
    "ElementBase": "DefinedThing",
    "ElementDefinition": "ElementBase",
    "ElementUsage": "ElementBase",
    "EmailAddress": "Thing",
    "EngineeringModel": "TopContainer",
    "EngineeringModelDataAnnotation": "GenericAnnotation",
    "EngineeringModelDataDiscussionItem": "DiscussionItem",
    "EngineeringModelDataNote": "EngineeringModelDataAnnotation",
    "EngineeringModelSetup": "DefinedThing",
    "EnumerationParameterType": "ScalarParameterType",
    "EnumerationValueDefinition": "DefinedThing",
    "ExclusiveOrExpression": "BooleanExpression",
    "ExternalIdentifierMap": "Thing",
    "File": "Thing",
    "FileRevision": "Thing",
    "FileStore": "Thing",
    "FileType": "DefinedThing",
    "Folder": "Thing",
    "GenericAnnotation": "Thing",
    "Glossary": "DefinedThing",
    "Goal": "DefinedThing",
    "HyperLink": "Thing",
    "IdCorrespondence": "Thing",
    "IntervalScale": "MeasurementScale",
    "Iteration": "Thing",
    "IterationSetup": "Thing",
    "LinearConversionUnit": "ConversionBasedUnit",
    "LogarithmicScale": "MeasurementScale",
    "MappingToReferenceScale": "Thing",
    "MeasurementScale": "DefinedThing",
    "MeasurementUnit": "DefinedThing",
    "ModellingAnnotationItem": "EngineeringModelDataAnnotation",
    "ModellingThingReference": "ThingReference",
    "ModelLogEntry": "Thing",
    "ModelReferenceDataLibrary": "ReferenceDataLibrary",
    "MultiRelationship": "Relationship",
    "MultiRelationshipRule": "Rule",
    "NaturalLanguage": "Thing",
    "NestedElement": "Thing",
    "NestedParameter": "Thing",
    "Note": "Thing",
    "NotExpression": "BooleanExpression",
    "Option": "DefinedThing",
    "OrdinalScale": "MeasurementScale",
    "OrExpression": "BooleanExpression",
    "Organization": "Thing",
    "OwnedStyle": "DiagrammingStyle",
    "Page": "Thing",
    "Parameter": "ParameterOrOverrideBase",
    "ParameterBase": "Thing",
    "ParameterGroup": "Thing",
    "ParameterizedCategoryRule": "Rule",
    "ParameterOrOverrideBase": "ParameterBase",
    "ParameterOverride": "ParameterOrOverrideBase",
    "ParameterOverrideValueSet": "ParameterValueSetBase",
    "ParameterSubscription": "ParameterBase",
    "ParameterSubscriptionValueSet": "Thing",
    "ParameterType": "DefinedThing",
    "ParameterTypeComponent": "Thing",
    "ParameterValue": "Thing",
    "ParameterValueSet": "ParameterValueSetBase",
    "ParameterValueSetBase": "Thing",
    "ParametricConstraint": "Thing",
    "Participant": "Thing",
    "ParticipantPermission": "Thing",
    "ParticipantRole": "DefinedThing",
    "Person": "Thing",
    "PersonPermission": "Thing",
    "PersonRole": "DefinedThing",
    "Point": "DiagramThingBase",
    "PossibleFiniteState": "DefinedThing",
    "PossibleFiniteStateList": "DefinedThing",
    "PrefixedUnit": "ConversionBasedUnit",
    "Publication": "Thing",
    "QuantityKind": "ScalarParameterType",
    "QuantityKindFactor": "Thing",
    "RatioScale": "MeasurementScale",
    "ReferenceDataLibrary": "DefinedThing",
    "ReferencerRule": "Rule",
    "ReferenceSource": "DefinedThing",
    "RelationalExpression": "BooleanExpression",
    "Relationship": "Thing",
    "RelationshipParameterValue": "ParameterValue",
    "RequestForDeviation": "ContractDeviation",
    "RequestForWaiver": "ContractDeviation",
    "Requirement": "SimpleParameterizableThing",
    "RequirementsContainer": "DefinedThing",
    "RequirementsContainerParameterValue": "ParameterValue",
    "RequirementsGroup": "RequirementsContainer",
    "RequirementsSpecification": "RequirementsContainer",
    "ReviewItemDiscrepancy": "ModellingAnnotationItem",
    "Rule": "DefinedThing",
    "RuleVerification": "Thing",
    "RuleVerificationList": "DefinedThing",
    "RuleViolation": "Thing",
    "ScalarParameterType": "ParameterType",
    "ScaleReferenceQuantityValue": "Thing",
    "ScaleValueDefinition": "DefinedThing",
    "Section": "Thing",
    "SharedStyle": "DiagrammingStyle",
    "SimpleParameterizableThing": "DefinedThing",
    "SimpleParameterValue": "Thing",
    "SimpleQuantityKind": "QuantityKind",
    "SimpleUnit": "MeasurementUnit",
    "SiteDirectory": "TopContainer",
    "SiteDirectoryDataAnnotation": "GenericAnnotation",
    "SiteDirectoryDataDiscussionItem": "DiscussionItem",
    "SiteDirectoryThingReference": "ThingReference",
    "SiteLogEntry": "Thing",
    "SiteReferenceDataLibrary": "ReferenceDataLibrary",
    "Solution": "GenericAnnotation",
    "SpecializedQuantityKind": "QuantityKind",
    "Stakeholder": "DefinedThing",
    "StakeholderValue": "DefinedThing",
    "StakeHolderValueMap": "DefinedThing",
    "StakeHolderValueMapSettings": "Thing",
    "TelephoneNumber": "Thing",
    "Term": "DefinedThing",
    "TextParameterType": "ScalarParameterType",
    "TextualNote": "Note",
    "Thing": "",
    "ThingReference": "Thing",
    "TimeOfDayParameterType": "ScalarParameterType",
    "TopContainer": "Thing",
    "UnitFactor": "Thing",
    "UnitPrefix": "DefinedThing",
    "UserPreference": "Thing",
    "UserRuleVerification": "RuleVerification",
    "ValueGroup": "DefinedThing",
  };

  /**
   * Get the metadata class for a Thing
   */
  export function getMetadata(classKind: string): IThingMetadata {
    const metadata = thingMetadata[classKind];
    if (Utils.isUndefinedOrNull(metadata)) {
      throw new Error("no metadata found for " + classKind);
    }

    return metadata;
  }

  /**
   * Get the default person permission for a Thing
   */
  export function getDefaultPersonPermission(classKind: string): Dto.PersonAccessRightKind {
    // The dictionary of default Person Permission
    const defaultPersonPermissionData: { [property: string] : Dto.PersonAccessRightKind } = {
      "ActionItem": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ActualFiniteState": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ActualFiniteStateList": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "Alias": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "AndExpression": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "Approval": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ArrayParameterType": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "BinaryNote": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "BinaryRelationship": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "BinaryRelationshipRule": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "Book": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "BooleanExpression": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "BooleanParameterType": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "Bounds": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "BuiltInRuleVerification": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "Category": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "ChangeProposal": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ChangeRequest": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "Citation": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "Color": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "CommonFileStore": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "CompoundParameterType": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "Constant": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "ContractChangeNotice": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ContractDeviation": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ConversionBasedUnit": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "CyclicRatioScale": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "DateParameterType": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "DateTimeParameterType": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "DecompositionRule": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "DefinedThing": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "Definition": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "DerivedQuantityKind": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "DerivedUnit": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "DiagramCanvas": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "DiagramEdge": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "DiagramElementContainer": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "DiagramElementThing": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "DiagrammingStyle": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "DiagramObject": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "DiagramShape": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "DiagramThingBase": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "DiscussionItem": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "DomainFileStore": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "DomainOfExpertise": Dto.PersonAccessRightKind.NONE,
      "DomainOfExpertiseGroup": Dto.PersonAccessRightKind.NONE,
      "ElementBase": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ElementDefinition": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ElementUsage": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "EmailAddress": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "EngineeringModel": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "EngineeringModelDataAnnotation": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "EngineeringModelDataDiscussionItem": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "EngineeringModelDataNote": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "EngineeringModelSetup": Dto.PersonAccessRightKind.NONE,
      "EnumerationParameterType": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "EnumerationValueDefinition": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "ExclusiveOrExpression": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ExternalIdentifierMap": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "File": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "FileRevision": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "FileStore": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "FileType": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "Folder": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "GenericAnnotation": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "Glossary": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "Goal": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "HyperLink": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "IdCorrespondence": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "IntervalScale": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "Iteration": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "IterationSetup": Dto.PersonAccessRightKind.NONE,
      "LinearConversionUnit": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "LogarithmicScale": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "MappingToReferenceScale": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "MeasurementScale": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "MeasurementUnit": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "ModellingAnnotationItem": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ModellingThingReference": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ModelLogEntry": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ModelReferenceDataLibrary": Dto.PersonAccessRightKind.NONE,
      "MultiRelationship": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "MultiRelationshipRule": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "NaturalLanguage": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "NestedElement": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "NestedParameter": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "Note": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "NotExpression": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "Option": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "OrdinalScale": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "OrExpression": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "Organization": Dto.PersonAccessRightKind.NONE,
      "OwnedStyle": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "Page": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "Parameter": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ParameterBase": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ParameterGroup": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ParameterizedCategoryRule": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "ParameterOrOverrideBase": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ParameterOverride": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ParameterOverrideValueSet": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ParameterSubscription": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ParameterSubscriptionValueSet": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ParameterType": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "ParameterTypeComponent": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "ParameterValue": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ParameterValueSet": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ParameterValueSetBase": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ParametricConstraint": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "Participant": Dto.PersonAccessRightKind.NONE,
      "ParticipantPermission": Dto.PersonAccessRightKind.NONE,
      "ParticipantRole": Dto.PersonAccessRightKind.NONE,
      "Person": Dto.PersonAccessRightKind.NONE,
      "PersonPermission": Dto.PersonAccessRightKind.NONE,
      "PersonRole": Dto.PersonAccessRightKind.NONE,
      "Point": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "PossibleFiniteState": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "PossibleFiniteStateList": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "PrefixedUnit": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "Publication": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "QuantityKind": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "QuantityKindFactor": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "RatioScale": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "ReferenceDataLibrary": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ReferencerRule": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "ReferenceSource": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "RelationalExpression": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "Relationship": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "RelationshipParameterValue": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "RequestForDeviation": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "RequestForWaiver": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "Requirement": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "RequirementsContainer": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "RequirementsContainerParameterValue": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "RequirementsGroup": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "RequirementsSpecification": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ReviewItemDiscrepancy": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "Rule": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "RuleVerification": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "RuleVerificationList": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "RuleViolation": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ScalarParameterType": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "ScaleReferenceQuantityValue": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "ScaleValueDefinition": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "Section": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "SharedStyle": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "SimpleParameterizableThing": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "SimpleParameterValue": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "SimpleQuantityKind": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "SimpleUnit": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "SiteDirectory": Dto.PersonAccessRightKind.NONE,
      "SiteDirectoryDataAnnotation": Dto.PersonAccessRightKind.NONE,
      "SiteDirectoryDataDiscussionItem": Dto.PersonAccessRightKind.NONE,
      "SiteDirectoryThingReference": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "SiteLogEntry": Dto.PersonAccessRightKind.NONE,
      "SiteReferenceDataLibrary": Dto.PersonAccessRightKind.NONE,
      "Solution": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "SpecializedQuantityKind": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "Stakeholder": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "StakeholderValue": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "StakeHolderValueMap": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "StakeHolderValueMapSettings": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "TelephoneNumber": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "Term": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "TextParameterType": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "TextualNote": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "Thing": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ThingReference": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "TimeOfDayParameterType": Dto.PersonAccessRightKind.SAME_AS_SUPERCLASS,
      "TopContainer": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "UnitFactor": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "UnitPrefix": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "UserPreference": Dto.PersonAccessRightKind.SAME_AS_CONTAINER,
      "UserRuleVerification": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "ValueGroup": Dto.PersonAccessRightKind.NOT_APPLICABLE,
      "NotThing": Dto.PersonAccessRightKind.NOT_APPLICABLE
    };

    const personPermission = defaultPersonPermissionData[classKind];
    if (Utils.isUndefinedOrNull(personPermission)) {
      throw new Error("No default Person Permission found for " + classKind);
    }

    return personPermission;
  }

  /**
   * Get the default participant permission for a Thing
   */
  export function getDefaultParticipantPermission(classKind: string): Dto.ParticipantAccessRightKind {
    // The dictionary of default Participant Permission
    const defaultParticipantPermissionData: { [property: string] : Dto.ParticipantAccessRightKind } = {
      "ActionItem": Dto.ParticipantAccessRightKind.NONE,
      "ActualFiniteState": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "ActualFiniteStateList": Dto.ParticipantAccessRightKind.NONE,
      "Alias": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "AndExpression": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "Approval": Dto.ParticipantAccessRightKind.NONE,
      "ArrayParameterType": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "BinaryNote": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "BinaryRelationship": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "BinaryRelationshipRule": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "Book": Dto.ParticipantAccessRightKind.NONE,
      "BooleanExpression": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "BooleanParameterType": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "Bounds": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "BuiltInRuleVerification": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "Category": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "ChangeProposal": Dto.ParticipantAccessRightKind.NONE,
      "ChangeRequest": Dto.ParticipantAccessRightKind.NONE,
      "Citation": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "Color": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "CommonFileStore": Dto.ParticipantAccessRightKind.NONE,
      "CompoundParameterType": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "Constant": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "ContractChangeNotice": Dto.ParticipantAccessRightKind.NONE,
      "ContractDeviation": Dto.ParticipantAccessRightKind.NONE,
      "ConversionBasedUnit": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "CyclicRatioScale": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "DateParameterType": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "DateTimeParameterType": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "DecompositionRule": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "DefinedThing": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "Definition": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "DerivedQuantityKind": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "DerivedUnit": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "DiagramCanvas": Dto.ParticipantAccessRightKind.NONE,
      "DiagramEdge": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "DiagramElementContainer": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "DiagramElementThing": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "DiagrammingStyle": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "DiagramObject": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "DiagramShape": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "DiagramThingBase": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "DiscussionItem": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "DomainFileStore": Dto.ParticipantAccessRightKind.NONE,
      "DomainOfExpertise": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "DomainOfExpertiseGroup": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "ElementBase": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "ElementDefinition": Dto.ParticipantAccessRightKind.NONE,
      "ElementUsage": Dto.ParticipantAccessRightKind.NONE,
      "EmailAddress": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "EngineeringModel": Dto.ParticipantAccessRightKind.NONE,
      "EngineeringModelDataAnnotation": Dto.ParticipantAccessRightKind.NONE,
      "EngineeringModelDataDiscussionItem": Dto.ParticipantAccessRightKind.NONE,
      "EngineeringModelDataNote": Dto.ParticipantAccessRightKind.NONE,
      "EngineeringModelSetup": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "EnumerationParameterType": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "EnumerationValueDefinition": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "ExclusiveOrExpression": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "ExternalIdentifierMap": Dto.ParticipantAccessRightKind.NONE,
      "File": Dto.ParticipantAccessRightKind.NONE,
      "FileRevision": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "FileStore": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "FileType": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "Folder": Dto.ParticipantAccessRightKind.NONE,
      "GenericAnnotation": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "Glossary": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "Goal": Dto.ParticipantAccessRightKind.NONE,
      "HyperLink": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "IdCorrespondence": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "IntervalScale": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "Iteration": Dto.ParticipantAccessRightKind.NONE,
      "IterationSetup": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "LinearConversionUnit": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "LogarithmicScale": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "MappingToReferenceScale": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "MeasurementScale": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "MeasurementUnit": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "ModellingAnnotationItem": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "ModellingThingReference": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "ModelLogEntry": Dto.ParticipantAccessRightKind.NONE,
      "ModelReferenceDataLibrary": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "MultiRelationship": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "MultiRelationshipRule": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "NaturalLanguage": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "NestedElement": Dto.ParticipantAccessRightKind.NONE,
      "NestedParameter": Dto.ParticipantAccessRightKind.NONE,
      "Note": Dto.ParticipantAccessRightKind.NONE,
      "NotExpression": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "Option": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "OrdinalScale": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "OrExpression": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "Organization": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "OwnedStyle": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "Page": Dto.ParticipantAccessRightKind.NONE,
      "Parameter": Dto.ParticipantAccessRightKind.NONE,
      "ParameterBase": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "ParameterGroup": Dto.ParticipantAccessRightKind.NONE,
      "ParameterizedCategoryRule": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "ParameterOrOverrideBase": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "ParameterOverride": Dto.ParticipantAccessRightKind.NONE,
      "ParameterOverrideValueSet": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "ParameterSubscription": Dto.ParticipantAccessRightKind.NONE,
      "ParameterSubscriptionValueSet": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "ParameterType": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "ParameterTypeComponent": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "ParameterValue": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "ParameterValueSet": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "ParameterValueSetBase": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "ParametricConstraint": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "Participant": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "ParticipantPermission": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "ParticipantRole": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "Person": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "PersonPermission": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "PersonRole": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "Point": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "PossibleFiniteState": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "PossibleFiniteStateList": Dto.ParticipantAccessRightKind.NONE,
      "PrefixedUnit": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "Publication": Dto.ParticipantAccessRightKind.NONE,
      "QuantityKind": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "QuantityKindFactor": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "RatioScale": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "ReferenceDataLibrary": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "ReferencerRule": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "ReferenceSource": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "RelationalExpression": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "Relationship": Dto.ParticipantAccessRightKind.NONE,
      "RelationshipParameterValue": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "RequestForDeviation": Dto.ParticipantAccessRightKind.NONE,
      "RequestForWaiver": Dto.ParticipantAccessRightKind.NONE,
      "Requirement": Dto.ParticipantAccessRightKind.NONE,
      "RequirementsContainer": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "RequirementsContainerParameterValue": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "RequirementsGroup": Dto.ParticipantAccessRightKind.NONE,
      "RequirementsSpecification": Dto.ParticipantAccessRightKind.NONE,
      "ReviewItemDiscrepancy": Dto.ParticipantAccessRightKind.NONE,
      "Rule": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "RuleVerification": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "RuleVerificationList": Dto.ParticipantAccessRightKind.NONE,
      "RuleViolation": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "ScalarParameterType": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "ScaleReferenceQuantityValue": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "ScaleValueDefinition": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "Section": Dto.ParticipantAccessRightKind.NONE,
      "SharedStyle": Dto.ParticipantAccessRightKind.NONE,
      "SimpleParameterizableThing": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "SimpleParameterValue": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "SimpleQuantityKind": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "SimpleUnit": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "SiteDirectory": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "SiteDirectoryDataAnnotation": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "SiteDirectoryDataDiscussionItem": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "SiteDirectoryThingReference": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "SiteLogEntry": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "SiteReferenceDataLibrary": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "Solution": Dto.ParticipantAccessRightKind.NONE,
      "SpecializedQuantityKind": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "Stakeholder": Dto.ParticipantAccessRightKind.NONE,
      "StakeholderValue": Dto.ParticipantAccessRightKind.NONE,
      "StakeHolderValueMap": Dto.ParticipantAccessRightKind.NONE,
      "StakeHolderValueMapSettings": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "TelephoneNumber": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "Term": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "TextParameterType": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "TextualNote": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "Thing": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "ThingReference": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "TimeOfDayParameterType": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "TopContainer": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "UnitFactor": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "UnitPrefix": Dto.ParticipantAccessRightKind.SAME_AS_CONTAINER,
      "UserPreference": Dto.ParticipantAccessRightKind.NOT_APPLICABLE,
      "UserRuleVerification": Dto.ParticipantAccessRightKind.SAME_AS_SUPERCLASS,
      "ValueGroup": Dto.ParticipantAccessRightKind.NONE,
      "NotThing": Dto.ParticipantAccessRightKind.NOT_APPLICABLE
    };

    const participantPermission = defaultParticipantPermissionData[classKind];
    if (Utils.isUndefinedOrNull(participantPermission)) {
      throw new Error("No default Participant Permission found for " + classKind);
    }

    return participantPermission;
  }

  /**
   * Get the base type for a thing
   */
  export function getBaseType(classKind: string): string {
    const basetype = baseTypeData[classKind];
    if (Utils.isUndefinedOrNull(basetype)) {
      throw new Error("No base type found for " + classKind);
    }

    return basetype;
  }

  /**
   * Get the container data for a Thing
   */
  export function getContainerInfo(classKind: string): ContainerMetadata {
    const containerInfo = containerInfoData[classKind];
    if (Utils.isUndefinedOrNull(containerInfo)) {
      throw new Error("No container info found for " + classKind);
    }

    return containerInfo;
  }
}
